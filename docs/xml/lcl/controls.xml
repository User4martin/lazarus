<?xml version="1.0"?>
<fpdoc-descriptions>
  <package name="LCL">
    <!--
  ====================================================================
    Controls
  ====================================================================
-->
    <module name="Controls">
      <short>This unit contains basic classes for visual controls.</short>
      <descr/>
      <!-- unresolved type reference Visibility: default -->
      <element name="Classes">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="SysUtils">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="TypInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLStrConsts">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLProc">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="GraphType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="Graphics">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LMessages">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLIntf">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="InterfaceBase">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="ImgList">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="PropertyStorage">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="Menus">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="ActnList">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLClasses">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrNone">
        <short>Modal dialog left with None button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrOK">
        <short>Modal dialog left with OK button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrCancel">
        <short>Modal dialog left with Cancel button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrAbort">
        <short>Modal dialog aborted.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrRetry">
        <short>Modal dialog left with Retry button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrIgnore">
        <short>Modal dialog left with Ignore button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrYes">
        <short>Modal dialog left with Yes button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrNo">
        <short>Modal dialog left with No button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrAll">
        <short>Modal dialog left with All button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrNoToAll">
        <short>Modal dialog left with NoToAll button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrYesToAll">
        <short>Modal dialog left with YesToAll button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrClose">
        <short>Modal dialog left with Close button.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrLast">
        <short>Last (highest) value of modal results.</short>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TWinControlClass">
        <short>
          <var>TWinControlClass</var> - class of 
          
          <var>TWinControl</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TControlClass">
        <short>
          <var>TControlClass</var> - class of 
          
          <var>TControl</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- "type" alias type Visibility: default -->
      <element name="TDate">
        <short>Date expressed in the encoded <link id="TDateTime"/> type.</short>
        <descr>Variables of this type contain both date and time, but only one of these should be used.
        </descr>
      </element>
      <!-- "type" alias type Visibility: default -->
      <element link="TDate" name="TTime">
        <short>Time of day expressed in the encoded encoded <link id="TDateTime"/> type</short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMMouseWheel">
        <short>Parameters of a CMMouseWheel message.</short>
        <descr>
          <pre>Details held include:
          the Message associated with the wheel;
          the shift state (ie whether Shift, Alt, Control etc keys have been pressed);
          mouse position and the message Result.</pre>
        </descr>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.MSg">
        <short>The exact Message ID (WM_MOUSEWHEEL?).</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.ShiftState">
        <short>State of modifier keys and mouse buttons.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.Unused">
        <short>inserted for alignment only.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMMouseWheel.WheelData">
        <short>How many notches the wheel has been turned; negative for turned backwards.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMMouseWheel.Pos">
        <short>Mouse position.</short>
      </element>
      <element name="TCMMouseWheel.XPos">
        <short>Mouse X position.</short>
      </element>
      <element name="TCMMouseWheel.YPos">
        <short>Mouse Y position.</short>
      </element>
      <element name="TCMMouseWheel.Result">
        <short>Zero indicates that the message was handled.</short>
      </element>
      <!-- alias type Visibility: default -->
      <element link="TLMNCHitTest" name="TCMHitTest"/>
      <element link="TLMMouse" name="TCMDesignHitTest"/>
      <!-- record type Visibility: default -->
      <element name="TCMControlChange">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TCMControlChange.Msg">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMControlChange.Control">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMControlChange.Inserting">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMControlChange.Result">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMControlListChange">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TCMControlListChange.Msg">
        <short/>
      </element>
      <element name="TCMControlListChange.Control">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMControlListChange.Inserting">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMControlListChange.Result">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element link="TLMKey" name="TCMDialogChar">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- alias type Visibility: default -->
      <element link="TLMKey" name="TCMDialogKey">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- alias type Visibility: default -->
      <element link="TLMEnter" name="TCMEnter">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- alias type Visibility: default -->
      <element link="TLMExit" name="TCMExit">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMCancelMode">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TCMCancelMode.Msg">
        <short/>
      </element>
      <element name="TCMCancelMode.Unused">
        <short/>
      </element>
      <element name="TCMCancelMode.Sender">
        <short/>
      </element>
      <element name="TCMCancelMode.Result">
        <short/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMChildKey">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TCMChildKey.Msg">
        <short/>
      </element>
      <element name="TCMChildKey.Unused"/>
      <element name="TCMChildKey.CharCode">
        <short>VK_XXX constants for TLMKeyDown/Up, ASCII for TLMChar.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TCMChildKey.Sender">
        <short/>
      </element>
      <element name="TCMChildKey.Result">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAlign">
        <short>Alignment options for a control, within its Parent control.</short>
        <descr>
          <p>A control can be aligned as:</p>
          <dl>
            <dt>alNone</dt>
            <dd>fixed position and extent</dd>
            <dt>alTop</dt>
            <dd>stacked at top, full width</dd>
            <dt>alBottom</dt>
            <dd>stacked at bottom, full width</dd>
            <dt>alLeft</dt>
            <dd>stacked at left, full height</dd>
            <dt>alRight</dt>
            <dd>stacked at right, full height</dd>
            <dt>alClient</dt>
            <dd>filling entire remaining client area</dd>
            <dt>alCustom</dt>
            <dd>other alignment, in drag-dock: notebook</dd>
          </dl>
          <p>At most one control can have alClient alignment.</p>
          <p>The order of multiple controls of the same (stackable) alignment is determined by their Left or Top coordinate.</p>
          <p>The precedence of conflicting alignment requests (e.g. one at top, one at right) is resolved</p>
        </descr>
      <notes><note>how???</note><note>which provisions exist for alCustom implementation?</note>
        </notes>
      </element>
      <element name="TAlign.alNone">
        <short>Control has fixed size and position</short>
      </element>
      <element name="TAlign.alTop">
        <short>Control stacked at top, full width.</short>
      </element>
      <element name="TAlign.alBottom">
        <short>Control stacked at bottom, full width.</short>
      </element>
      <element name="TAlign.alLeft">
        <short>Control stacked at left, full height.</short>
      </element>
      <element name="TAlign.alRight">
        <short>Control stacked at right, full height.</short>
      </element>
      <element name="TAlign.alClient">
        <short>Control fills remaining client area.</short>
      </element>
      <element name="TAlign.alCustom">
        <short>Control has special alignment.</short>
        <descr/>
      <notes><note>aligned how?</note>
        </notes>
      </element>
      <!-- set type Visibility: default -->
      <element link="TAlign" name="TAlignSet">
        <short>Set of alignment options.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAnchorKind">
        <short>The control side to be anchored.</short>
        <descr>With asrCenter the sides mean horizontal or vertical alignment, of the control's center.
        </descr>
      </element>
      <element name="TAnchorKind.akTop">
        <short>Top side (or center vertically).</short>
      </element>
      <element name="TAnchorKind.akLeft">
        <short>Left side (or center horizonally).</short>
      </element>
      <element name="TAnchorKind.akRight">
        <short>Right side (or center horizontally).</short>
      </element>
      <element name="TAnchorKind.akBottom">
        <short>Bottom side (or center vertically).</short>
      </element>
      <!-- set type Visibility: default -->
      <element link="TAnchorKind" name="TAnchors"/>
      <!-- constant Visibility: default -->
      <element name="AnchorAlign">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- constant Visibility: default -->
      <element link="TAnchorKind" name="MainAlignAnchor">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- constant Visibility: default -->
      <element link="TAnchorKind" name="OppositeAnchor">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- constant Visibility: default -->
      <element link="TAnchorKind" name="ClockwiseAnchor">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefaultSideForAnchorKind">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- constant Visibility: default -->
      <element name="AnchorReferenceSide">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- constant Visibility: default -->
      <element name="AlignNames">
        <short>Array of names for the <link id="TAlign"/> elements.</short>
        <descr>
          <remark>The names include the 'al' prefix, e.g. alNone.</remark>
        </descr>
      </element>
      <!-- constant Visibility: default -->
      <element link="TAnchorKind" name="AnchorNames">
        <short>Names for the TAnchorKind elements.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAnchorSideReference">
        <short>The side of another control, to which this control's side is anchored.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSideReference.asrTop">
        <short>Anchor to the top side.</short>
      </element>
      <element name="TAnchorSideReference.asrBottom">
        <short>Anchor to the bottom side.</short>
      </element>
      <element name="TAnchorSideReference.asrCenter">
        <short>Anchor to the center of the other control.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="asrLeft">
        <short>Anchor to the left side (=asrTop).</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="asrRight">
        <short>Anchor to the right side (=asrBottom).</short>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCaption">
        <short>A string type for the caption of a control: may be translated</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFormStyle">
        <short>Defines special form behaviour.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TFormStyle.fsNormal">
        <short>An ordinary (overlapping) form.</short>
      </element>
      <element name="TFormStyle.fsMDIChild">
        <short>The form is an MDI child.</short>
      </element>
      <element name="TFormStyle.fsMDIForm">
        <short>The form is an MDI parent form, containing MDI child forms.</short>
      </element>
      <element name="TFormStyle.fsStayOnTop">
        <short>The form is in the foreground, on top of all other application forms.</short>
      </element>
      <element name="TFormStyle.fsSplash">
        <short>A splash form.</short>
      <notes><note>meaning what?</note>
        </notes>
      </element>
      <element name="TFormStyle.fsSystemStayOnTop">
        <short>The form stays system-wide on top.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- constant Visibility: default -->
      <element name="fsAllStayOnTop">
        <short>Set of form styles, which make a form stay on top.</short>
        <descr/>
        <seealso>
          <link id="TFormStyle"/>
        </seealso>
      </element>
      <!-- constant Visibility: default -->
      <element name="fsAllNonSystemStayOnTop">
        <short>Set of form styles, except those which make a form stay on top of all other forms of the system</short>
        <seealso>
          <link id="TFormStyle"/>
        </seealso>
      <notes><note>not system-wide?</note>
        </notes>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFormBorderStyle">
        <short>Style of a form's border.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TFormBorderStyle.bsNone">
        <short>No border at all.</short>
      </element>
      <element name="TFormBorderStyle.bsSingle">
        <short>Single line border, the form cannot be resized.</short>
      </element>
      <element name="TFormBorderStyle.bsSizeable">
        <short>The form can be resized (standard).</short>
      </element>
      <element name="TFormBorderStyle.bsDialog">
        <short>The form is a dialog, cannot be resized.</short>
      <notes><note>legacy?</note>
        </notes>
      </element>
      <element name="TFormBorderStyle.bsToolWindow">
        <short>Single line border, small caption, not resizeable.</short>
      </element>
      <element name="TFormBorderStyle.bsSizeToolWin">
        <short>Small caption, form can be resized.</short>
      </element>
      <!-- range type Visibility: default -->
      <element link="TFormBorderStyle" name="TBorderStyle">
        <short>Possible types of borders (with or without border).</short>
        <seealso/>
      <notes><note>used where?</note>
        </notes>
      </element>
      <!-- alias type Visibility: default -->
      <element link="TFormBorderStyle" name="TControlBorderStyle">
        <short>Possible types of control borders (with or without border).</short>
        <descr>A subset of TFormBorderStyle, listing only the styles available to a control that is not a form.</descr>
        <seealso/>
      <notes><note>used where?</note>
        </notes>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlRoleForForm">
        <short>Possible default actions on special keys.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlRoleForForm.crffDefault">
        <short>This control is notified when the user presses Return.</short>
      </element>
      <element name="TControlRoleForForm.crffCancel">
        <short>This control is notified when the user presses Escape.</short>
      </element>
      <!-- set type Visibility: default -->
      <element link="TControlRoleForForm" name="TControlRolesForForm"/>
      <!-- alias type Visibility: default -->
      <element link="TGraphicsBevelCut" name="TBevelCut"/>
      <!-- enumeration type Visibility: default -->
      <element name="TMouseButton">
        <short>Enumeration of recognized mouse buttons.</short>
        <descr>
          <p>These are <b>logical</b> buttons, left and right physical buttons can be swapped for left handed users.</p>
        </descr>
      </element>
      <element name="TMouseButton.mbLeft">
        <short>Represents the left mouse button. It might be physically the right button if the system is configured to act like that, for example for a left handled person.</short>
      </element>
      <element name="TMouseButton.mbRight">
        <short>Represents the right mouse button. It might be physically the left button if the system is configured to act like that, for example for a left handled person.</short>
      </element>
      <element name="TMouseButton.mbMiddle">
        <short>Represents the middle mouse button.</short>
      </element>
      <element name="TMouseButton.mbExtra1">
        <short>Represents the first extra mouse button.</short>
      </element>
      <element name="TMouseButton.mbExtra2">
        <short>Represents the second extra mouse button.</short>
      </element>
      <!-- range type Visibility: default -->
      <element name="TCursor">
        <short>
          <var>TCursor</var> - integer type defining range of values for cursor shapes.</short>
        <descr>
          <p>Allowed values are:</p>
          <pre>Standard cursors
  crDefault     = TCursor(0);   //current cursor unchanged
  crNone        = TCursor(-1);  //hide cursor
  crArrow       = TCursor(-2);  //normal cursor
  crCross       = TCursor(-3);  //graphics cursor, for pixel or rectangle selection
  crIBeam       = TCursor(-4);  //text cursor, for setting insertion point
Sizing cursors
  crSize        = TCursor(-22);
  crSizeAll     = TCursor(-22);
  crSizeNESW    = TCursor(-6); // diagonal north east - south west
  crSizeNS      = TCursor(-7);
  crSizeNWSE    = TCursor(-8);
  crSizeWE      = TCursor(-9);
  crSizeNW      = TCursor(-23);
  crSizeN       = TCursor(-24);
  crSizeNE      = TCursor(-25);
  crSizeW       = TCursor(-26);
  crSizeE       = TCursor(-27);
  crSizeSW      = TCursor(-28);
  crSizeS       = TCursor(-29);
  crSizeSE      = TCursor(-30);
DragDrop cursors
  crDrag        = TCursor(-12); //dragging, drop allowed
  crNoDrop      = TCursor(-13); //dragging, drop disallowed/rejected
  crMultiDrag   = TCursor(-16); //dragging multiple items
  crNo          = TCursor(-18);
Splitter cursors
  crHSplit      = TCursor(-14);
  crVSplit      = TCursor(-15);
More cursors
  crUpArrow     = TCursor(-10);
  crHourGlass   = TCursor(-11); //busy
  crSQLWait     = TCursor(-17);
  crAppStart    = TCursor(-19);
  crHelp        = TCursor(-20);
  crHandPoint   = TCursor(-21);
</pre>
        </descr>
      </element>
      <element name="crHigh">
        <short>Highest defined cursor constant (0).</short>
      </element>
      <element name="crDefault">
        <short>Indicates that the default cursor from the system should be utilized</short>
      </element>
      <element name="crNone">
        <short>Indicates that the cursor should be invisible</short>
      </element>
      <element name="crArrow">
        <short>The Arrow cursor, which is the most common and the default one in most cases</short>
      </element>
      <element name="crCross">
        <short>A cursor utilized for graphics, for pixel or rectangle selection, often in the shape of a cross</short>
      </element>
      <element name="crIBeam">
        <short>A text cursor, for setting insertion point. Often used in text editors</short>
      </element>
      <element name="crSize">
        <short>A generic sizing cursor, to indicate that here one may drag to resize something. Is the same as crSizeAll.</short>
      </element>
      <element name="crSizeNESW">
        <short>A cursor for resizing which runs diagonally from NorthEast to SouthWest (-6)</short>
      </element>
      <element name="crSizeNS">
        <short>A cursor for resizing which cursor runs from North to South (-7)</short>
      </element>
      <element name="crSizeNWSE">
        <short>A cursor for resizing which cursor runs from NorthWest to SouthEast</short>
      </element>
      <element name="crSizeWE">
        <short>A cursor for resizing which has an arrow with two points, one to the left and another to the right, to indicate resizing possibility in both directions.</short>
      </element>
      <element name="crSizeNW">
        <short>A cursor for resizing which has an arrow pointing to the left-top corner, to indicate resizing possibility in this direction</short>
      </element>
      <element name="crSizeN">
        <short>A cursor for resizing which has an arrow pointing upwards, to indicate resizing possibility in this direction</short>
      </element>
      <element name="crSizeNE">
        <short>A cursor for resizing which has an arrow pointing to the right-top corner, to indicate resizing possibility in this direction</short>
      </element>
      <element name="crSizeW">
        <short>A cursor for resizing which has an arrow pointing to the left, to indicate resizing possibility in this direction</short>
      </element>
      <element name="crSizeE">
        <short>A cursor for resizing which has an arrow pointing to the right, to indicate resizing possibility in this direction</short>
      </element>
      <element name="crSizeSW">
        <short>A cursor for resizing which has an arrow pointing to the left-bottom corner, to indicate resizing possibility in this direction</short>
      </element>
      <element name="crSizeS">
        <short>A cursor for resizing which has an arrow pointing downwards, to indicate resizing possibility in this direction</short>
      </element>
      <element name="crSizeSE">
        <short>A cursor for resizing which has an arrow pointing to the right-bottom corner, to indicate resizing possibility in this direction</short>
      </element>
      <element name="crUpArrow">
        <short>Up Arrow cursor constant (-10)</short>
      </element>
      <element name="crHourGlass">
        <short>Busy cursor constant, utilized to indicate that one should wait while an action is done</short>
      </element>
      <element name="crDrag">
        <short>A cursor to indicate that one can drop a dragged item in this area</short>
      </element>
      <element name="crNoDrop">
        <short>A cursor to indicate that one cannot drop a dragged item in this area</short>
      </element>
      <element name="crHSplit">
        <short>Horizontal Splitter cursor constant (-14)</short>
      </element>
      <element name="crVSplit">
        <short>Vertical Split cursor constant (-15)</short>
      </element>
      <element name="crMultiDrag">
        <short>Multiple Object dragging cursor constant (-16)</short>
      </element>
      <element name="crSQLWait">
        <short>Waiting for SQL cursor constant (-17)</short>
      </element>
      <element name="crNo">
        <short>Shows a negative sign. See also <link id="crNoDrop"/>.
        </short>
      </element>
      <element name="crAppStart">
        <short>Application starting cursor.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="crHelp">
        <short>"What's This" Help cursor constant (-20)</short>
      </element>
      <element name="crHandPoint">
        <short>Pointing hand cursor constant (-21)</short>
      </element>
      <element name="crSizeAll">
        <short>All Directions sizing cursor constant (-22)</short>
      </element>
      <element name="crLow">
        <short>Lowest defined cursor constant (-30).</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TWndMethod">
        <short>Method type for WindowProc handlers.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWndMethod.TheMessage">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlStyleType">
        <short>TControlStyleType - enumerated type describing features of the Control</short>
      </element>
      <element name="TControlStyleType.csAcceptsControls">
        <short>Indicates that one can add child controls to this control in the form designer.</short>
      </element>
      <element name="TControlStyleType.csCaptureMouse">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlStyleType.csDesignInteractive">
        <short>wants mouse events in design mode</short>
      </element>
      <element name="TControlStyleType.csClickEvents">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlStyleType.csFramed">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlStyleType.csSetCaption">
        <short>As long as Name=Text, changing the Name will set the Caption.</short>
        <descr>When for example a button's Name and Caption have the value 'Button1' and the Name is changed to 'Button2' then the Caption is changed as well. When Name and Caption differs this flag has no effect. This flag has no effect during loading.</descr>
      </element>
      <element name="TControlStyleType.csOpaque">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlStyleType.csDoubleClicks">
        <short>Indicates that the control understands mouse double clicks</short>
      </element>
      <element name="TControlStyleType.csTripleClicks">
        <short>Indicates that the control understands mouse triple clicks</short>
      </element>
      <element name="TControlStyleType.csQuadClicks">
        <short>Indicates that the control understands mouse quadruple clicks</short>
      </element>
      <element name="TControlStyleType.csFixedWidth">
        <short>Indicates that the control cannot change its width</short>
      </element>
      <element name="TControlStyleType.csFixedHeight">
        <short>Indicates that the control cannot change its height (e.g. combobox)</short>
      </element>
      <element name="TControlStyleType.csNoDesignVisible">
        <short>Indicates that the control is invisible in the form designer</short>
      </element>
      <element name="TControlStyleType.csReplicatable">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlStyleType.csNoStdEvents">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlStyleType.csDisplayDragImage">
        <short>display images from dragimagelist during drag operation over control</short>
      </element>
      <element name="TControlStyleType.csReflector">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlStyleType.csActionClient">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlStyleType.csMenuEvents">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlStyleType.csNoFocus">
        <short>Indicates that the control cannot receive focus</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlStyleType.csNeedsBorderPaint">
        <short>[not implemented]</short>
      </element>
      <element name="TControlStyleType.csParentBackground">
        <short>[not implemented]</short>
      </element>
      <element name="TControlStyleType.csDesignNoSmoothResize">
        <short>no WYSIWYG resizing in designer</short>
      </element>
      <element name="TControlStyleType.csDesignFixedBounds">
        <short>control can not be moved nor resized in designer</short>
      </element>
      <element name="TControlStyleType.csHasDefaultAction">
        <short>control implements useful ExecuteDefaultAction</short>
      </element>
      <element name="TControlStyleType.csHasCancelAction">
        <short>control implements useful ExecuteCancelAction</short>
      </element>
      <element name="TControlStyleType.csNoDesignSelectable">
        <short>control can not be selected at design time</short>
      </element>
      <element name="TControlStyleType.csOwnedChildrenNotSelectable">
        <short>child controls owned by this control are NOT selectable in the designer</short>
      </element>
      <element name="TControlStyleType.csAutoSize0x0">
        <short>if the preferred size is 0x0 then control is shrinked to 0x0</short>
      </element>
      <element name="TControlStyleType.csAutoSizeKeepChildLeft">
        <short>when AutoSize=true do not move children horizontally</short>
      </element>
      <element name="TControlStyleType.csAutoSizeKeepChildTop">
        <short>when AutoSize=true do not move children vertically</short>
      </element>
      <element name="TControlStyleType.csRequiresKeyboardInput">
        <short>Indicates that a control requires keyboard input to be utilized by the user. This information is utilized in Android and other platforms so that the virtual keyboard is activated when the control receives focus and the device has no hardware keyboard</short>
      </element>
      <!-- set type Visibility: default -->
      <element link="TControlStyleType" name="TControlStyle">
        <short>Set of control styles.</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="csMultiClicks">
        <short>Set of styles which require/provide multiple clicks on a control.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlStateType">
        <short>State flags of a Control</short>
        <descr>
          <p>Enumerated type comprising</p>
          <pre>csLButtonDown,
    csClicked,
    csPalette,
    csReadingState,
    csAlignmentNeeded,
    csFocusing,
    csCreating,
    csPaintCopy,
    csCustomPaint,
    csDestroyingHandle,
    csDocking,
    csVisibleSetInLoading
</pre>
        </descr>
      </element>
      <element name="TControlStateType.csLButtonDown">
        <short/>
      </element>
      <element name="TControlStateType.csClicked">
        <short/>
      </element>
      <element name="TControlStateType.csPalette">
        <short/>
      </element>
      <element name="TControlStateType.csReadingState">
        <short/>
      </element>
      <element name="TControlStateType.csFocusing">
        <short/>
      </element>
      <element name="TControlStateType.csCreating">
        <short/>
      </element>
      <element name="TControlStateType.csPaintCopy">
        <short/>
      </element>
      <element name="TControlStateType.csCustomPaint">
        <short/>
      </element>
      <element name="TControlStateType.csDestroyingHandle">
        <short/>
      </element>
      <element name="TControlStateType.csDocking">
        <short/>
      </element>
      <element name="TControlStateType.csVisibleSetInLoading">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element link="TControlStateType" name="TControlState">
        <short>Set of permissible Control states</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlCanvas">
        <short>The base class for the canvas property of several graphic controls, such as TGraphicControl and TCustomControl</short>
        <descr>[provide usable links on the methods]</descr>
        <seealso>
          <link id="#lcl.Controls.TGraphicControl">TGraphicControl</link>
          <link id="#lcl.Controls.TCustomControl">TCustomControl</link>
          <link id="#lcl.Graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>
      <element name="TControlCanvas.FControl"/>
      <element name="TControlCanvas.FDeviceContext"/>
      <element name="TControlCanvas.FWindowHandle"/>
      <!-- procedure Visibility: private -->
      <element link="TControlCanvas.Control" name="TControlCanvas.SetControl"/>
      <element name="TControlCanvas.SetControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlCanvas.CreateFont"/>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TCanvas.CreateHandle" name="TControlCanvas.CreateHandle"/>
      <!-- function Visibility: protected -->
      <element name="TControlCanvas.GetDefaultColor"/>
      <element name="TControlCanvas.GetDefaultColor.Result">
        <short/>
      </element>
      <element name="TControlCanvas.GetDefaultColor.ADefaultColorType">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControlCanvas.Create"/>
      <!-- destructor Visibility: public -->
      <element name="TControlCanvas.Destroy"/>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Graphics.TCanvas.FreeHandle" name="TControlCanvas.FreeHandle"/>
      <!-- function Visibility: public -->
      <element name="TControlCanvas.ControlIsPainting">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlCanvas.ControlIsPainting.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlCanvas.Control">
        <short>The Control object for which this is the Canvas.</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragImageList">
        <short>A list of Images used in dragging.</short>
        <descr>
          <p>A drag image is shown when a DragImageList is supplied at all, 
            <b>and</b> when no accepting target is under the mouse, or the source control style includes csDisplayDragImage, or AlwaysShowDragImage is set in the DragObject.</p>
          <p>In drag-dock operations typically no drag image is shown, since the DockRect frame already gives all required visual feedback.</p>
          <pre>This is a vague idea of the usage of this class:

SetDragImage selects an image from the list, and defines the hotspot within this image.
  (the hotspot typically is the offset of the mouse position to the origin of the dragged control)

BeginDrag starts dragging, the image is shown at the starting location.

DragMove moves the image.

EndDrag stops dragging, the image is removed from the screen.
</pre>
        </descr>
      </element>
      <element link="TDragImageList.DragCursor" name="TDragImageList.FDragCursor"/>
      <element link="TDragImageList.Dragging" name="TDragImageList.FDragging"/>
      <element link="TDragImageList.DragHotspot" name="TDragImageList.FDragHotspot"/>
      <element name="TDragImageList.FImageIndex"/>
      <element name="TDragImageList.FLastDragPos">
        <short>Remember position where the image was painted.</short>
      </element>
      <element name="TDragImageList.FLockedWindow">
        <short>The window whose updates are locked while dragging.
        </short>
      </element>
      <element name="TDragImageList.FOldCursor"/>
      <!-- procedure Visibility: private -->
      <element link="TDragImageList.DragCursor" name="TDragImageList.SetDragCursor"/>
      <element name="TDragImageList.SetDragCursor.AValue">
        <short/>
      </element>
      <!-- class procedure Visibility: default -->
      <element name="TDragImageList.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.ImgList.TCustomImageList.Initialize" name="TDragImageList.Initialize"/>
      <!-- function Visibility: public -->
      <element name="TDragImageList.BeginDrag">
        <short>Start dragging an image; returns True if successful.</short>
        <descr>Locks window updates, remembers the current cursor shape and sets the new shape.
        </descr>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TDragImageList.BeginDrag.Result">
        <short>True if successful.</short>
      </element>
      <element name="TDragImageList.BeginDrag.Window">
        <short>The associated window.</short>
      </element>
      <element name="TDragImageList.BeginDrag.X">
        <short>The mouse position.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TDragImageList.BeginDrag.Y">
        <short>The mouse position.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.DragLock">
        <short>Show drag image during drag operation.</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>and lock updates of Window?</note>
        </notes>
      </element>
      <element name="TDragImageList.DragLock.Result">
        <short>True if Dragging and image shown.</short>
      </element>
      <element name="TDragImageList.DragLock.Window">
        <short>The locked window.</short>
      </element>
      <element name="TDragImageList.DragLock.XPos">
        <short>The mouse position.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TDragImageList.DragLock.YPos">
        <short>The mouse position.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.DragMove">
        <short>Show the image at a new location.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragImageList.DragMove.Result">
        <short>True if Dragging and image moved.</short>
      </element>
      <element name="TDragImageList.DragMove.X">
        <short>The new mouse position.</short>
      </element>
      <element name="TDragImageList.DragMove.Y">
        <short>The new mouse position.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragImageList.DragUnlock">
        <short>Hide the drag image.</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>and unlock window updates?</note>
        </notes>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.EndDrag">
        <short>Finish dragging of the image, restore the old cursor shape.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragImageList.EndDrag.Result">
        <short>True when dragging was started before.</short>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.ImgList.TCustomImageList.GetHotSpot" name="TDragImageList.GetHotSpot"/>
      <element name="TDragImageList.GetHotSpot.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragImageList.HideDragImage">
        <short>Hide the dragged image without unlocking the window.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.SetDragImage">
        <short>Set index of dragged image and hotspot.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragImageList.SetDragImage.Result">
        <short>Always True</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TDragImageList.SetDragImage.Index">
        <short>List index of the image to use.</short>
      </element>
      <element name="TDragImageList.SetDragImage.HotSpotX">
        <short>Offset from mouse position to image position.</short>
      </element>
      <element name="TDragImageList.SetDragImage.HotSpotY">
        <short>Offset from mouse position to image position.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragImageList.ShowDragImage">
        <short>Display the drag image.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragImageList.DragCursor">
        <short>The cursor shape to use while dragging.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragImageList.DragHotspot">
        <short>The position of the image HotSpot, i.e. the offset to the mouse position while dragging.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragImageList.Dragging">
        <short>True if dragging in progress.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TKeyEvent">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TKeyEvent.Sender">
        <short/>
      </element>
      <element name="TKeyEvent.Key">
        <short/>
      </element>
      <element name="TKeyEvent.Shift">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TKeyPressEvent">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TKeyPressEvent.Sender">
        <short/>
      </element>
      <element name="TKeyPressEvent.Key">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TUTF8KeyPressEvent"/>
      <element name="TUTF8KeyPressEvent.Sender">
        <short/>
      </element>
      <element name="TUTF8KeyPressEvent.UTF8Key">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseEvent">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TMouseEvent.Sender">
        <short/>
      </element>
      <element name="TMouseEvent.Button">
        <short/>
      </element>
      <element name="TMouseEvent.Shift">
        <short/>
      </element>
      <element name="TMouseEvent.X">
        <short/>
      </element>
      <element name="TMouseEvent.Y">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseMoveEvent">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TMouseMoveEvent.Sender">
        <short/>
      </element>
      <element name="TMouseMoveEvent.Shift">
        <short/>
      </element>
      <element name="TMouseMoveEvent.X">
        <short/>
      </element>
      <element name="TMouseMoveEvent.Y">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseWheelEvent">
        <short>Type of an OnMouseWheel event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseWheelEvent.Sender">
        <short>The control under the mouse.</short>
      </element>
      <element name="TMouseWheelEvent.Shift">
        <short>State of the modifier keys and mouse buttons.</short>
      </element>
      <element name="TMouseWheelEvent.WheelDelta">
        <short>How many notches the wheel has been turned.</short>
      </element>
      <element name="TMouseWheelEvent.MousePos">
        <short>The mouse position, in client coordinates.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TMouseWheelEvent.Handled">
        <short>Set Handled to True when the event was handled.</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseWheelUpDownEvent">
        <short>Type of OnMouseWheelUp/Down event handlers.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseWheelUpDownEvent.Sender">
        <short>The control under the mouse.</short>
      </element>
      <element name="TMouseWheelUpDownEvent.Shift">
        <short>State of the modifier keys and mouse buttons.</short>
      </element>
      <element name="TMouseWheelUpDownEvent.MousePos">
        <short>The mouse position, in client coordinates.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TMouseWheelUpDownEvent.Handled">
        <short>Set Handled to True when the event was handled.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragState">
        <short>State changes while dragging - when mouse enters, leaves or moves over a control.</short>
        <descr>These values are sent with drag messages, allowing the control to perform special actions while the mouse moves over it.
        </descr>
        <seealso/>
      </element>
      <element name="TDragState.dsDragEnter">
        <short>Mouse has just entered the control.</short>
      </element>
      <element name="TDragState.dsDragLeave">
        <short>Mouse has just left the control.</short>
      </element>
      <element name="TDragState.dsDragMove">
        <short>Mouse is moving over the control.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragMode">
        <short>Indicates whether dragging can start automatically.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragMode.dmManual">
        <short>Dragging can start only by explicit code.</short>
      </element>
      <element name="TDragMode.dmAutomatic">
        <short>Dragging starts when the left mouse button is pressed on the control.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragKind">
        <short>Indicates whether the control performs drag-drop or drag-dock.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragKind.dkDrag">
        <short>Control is dragged for dropping.</short>
      </element>
      <element name="TDragKind.dkDock">
        <short>Control is dragged for docking.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragOperation">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragOperation.dopNone">
        <short>Dragging not started.</short>
      </element>
      <element name="TDragOperation.dopDrag">
        <short>Drag-drop started.</short>
      </element>
      <element name="TDragOperation.dopDock">
        <short>Drag-dock started.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragMessage">
        <short>DragManager message types.</short>
        <descr>
          <p>All messages are sent to the target control, except dmDragDrop and dmDragCancel is sent to the source control.</p>
          <pre>dmDragEnter: mouse enters control
dmDragLeave: mouse leaves control
dmDragMove: mouse moves over control (after dmDragEnter)
dmDragDrop: control dropped
dmDragCancel: dragging aborted
dmFindTarget: find child control under the mouse
</pre>
        </descr>
      </element>
      <element name="TDragMessage.dmDragEnter">
        <short>mouse enters control</short>
      </element>
      <element name="TDragMessage.dmDragLeave">
        <short>mouse leaves control</short>
      </element>
      <element name="TDragMessage.dmDragMove">
        <short>mouse moves over control (after dmDragEnter)</short>
      </element>
      <element name="TDragMessage.dmDragDrop">
        <short>control dropped</short>
      </element>
      <element name="TDragMessage.dmDragCancel">
        <short>dragging aborted</short>
      </element>
      <element name="TDragMessage.dmFindTarget">
        <short>find possible target control under the mouse</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDragOverEvent">
        <short>The type of an OnDragOver handler.</short>
        <descr>
          <p>An OnDragOver event is sent by a control, when an object is dragged over it.
            The handler can specify whether a drop will be accepted or rejected.</p>
          <remark>
            <var>Source</var> is polymorphic, can be either the DragObject or the dragged control!
            This depends on DragObject.AutoCreated, for no sane reason :-(
          </remark>
        </descr>
        <seealso>
          <link id="TDockOverEvent"/>
        </seealso>
      </element>
      <element name="TDragOverEvent.Sender">
        <short>The possible drop target (control).</short>
      </element>
      <element name="TDragOverEvent.Source">
        <short>The object (TDragObject or TControl) being dragged.</short>
      </element>
      <element name="TDragOverEvent.X">
        <short>X coordinate of the mouse on screen.</short>
      </element>
      <element name="TDragOverEvent.Y">
        <short>Y coordinate of the mouse on screen.</short>
      </element>
      <element name="TDragOverEvent.State">
        <short>The current DragState (entering, leaving or moving over the target).</short>
      </element>
      <element name="TDragOverEvent.Accept">
        <short>Set Accept to False to reject an drop (default is True).</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDragDropEvent">
        <short>The type of an OnDragDrop notification handler.</short>
        <descr>An OnDragDrop event is generated by the target control, on the drop of a dragged object.
        </descr>
        <seealso>
          <link id="TDockDropEvent"/>
          <link id="TEndDragEvent"/>
          <link id="TControl.OnDragDrop"/>
        </seealso>
      </element>
      <element name="TDragDropEvent.Sender">
        <short>The target control of the drop.</short>
      </element>
      <element link="TDragOverEvent.Source" name="TDragDropEvent.Source">
        <short>The dragged control.</short>
      </element>
      <element name="TDragDropEvent.X">
        <short>The <b>client</b> coordinates of the drop.</short>
      </element>
      <element name="TDragDropEvent.Y">
        <short>The <b>client</b> coordinates of the drop.</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TStartDragEvent">
        <short>The type of an OnStartDrag handler.</short>
        <descr>An OnStartDrag event is generated by a control when it shall be dragged and its DragKind is dkDrag.
          The handler can provide a specific DragDrop object, else a standard TDragDropObjectEx is automatically created by the DragManager.
        </descr>
        <seealso>
          <link id="TStartDragEvent"/>
        </seealso>
      </element>
      <element name="TStartDragEvent.Sender">
        <short>The control to be dragged.</short>
      </element>
      <element name="TStartDragEvent.DragObject">
        <short>Supply your own DragObject, or leave it Nil for automatic creation.</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TEndDragEvent">
        <short>The type of an OnEndDrag handler.</short>
        <descr>
          <p>An OnEndDrag event is sent by a dragged control, when dragging is finished.
            This happens regardless of whether the operation was drag-drop or drag-dock,
            and whether the operation ended with a drop or was cancel'd.
          </p>
          <p>Check Target=Nil to distinguish between a drop and a cancel'd operation (Nil).</p>
        </descr>
        <seealso>
          <link id="TDragDropEvent"/>
          <link id="TDockDropEvent"/>
        </seealso>
      </element>
      <element name="TEndDragEvent.Sender">
        <short>The dragged control</short>
      <notes><note>or DragObject?</note>
        </notes>
      </element>
      <element name="TEndDragEvent.Target">
        <short>The drop target (control), or Nil if cancel'd.</short>
      </element>
      <element link="TDragOverEvent.X" name="TEndDragEvent.X">
        <short>The mouse coordinate, in client coordinates if dropped, else in screen coordinates.</short>
      </element>
      <element link="TDragOverEvent.Y" name="TEndDragEvent.Y">
        <short>The mouse coordinate, in client coordinates if dropped, else in screen coordinates.</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragObject">
        <short>Base class for managing drag operations and user feedback.</short>
        <descr>
          <p>Every dragging operation has an associated DragObject, holding references to the source and target controls, and other parameters for the customization of the visual user feedback.</p>
          <p>A default DragObject is created automatically when a dragging operation starts, and is destroyed when the operation has ended, so that you must not take special care on it.
            But an application can provide a customized DragObject in the <link id="TControl.OnStartDrag"/> or <link id="TControl.OnStartDock"/> handlers of the source control (being dragged).</p>
          <remark>AutoCreated DragObjects imply different behaviour in the DragOver and DragDrop events, where the Source becomes the dragged control, while else the DragObject itself is passed as Source.
          </remark>
          <p>TDragObject is the ancestor of an whole tree of dragging objects, with the main branches supporting either drag-drop or drag-dock operations.
            The type of the operation is determined from the <link id="TControl.DragKind"/> property of the source control.</p>
          <remark>In contrast to the Delphi implementation, Lazarus has moved a couple of methods into the drag performers, so that these are no more available for customization.</remark>
          <p>A Lazarus DragObject mainly supplies the cursor and images, used in visual user feedback.
            Drag-drop operations typically signal acceptance of an possible drop by variations of the mouse cursor, and optionally can attach to it shapes of the dragged object(s).
            Drag-dock operations instead show a docking rectangle, that snaps to possible target locations when the mouse moves over docksites.</p>
          <p>[entire review DoDi 2011-09-10]</p>
        </descr>
        <seealso>
          <link id="TDragControlObject"/>
          <link id="TDragDockObject"/>
        </seealso>
      </element>
      <element link="TDragObject.DragPos" name="TDragObject.FDragPos"/>
      <element link="TDragObject.DragTarget" name="TDragObject.FDragTarget"/>
      <element link="TDragObject.DragTargetPos" name="TDragObject.FDragTargetPos"/>
      <element link="TDragObject.AutoFree" name="TDragObject.FAutoFree"/>
      <element link="TDragObject.AutoCreated" name="TDragObject.FAutoCreated"/>
      <element link="TDragObject.Dropped" name="TDragObject.FDropped"/>
      <element link="TDragObject.AlwaysShowDragImage" name="TDragObject.FAlwaysShowDragImages"/>
      <element link="TDragObject.Control" name="TDragObject.FControl"/>
      <element name="TDragObject.MouseDeltaX">
        <short>[Delphi compatible - dropped!]</short>
      </element>
      <element name="TDragObject.MouseDeltaY">
        <short>[Delphi compatible - dropped!]</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TDragObject.Capture">
        <short>[Delphi compatible - dropped!]</short>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.Capture.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.Finished">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.Finished.Target">
        <short/>
      </element>
      <element name="TDragObject.Finished.X">
        <short/>
      </element>
      <element name="TDragObject.Finished.Y">
        <short/>
      </element>
      <element name="TDragObject.Finished.Accepted">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragObject.GetDragCursor">
        <short>Returns the dragging cursor type (shape).</short>
        <descr>In drag-drop operations the cursor signals acceptance or rejection of an drop, depending on Accepted.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragObject.GetDragCursor.Result">
        <short>The cursor to show.</short>
      </element>
      <element name="TDragObject.GetDragCursor.Accepted">
        <short>Which cursor to return (rejected:crNoDrop or accepted:crDrag).</short>
      </element>
      <element name="TDragObject.GetDragCursor.X">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TDragObject.GetDragCursor.Y">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragObject.GetDragImages">
        <short>Returns a list of images for dragging.</short>
        <descr>The returned <link id="TDragImageList"/> provides methods for the selection and display of an image, shown while dragging.
          This implementation returns Nil, must be overridden (e.g. in TDragControlObject).
        </descr>
        <errors/>
        <seealso>
          <link id="TDragControlObject"/>
        </seealso>
      </element>
      <element name="TDragObject.GetDragImages.Result">
        <short>The ImageList to use, is Nil by default!</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.MouseMove">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.MouseMove.Shift">
        <short/>
      </element>
      <element name="TDragObject.MouseMove.X">
        <short/>
      </element>
      <element name="TDragObject.MouseMove.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.MouseDown">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.MouseDown.Button">
        <short/>
      </element>
      <element name="TDragObject.MouseDown.Shift">
        <short/>
      </element>
      <element name="TDragObject.MouseDown.X">
        <short/>
      </element>
      <element name="TDragObject.MouseDown.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.MouseUp">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.MouseUp.Button">
        <short/>
      </element>
      <element name="TDragObject.MouseUp.Shift">
        <short/>
      </element>
      <element name="TDragObject.MouseUp.X">
        <short/>
      </element>
      <element name="TDragObject.MouseUp.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.CaptureChanged">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.CaptureChanged.OldCaptureControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.KeyDown">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.KeyDown.Key">
        <short/>
      </element>
      <element name="TDragObject.KeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.KeyUp">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.KeyUp.Key">
        <short/>
      </element>
      <element name="TDragObject.KeyUp.Shift">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDragObject.Create">
        <short>Remembers the dragged control.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <element name="TDragObject.Create.AControl">
        <short>The control being dragged.</short>
      </element>
      <element name="TDragObject.AutoCreate">
        <short>Special constructor, enforcing the destruction of the object at the end of the dragging operation.</short>
        <descr>This constructor sets the AutoCreated and AutoFree flags. AutoFree is tested by the DragManager at the end of the dragging operation.</descr>
      </element>
      <element name="TDragObject.AutoCreate.AControl">
        <short>The control being dragged.</short>
      </element>
      <element name="TDragObject.AutoFree">
        <short>Indicates whether the object shall be destroyed at the end of the dragging operation.</short>
        <descr>This is a Lazarus specific property, introduced to get rid of the special Delphi TDrag...Ex classes.</descr>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TDragObject.Destroy"/>
      <!-- property Visibility: public -->
      <element name="TDragObject.AlwaysShowDragImages">
        <short>Should the image of dragged objects always be shown?</short>
        <descr>This is another chance for enforcing the display of a drag image, even if a drop is acceptable.</descr>
        <seealso/>
      <notes><note>where to describe the various conditions?</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.Control">
        <short>The control that is dragged (source).</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragObject.Assign">
        <short>[Delphi compatible - dropped!] Copy information from another drag object.</short>
        <descr>Use <var>Assign</var> to initialize the drag object with your own default values.</descr>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.Assign.Source"/>
      <!-- function Visibility: public -->
      <element name="TDragObject.GetName">
        <short>[Delphi compatible - dropped!] Returns the Name of the drag object.</short>
        <descr>This implementation returns the ClassName of the object.
          Override as appropriate for your drag management, this method is not called by LCL code.
        </descr>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.GetName.Result">
        <short>The object's name.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragObject.Instance">
        <short>[Delphi compatible - dropped!]</short>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.Instance.Result">
        <short>Zero by default.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragObject.HideDragImage">
        <short>Asks the image list to hide the drag image.</short>
        <seealso>
          <link id="#lcl.Controls.TDragObject.ShowDragImage">ShowDragImage</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragObject.ShowDragImage">
        <short>Asks the image list to show the drag image.</short>
        <descr/>
        <seealso>
          <link id="#lcl.Controls.TDragObject.HideDragImage">HideDragImage</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.Cancelling">
        <short>[Delphi compatible - dropped!] Is this drag being cancelled?</short>
        <descr>Set while this drag is cancelled. Used to prevent endless loops in further processing.</descr>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragHandle">
        <short>[Delphi compatible - dropped!] The Handle of the dragged object.</short>
        <descr/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragPos">
        <short>Current mouse position in screen coordinates.</short>
        <seealso>
          <link id="TDragObject.DragTargetPos"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragTargetPos">
        <short>Mouse position in client coordinates of the DragTarget.</short>
        <seealso>
          <link id="TDragObject.DragPos"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragTarget">
        <short>The control over which the object currently is dragged (target).</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.Dropped">
        <short>Indicates whether the drag object has been dropped yet.</short>
        <descr>False while dragging is in progress, or when dragging has been aborted.</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.MouseDeltaX">
        <short>[Delphi compatible - dropped!] The x offset of the DragImage or DockRect hotspot.</short>
        <descr/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.MouseDeltaY">
        <short>[Delphi compatible - dropped!] The y offset of the DragImage or DockRect hotspot.</short>
        <descr/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragObject.AutoCreated">
        <short>Was the drag object created automatically?</short>
        <descr>This property is of little use, more important is the AutoFree property.</descr>
      </element>
      <element name="TDragObject.EndDrag">
        <short>Called when a dragging operation ends.</short>
        <descr>The default implementation calls Control.DoEndDrag, which in turn invokes an OnEndDrag handler.</descr>
      </element>
      <element name="TDragObject.EndDrag.Target">
        <short>The control onto which the dragged object is dropped (can be Nil).</short>
      </element>
      <element name="TDragObject.EndDrag.X">
        <short/>
      </element>
      <element name="TDragObject.EndDrag.Y">
        <short/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TDragObjectClass">
        <short>A <link id="TDragObject"/> class type.</short>
      </element>
      <element link="#LCL.Controls.TDragObject" name="TDragObjectEx">
        <short>A drag object that is automatically destroyed after use.</short>
      </element>
      <element name="TDragObjectEx.Create">
        <short>Creates a drag object that is automatically destroyed after use.</short>
      </element>
      <element name="TDragObjectEx.Create.AControl">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragControlObject">
        <short>A drag object for dragging a control.</short>
        <descr>While a TDragObject can be used for dragging controls, this class <b>knows</b> that it drags a control, and asks it for an DragCursor and DragImages.
        </descr>
        <errors/>
        <seealso>
          <link id="TDragObject"/>
        </seealso>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragControlObject.GetDragCursor">
        <short>Asks the Control to provide an cursor.</short>
      </element>
      <element name="TDragControlObject.GetDragCursor.Result">
        <short/>
      </element>
      <element name="TDragControlObject.GetDragCursor.Accepted">
        <short/>
      </element>
      <element name="TDragControlObject.GetDragCursor.X">
        <short/>
      </element>
      <element name="TDragControlObject.GetDragCursor.Y">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragControlObject.GetDragImages">
        <short>Asks the Control to provide an ImageList.</short>
      </element>
      <element name="TDragControlObject.GetDragImages.Result">
        <short>The Image list to be used in dragging this control.</short>
      </element>
      <element link="#LCL.Controls.TDragControlObject" name="TDragControlObjectEx"/>
      <element name="TDragControlObjectEx.Create">
        <short>Creates an object to be destroyed after use.</short>
      </element>
      <element name="TDragControlObjectEx.Create.AControl">
        <short>The control to drag.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDockOrientation">
        <short>Orientation of DockZones and docked controls, similar to <link id="TAlign"/>.</short>
        <descr>
          <p>This is a Delphi relict, bound to TDockTree and not very useful in application code.<br/>
          All DockZones in an DockTree have a unique orientation, horizontal or vertical, indicating how controls are arranged in this zone.
          When a control is docked into a zone, it obtains the orientation of that zone.
          </p>
          <remark>The control's orientation can be stored as the opposite of the zone, depending on the used DockManager.
          </remark>
        </descr>
        <seealso/>
      </element>
      <element name="TDockOrientation.doNoOrient">
        <short>no orientation applies (like alNone)</short>
      </element>
      <element name="TDockOrientation.doHorizontal">
        <short>siblings are arranged horizontally, children top-to-bottom</short>
      </element>
      <element name="TDockOrientation.doVertical">
        <short>siblings are arranged vertically, children left-to-right</short>
      </element>
      <element name="TDockOrientation.doPages">
        <short>children are pages in a tabbed control</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDockDropEvent">
        <short>The type of an OnDockDrop handler.</short>
        <descr>An OnDockDrop event is sent by the drop target (dock site) on the drop of a dragged object.
        </descr>
        <seealso>
          <link id="TDragDropEvent"/>
        </seealso>
      </element>
      <element name="TDockDropEvent.Sender">
        <short>The drop target (docksite control).</short>
      </element>
      <element name="TDockDropEvent.Source">
        <short>The DragDock object, containing information about the dragged object.</short>
      </element>
      <element link="TDragOverEvent.X" name="TDockDropEvent.X">
        <short/>
      </element>
      <element link="TDragOverEvent.Y" name="TDockDropEvent.Y">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDockOverEvent">
        <short>The type of an OnDockOver handler.</short>
        <descr>An OnDockOver event is sent by a dock site, when an object is dragged over it.
          The handler can specify whether a drop will be accepted or rejected.
        </descr>
        <seealso>
          <link id="TDragOverEvent"/>
        </seealso>
      </element>
      <element name="TDockOverEvent.Sender">
        <short>The possible drop target.</short>
      </element>
      <element link="TDockDropEvent.Source" name="TDockOverEvent.Source">
        <short/>
      </element>
      <element link="TDragOverEvent.X" name="TDockOverEvent.X">
        <short/>
      </element>
      <element link="TDragOverEvent.Y" name="TDockOverEvent.Y">
        <short/>
      </element>
      <element link="TDragOverEvent.State" name="TDockOverEvent.State">
        <short/>
      </element>
      <element link="TDragOverEvent.Accept" name="TDockOverEvent.Accept">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TUnDockEvent">
        <short>The type of an OnUnDock handler.</short>
        <descr>An UnDock event is sent by a dock site, before a control is undocked from it.
          The handler can reject undocking, by setting Allow to False.
        </descr>
        <seealso/>
      </element>
      <element name="TUnDockEvent.Sender">
        <short>The docksite from which the object is undocked.</short>
      </element>
      <element name="TUnDockEvent.Client">
        <short>The control to be undocked.</short>
      </element>
      <element name="TUnDockEvent.NewTarget">
        <short>The new docksite for Client, Nil when undocked into floating state.</short>
      </element>
      <element name="TUnDockEvent.Allow">
        <short>Set Allow to False to reject undocking.</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TStartDockEvent">
        <short>The type of an OnStartDock handler.</short>
        <descr>An OnStartDock event is sent by a control when it shall be dragged and its DragKind is dkDock.
          The handler can provide a specific DragDock object, else a standard TDragDockObjectEx is automatically created by the DragManager.
        </descr>
        <seealso>
          <link id="TStartDragEvent"/>
        </seealso>
      </element>
      <element name="TStartDockEvent.Sender">
        <short>The control being dragged.</short>
      </element>
      <element name="TStartDockEvent.DragObject">
        <short>Supply your own TDragDockObject, or leave it Nil to request automatic creation.</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetSiteInfoEvent">
        <short>An OnGetSiteInfo handler returns information about a docksite.</short>
        <descr>An OnGetSiteInfo event is sent by the DragManager to all docksites.
          The handler can adjust the snapping rectangle (InfluenceRect), and can reject an drop.
        </descr>
        <seealso/>
      </element>
      <element name="TGetSiteInfoEvent.Sender">
        <short>The dock site near the mouse pointer.</short>
      </element>
      <element name="TGetSiteInfoEvent.DockClient">
        <short>The dragged control.</short>
      </element>
      <element name="TGetSiteInfoEvent.InfluenceRect">
        <short>The screen rectangle within which a drop or mouse move will be directed to this docksite.</short>
      </element>
      <element name="TGetSiteInfoEvent.MousePos">
        <short>The current position of the mouse.</short>
      <notes><note>screen?</note>
        </notes>
      </element>
      <element name="TGetSiteInfoEvent.CanDock">
        <short>Set CanDock to False to reject docking.</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragDockObject">
        <short>A drag object for drag-dock.</short>
        <descr>
          <p>This object type serves two main purposes: it allows to distinguish between drag-drop and drag-dock operations, and it implements docking specific information and behaviour.</p>
          <p>The primary use is for tree docking, as assumed in the TControl and TWinControl methods.</p>
          <p>[entire review DoDi 2011-09-10]</p>
        </descr>
        <errors/>
        <seealso>
          <link id="TDragObject"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element link="TDragDockObject.DockOffset" name="TDragDockObject.FDockOffset"/>
      <element link="TDragDockObject.DockRect" name="TDragDockObject.FDockRect"/>
      <element link="TDragDockObject.DropAlign" name="TDragDockObject.FDropAlign"/>
      <element link="TDragDockObject.DropOnControl" name="TDragDockObject.FDropOnControl"/>
      <element link="TDragDockObject.EraseDockRect" name="TDragDockObject.FEraseDockRect"/>
      <element link="TDragDockObject.Floating" name="TDragDockObject.FFloating"/>
      <element link="TDragDockObject.IncreaseDockArea" name="TDragDockObject.FIncreaseDockArea"/>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FBrush">
        <short>[dropped!]</short>
        <descr/>
        <seealso/>
      <notes><note>dropped!</note>
        </notes>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TDragDockObject.Brush" name="TDragDockObject.SetBrush"/>
      <element name="TDragDockObject.SetBrush.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragDockObject.AdjustDockRect">
        <short>Adjust the DockRect relative to the dragging hotspot (DockOffset).</short>
        <descr>
          <remark>The parameter type is bad, should be <b>var</b>. Ignore it please.
          </remark>
          <p>The default implementation adjusts the stored FDockRect, by DockOffset.
            This adjustment will make the DockRect appear right over the control, when dragging starts, regardless of where the user clicked onto the control.
          </p>
          <p>You'll rarely have to override this method, since the DockRect is adjusted by every target site's DockManager later.
          </p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragDockObject.AdjustDockRect.ARect">
        <short>useless, ignore!</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragDockObject.DrawDragDockImage">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragDockObject.EndDrag">
        <short>Finish docking.</short>
        <descr>Invokes Control.DoEndDock.</descr>
        <errors/>
        <seealso>
          <link id="TControl.DoEndDock"/>
        </seealso>
      </element>
      <element name="TDragDockObject.EndDrag.Target">
        <short>The target docksite, or Nil to make the Control float.</short>
      </element>
      <element name="TDragDockObject.EndDrag.X">
        <short/>
      </element>
      <element name="TDragDockObject.EndDrag.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragDockObject.EraseDragDockImage">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TDragObject.GetDragCursor" name="TDragDockObject.GetDragCursor"/>
      <element name="TDragDockObject.GetDragCursor.Result">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.Accepted">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.X">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.Y">
        <short/>
      </element>
      <element name="TDragDockObject.MoveDockImage">
        <short>Moves an already visible DockRect.</short>
        <descr>
          <p>Checks the DockRect for changes against EraseDockRect, to prevent flicker.</p>
          <p>Remembers the drawn frame coordinates in EraseDockRect.</p>
        </descr>
      </element>
      <element name="TDragDockObject.InitDock">
        <short>Initializes the dragging coordinates.</short>
        <descr>
          <p>Determines the hotspot offset for adjusting the floating DockRect.</p>
          <p>Since the undocked extent of the control doesn't change while dragging, we fix the hotspot offset here.</p>
          <p>Usage: OffsetRect(DockRect, FDockOffset);</p>
        </descr>
      </element>
      <element name="TDragDockObject.InitDock.APosition">
        <short/>
      </element>
      <element name="TDragDockObject.ShowDockImage">
        <short>Shows the DockRect, remembers the coordinates in EraseDockRect</short>
      </element>
      <element name="TDragDockObject.HideDockImage">
        <short>Hides the DockRect, invalidates EraseDockRect to prevent further erases.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragDockObject.GetFrameWidth">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragDockObject.GetFrameWidth.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDragDockObject.Create"/>
      <element name="TDragDockObject.Create.AControl">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TDragDockObject.Destroy"/>
      <!-- procedure Visibility: public -->
      <element name="TDragDockObject.Assign">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <element name="TDragDockObject.Assign.Source">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.Brush">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.DockOffset">
        <short>The hotspot offset of the dragged DockRect.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.DockRect">
        <short>Screen coordinates of a possible drop location.</short>
        <descr>The DockRect gives feedback to the user, where the dragged control may be dropped.
          When no docksite signals acceptance, the DockRect reflects the floating state of the dragged control.
          When a drop will dock the control, the DockRect signifies the approximate position of the docked control.
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.DropAlign">
        <short>How the dragged control will be docked, relative to the target control.</short>
        <descr>When the target is a DockTree, DropAlign indicates the placement of the control relative to DropOnControl.
          Other docking methods require a specialized (derived) DragDockObject.
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.DropOnControl">
        <short>The already docked control, relative to which the dragged control will be docked. Nil for an empty docksite.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.EraseDockRect">
        <short>The currently visible DockRect, to be removed later.</short>
        <descr>A special value indicates that the DockRect already has been removed.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.Floating">
        <short>The final state of the dragged control (after drop).</short>
        <descr>True when the dragged control becomes or stays floating.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.FrameWidth">
        <short>[Delphi compatible - dropped!]</short>
        <descr/>
        <seealso/>
      <notes><note>Delphi compatible - dropped!</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.IncreaseDockArea">
        <short>Determines whether the dock site shall be enlarged.</short>
        <descr>Not normally used, perhaps a special AnchorDocking property?</descr>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragDockObjectEx">
        <short>A drag object for docking, that is automatically destroyed after use.</short>
      </element>
      <element name="TDragDockObjectEx.Create">
        <short>Creates an object to be destroyed after use.</short>
      </element>
      <element name="TDragDockObjectEx.Create.AControl">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDockManager">
        <short>The layout manager for a docksite.</short>
        <descr>Every docksite can have an DockManager, which arranges the docked controls.
        </descr>
        <seealso>
          <link id="controls.TDockTree"/>
        </seealso>
      </element>
      <element name="TDockManager.Create">
        <short>Creates an DockManager for ADockSite</short>
      </element>
      <element name="TDockManager.Create.ADockSite">
        <short>This is the TWinControl acting as the docksite.</short>
      </element>
      <element name="TDockManager.MessageHandler">
        <short>Handles the messages sent to a docksite.</short>
        <descr>
          <p>This handler must handle all mouse messages, related to the client area of the docksite that is not covered by docked controls (dock headers...).</p>
          <p>Handling mouse messages while dragging is not required. Painting of the docksite has to be implemented in PaintSite.</p>
        </descr>
        <seealso>
          <link id="TDockManager.PaintSite"/>
        </seealso>
      </element>
      <element name="TDockManager.MessageHandler.Sender">
        <short/>
      </element>
      <element name="TDockManager.MessageHandler.Message">
        <short>The message to be processed.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.BeginUpdate">
        <short>Start updating the DockSite layout.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.EndUpdate">
        <short>Finish updating the DockSite layout.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.AutoFreeByControl">
        <short>Returns True if the DockManager should be destroyed together with the docksite.</short>
        <descr>
          <p>This is a Lazarus specific extension of the Delphi TDockManager. It allows multiple docksites to share the same DockManager instance.</p>
        </descr>
      </element>
      <element name="TDockManager.AutoFreeByControl.Result">
        <short>True if the DockManager should be destroyed together with the docksite.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.GetControlBounds">
        <short>Returns the zone bounds of a docked control.</short>
        <descr>
          <p>The TDockTree manager returns the bounds of the dockzone, including the dock header.</p>
          <p>When the Control is not docked, an empty Rect(0,0,0,0) is returned.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockManager.GetControlBounds.Control">
        <short>The docked control.</short>
      </element>
      <element name="TDockManager.GetControlBounds.AControlBounds">
        <short>The enclosing rectangle, in client coordinates of the docksite.</short>
      </element>
      <element name="TDockManager.GetDockEdge">
        <short>Determine the DropAlign.</short>
        <descr>
          <p>ADockObject contains valid DragTarget, DragPos and DragTargetPos relative dock site. DockRect is undetermined.</p>
          <p>DropOnControl may be Nil if nothing has been docked yet, or no target control exists at the mouse coordinates.</p>
          <p>Returns True if ADockObject.DropAlign has been determined. If False, the DropAlign has to be determined by default procedures.</p>
        </descr>
      </element>
      <element name="TDockManager.GetDockEdge.Result">
        <short>True if the DropAlign was determined.</short>
      </element>
      <element name="TDockManager.GetDockEdge.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.InsertControl">
        <short>Position <var>DropCtl</var> relative <var>Control</var>, using the alignment specified by <var>InsertAt</var>.</short>
        <descr>
          <p>InsertControl determines the placement of the just docked control, forcing a repaint of the container control if necessary.</p>
          <remark>When SetReplacingControl has been called with a non-Nil Control before, the dropped control only should replace that control.</remark>
          <p>An overloaded version passes the DragDockObject to the dockmanager, allowing to pass more information about the drop. It allows to implement other than tree-style docksites.</p>
        </descr>
        <errors/>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockManager.InsertControl.Control">
        <short>The control relative to which insert.</short>
      </element>
      <element name="TDockManager.InsertControl.InsertAt">
        <short>How to insert relative to Control.</short>
      </element>
      <element name="TDockManager.InsertControl.DropCtl">
        <short>The control to insert.</short>
      </element>
      <element name="TDockManager.InsertControl.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.LoadFromStream">
        <short>Restores the layout of the docksite from Stream.</short>
        <descr>The controls to be docked can be retrieved by ReloadDockedControl from the docksite; this method returns only existing controls of the given name, owned by the owner of the docksite, by default.</descr>
        <errors/>
        <seealso>
          <link id="TWinControl.ReloadDockedControl"/>
          <link id="TDockManager.SaveToStream"/>
        </seealso>
      </element>
      <element name="TDockManager.LoadFromStream.Stream">
        <short>The stream with the layout information.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.PaintSite">
        <short>Handles special painting of the docksite.</short>
        <descr>While the docked controls paint themselves, eventual dockheaders and other decoration have to be painted by the DockManager.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockManager.PaintSite.DC">
        <short>The device context, used to paint.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.PositionDockRect">
        <short>Determines the DockRect while dragging a control over the docksite.</short>
        <descr>
          <p>This method updates DockRect for the visual feedback, when a control is dragged over the docksite.</p>
          <p>The initial DragDockObject.DockRect spans the entire DockSite.</p>
          <p>The Delphi compatible version only can use the parameters determined by the default processing in the docksite.</p>
          <p>The Lazarus specific version can update the DockObject with better suited parameters.
            A DockManager here can implement any algorithm for the placement of a dropped control.
            The default implementation calls the Delphi compatible version.<br/>
            When you override the Lazarus version, you may have to determine the dock sibling and DropAlign again, when the default determination (in TControl and TWinControl) is inappropriate.
          </p>
        </descr>
        <errors/>
        <seealso>
          <link id="TDragDockObject"/>
        </seealso>
      </element>
      <element name="TDockManager.PositionDockRect.Client">
        <short>The dropped control.</short>
      </element>
      <element name="TDockManager.PositionDockRect.DropCtl">
        <short>The control relative to which Client shall be docked. Nil for docking into the docksite.</short>
      </element>
      <element name="TDockManager.PositionDockRect.DropAlign">
        <short>How to dock, relative to DropCtl.</short>
      </element>
      <element name="TDockManager.PositionDockRect.DockRect">
        <short>The screen rectangle of the docksite, to be adjusted by this method.</short>
      </element>
      <element name="TDockManager.PositionDockRect.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.RemoveControl">
        <short>Removes the undocked control from the docksite layout.</short>
        <descr>When SetReplacingControl has been called with a non-Nil argument before, the layout of the docksite should not be changed. Instead the next inserted control should take the place and role of this control.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockManager.RemoveControl.Control">
        <short>Control to remove.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.ResetBounds">
        <short>
          <var>ResetBounds</var> refreshes the layout of the docksite.</short>
        <descr>
          <p>This method typically notifies the DockManager of a Resize of the docksite.</p>
          <p>When the extent of the docksite really has changed, the DockManager should reposition and resize all docked controls accordingly.</p>
          <p>The layout always should be refreshed when <var>Force</var> is True. This is required when e.g. the visibility of docked controls has changed, but not the size of the docksite.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockManager.ResetBounds.Force">
        <short>When True, always update the layout.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.SaveToStream">
        <short>Saves the docksite layout to <var>Stream</var>.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TDockManager.LoadFromStream"/>
        </seealso>
      </element>
      <element name="TDockManager.SaveToStream.Stream">
        <short>Write the layout information into this stream.</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.SetReplacingControl">
        <short>Specifies the control to be replaced subsequently.</short>
        <descr>
          <p>This method is called by ReplaceDockedControl, to announce a pending replacement of <var>Control</var> by another control.
          The next RemoveControl should be ignored, and InsertControl should only exchange the controls, without reorganizing the layout of the docksite.
          When <var>Control</var> is Nil, this call signals the end of the exchange [obsolete].</p>
          <remark>The name "SetReplacingControl" is a misnomer, it should read "SetControlToBeReplaced".</remark>
          <p>The intended purpose of this method is the replacement of a docked control by a Notebook, preserving the DockZone.
            This operation should be handled by an DockManager internally, and calls to this method should be ignored.
          </p>
        </descr>
        <errors/>
        <seealso>
          <link id="TDockManager.InsertControl"/>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockManager.SetReplacingControl.Control">
        <short>The control to be replaced later.</short>
      </element>
      <element name="TDockManagerClass">
        <short>The DockManager class type, for use when a DockManager is automatically created.</short>
        <seealso>
          <link id="TWinControl.CreateDockManager"/>
          <link id="DefaultDockManagerClass"/>
        </seealso>
      </element>
      <element name="DefaultDockManagerClass">
        <short>The default class used to create an DockManager in <link id="TWinControl.CreateDockManager"/>.</short>
        <seealso>
          <link id="TDockManager"/>
        </seealso>
      </element>
      <!-- range type Visibility: default -->
      <element name="TConstraintSize">
        <short>Range of the control size constraints.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TSizeConstraintsOption">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceWidthAsMin">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceWidthAsMax">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceHeightAsMin">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceHeightAsMax">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- set type Visibility: default -->
      <element link="TSizeConstraintsOption" name="TSizeConstraintsOptions"/>
      <!-- object Visibility: default -->
      <element name="TSizeConstraints">
        <short>Holds maximum and minimum values that can be used in sizing objects.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FControl"/>
      <element name="TSizeConstraints.FMaxHeight"/>
      <element name="TSizeConstraints.FMaxInterfaceHeight"/>
      <element name="TSizeConstraints.FMaxInterfaceWidth"/>
      <element name="TSizeConstraints.FMaxWidth"/>
      <element name="TSizeConstraints.FMinHeight"/>
      <element name="TSizeConstraints.FMinInterfaceHeight"/>
      <element name="TSizeConstraints.FMinInterfaceWidth"/>
      <element name="TSizeConstraints.FMinWidth"/>
      <element name="TSizeConstraints.FOnChange"/>
      <element name="TSizeConstraints.FOptions"/>
      <!-- procedure Visibility: private -->
      <element name="TSizeConstraints.SetOptions"/>
      <element name="TSizeConstraints.SetOptions.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.Change">
        <short>Calls an OnChange handler if assigned.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#rtl.Classes.TPersistent.AssignTo" name="TSizeConstraints.AssignTo"/>
      <element name="TSizeConstraints.AssignTo.Dest">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TSizeConstraints.MaxHeight" name="TSizeConstraints.SetMaxHeight"/>
      <element name="TSizeConstraints.SetMaxHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TSizeConstraints.MaxWidth" name="TSizeConstraints.SetMaxWidth"/>
      <element name="TSizeConstraints.SetMaxWidth.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TSizeConstraints.MinHeight" name="TSizeConstraints.SetMinHeight"/>
      <element name="TSizeConstraints.SetMinHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TSizeConstraints.MinWidth" name="TSizeConstraints.SetMinWidth"/>
      <element name="TSizeConstraints.SetMinWidth.Value">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TSizeConstraints.Create"/>
      <element name="TSizeConstraints.Create.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TSizeConstraints.UpdateInterfaceConstraints">
        <short>Asks the interface for constraints.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TSizeConstraints.SetInterfaceConstraints">
        <short>Used by the interface to set the interface constraints.</short>
        <descr>Should only be used by custom components, not by applications.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MinW">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MinH">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MaxW">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MaxH">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMinWidth">
        <short>Determines the minimal applicable width, given the local and interface constraints.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMinWidth.Result">
        <short>Zero means no constraints.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMinHeight">
        <short>Determines the minimal applicable height, given the local and interface constraints.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMinHeight.Result">
        <short>Zero means no constraints.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMaxWidth">
        <short>Determines the maximum applicable width, given the local and interface constraints.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMaxWidth.Result">
        <short>Zero means no constraints.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMaxHeight">
        <short>Determines the maximum applicable height, given the local and interface constraints.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMaxHeight.Result">
        <short>Zero means no constraints.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.MinMaxWidth">
        <short>Determines the constrained Width, and transfers it to the widget.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.MinMaxWidth.Result">
        <short>The constrained width.</short>
      </element>
      <element name="TSizeConstraints.MinMaxWidth.Width">
        <short>The suggested width.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.MinMaxHeight">
        <short>Determines the constrained Height, and transfers it to the widget.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.MinMaxHeight.Result">
        <short>The constrained height.</short>
      </element>
      <element name="TSizeConstraints.MinMaxHeight.Height">
        <short>The suggested height.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MaxInterfaceHeight">
        <short>The maximum height allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MaxInterfaceWidth">
        <short>The maximum width allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MinInterfaceHeight">
        <short>The minimum height allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MinInterfaceWidth">
        <short>The minimum width allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.Control">
        <short>The <var>Control</var> to which these constraints apply.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.Options">
        <short>Options for the determination of the constraints.</short>
        <descr/>
        <seealso/>
      <notes><note>application?</note>
        </notes>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.OnChange">
        <short>Event handler for a change in the constraints.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MaxHeight">
        <short>The maximum height.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MaxWidth">
        <short>The maximum width.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MinHeight">
        <short>The minimum height.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MinWidth">
        <short>The minimum width.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TConstrainedResizeEvent">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TConstrainedResizeEvent.Sender">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MinWidth">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MinHeight">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MaxWidth">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MaxHeight">
        <short/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TSpacingSize">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- record type Visibility: default -->
      <element link="TControlBorderSpacing" name="TControlBorderSpacingDefault">
        <short>Defines the default values for TControlBorderSpacing.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element link="TControlBorderSpacing.Left" name="TControlBorderSpacingDefault.Left"/>
      <element link="TControlBorderSpacing.Top" name="TControlBorderSpacingDefault.Top"/>
      <element link="TControlBorderSpacing.Right" name="TControlBorderSpacingDefault.Right"/>
      <element link="TControlBorderSpacing.Bottom" name="TControlBorderSpacingDefault.Bottom"/>
      <element link="TControlBorderSpacing.Around" name="TControlBorderSpacingDefault.Around"/>
      <!-- pointer type Visibility: default -->
      <element link="TControlBorderSpacing" name="PControlBorderSpacingDefault"/>
      <!-- object Visibility: default -->
      <element name="TControlBorderSpacing">
        <short>Describes the (minimum) spacing around a control.</short>
        <descr>
          <p>TControlBorderSpacing defines the spacing around a control.
            The spacing around its children and between its children is defined in
            <link id="TWinControl.ChildSizing"/>.
          </p>
          <code>Left, Top, Right, Bottom: integer;
        minimum space left to the autosized control.
        For example: Control A lies left of control B.
        A has borderspacing Right=10 and B has borderspacing Left=5.
        Then A and B will have a minimum space of 10 between.

    Around: integer;
        same as Left, Top, Right and Bottom all at once. This will be added to
        the effective Left, Top, Right and Bottom.
        Example: Left=3 and Around=5 results in a minimum spacing to the left
        of 8.

    InnerBorder: integer;
        This is added to the preferred size.
        For example: A buttons widget returns 75x25 on GetPreferredSize.
        CalculatePreferredSize adds 2 times the InnerBorder to the width and
        height.
        
    CellAlignHorizontal, CellAlignVertical: TControlCellAlign;
        Used for example when the Parents.ChildSizing.Layout defines a table
        layout.
          </code>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element link="TControlBorderSpacing.Around" name="TControlBorderSpacing.FAround"/>
      <element link="TControlBorderSpacing.Bottom" name="TControlBorderSpacing.FBottom"/>
      <element name="TControlBorderSpacing.FCellAlignHorizontal"/>
      <element name="TControlBorderSpacing.FCellAlignVertical"/>
      <element name="TControlBorderSpacing.FControl"/>
      <element name="TControlBorderSpacing.FInnerBorder"/>
      <element name="TControlBorderSpacing.FLeft"/>
      <element name="TControlBorderSpacing.FOnChange"/>
      <element name="TControlBorderSpacing.FRight"/>
      <element name="TControlBorderSpacing.FTop"/>
      <element name="TControlBorderSpacing.FDefault"/>
      <!-- function Visibility: private -->
      <element link="TControlBorderSpacing.Around" name="TControlBorderSpacing.IsAroundStored"/>
      <element name="TControlBorderSpacing.IsAroundStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControlBorderSpacing.Bottom" name="TControlBorderSpacing.IsBottomStored"/>
      <element name="TControlBorderSpacing.IsBottomStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControlBorderSpacing.InnerBorder" name="TControlBorderSpacing.IsInnerBorderStored"/>
      <element name="TControlBorderSpacing.IsInnerBorderStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControlBorderSpacing.Left" name="TControlBorderSpacing.IsLeftStored"/>
      <element name="TControlBorderSpacing.IsLeftStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControlBorderSpacing.Right" name="TControlBorderSpacing.IsRightStored"/>
      <element name="TControlBorderSpacing.IsRightStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControlBorderSpacing.Top" name="TControlBorderSpacing.IsTopStored"/>
      <element name="TControlBorderSpacing.IsTopStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetAround">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.SetAround.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetBottom">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.SetBottom.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlBorderSpacing.CellAlignHorizontal" name="TControlBorderSpacing.SetCellAlignHorizontal"/>
      <element name="TControlBorderSpacing.SetCellAlignHorizontal.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlBorderSpacing.CellAlignVertical" name="TControlBorderSpacing.SetCellAlignVertical"/>
      <element name="TControlBorderSpacing.SetCellAlignVertical.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlBorderSpacing.InnerBorder" name="TControlBorderSpacing.SetInnerBorder"/>
      <element name="TControlBorderSpacing.SetInnerBorder.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlBorderSpacing.Left" name="TControlBorderSpacing.SetLeft"/>
      <element name="TControlBorderSpacing.SetLeft.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlBorderSpacing.Right" name="TControlBorderSpacing.SetRight"/>
      <element name="TControlBorderSpacing.SetRight.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlBorderSpacing.Space" name="TControlBorderSpacing.SetSpace"/>
      <element name="TControlBorderSpacing.SetSpace.Kind">
        <short/>
      </element>
      <element name="TControlBorderSpacing.SetSpace.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlBorderSpacing.Top" name="TControlBorderSpacing.SetTop"/>
      <element name="TControlBorderSpacing.SetTop.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlBorderSpacing.Change">
        <short>Invalidates the control, and invokes the <var>OnChange</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.Change.InnerSpaceChanged">
        <short>currently ignored (distinction no more required).</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControlBorderSpacing.Create"/>
      <element name="TControlBorderSpacing.Create.OwnerControl">
        <short>The associated control.</short>
      </element>
      <element name="TControlBorderSpacing.Create.ADefault">
        <short>Pointer to an record with default settings; can be Nil for all zero defaults.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#rtl.Classes.TPersistent.Assign" name="TControlBorderSpacing.Assign"/>
      <element name="TControlBorderSpacing.Assign.Source">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#rtl.Classes.TPersistent.AssignTo" name="TControlBorderSpacing.AssignTo"/>
      <element name="TControlBorderSpacing.AssignTo.Dest">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlBorderSpacing.IsEqual">
        <short>True if the specified spacing equals the current settings.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.IsEqual.Result">
        <short/>
      </element>
      <element name="TControlBorderSpacing.IsEqual.Spacing">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlBorderSpacing.GetSpaceAround">
        <short>Returns the bounds with added Around space.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.GetSpaceAround.SpaceAround">
        <short>Out parameter, initial contents are ignored!</short>
      </element>
      <!-- function Visibility: public -->
      <element link="TControlBorderSpacing.Space" name="TControlBorderSpacing.GetSpace"/>
      <element name="TControlBorderSpacing.GetSpace.Result">
        <short/>
      </element>
      <element name="TControlBorderSpacing.GetSpace.Kind">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlBorderSpacing.GetSideSpace">
        <short>The space on a control side, including Around space.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TControlBorderSpacing.GetSpace"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetSideSpace.Result">
        <short>The space value.</short>
      </element>
      <element name="TControlBorderSpacing.GetSideSpace.Kind">
        <short>The requested edge.</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Around">
        <short>The space to add to every side's individual space.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Bottom">
        <short>The space at the bottom border.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.CellAlignHorizontal">
        <short>The horizontal alignment inside a table cell.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.CellAlignVertical">
        <short>The vertical alignment inside a table cell.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlBorderSpacing.Control">
        <short>The control to which this border spacing applies.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.InnerBorder">
        <short>Space added to the widget's <link id="TControl.GetPreferredSize">preferred size</link>.</short>
        <descr>
          <p>When <link id="TControl.GetPreferredSize">calculating the preferred size</link> of control,
            the LCL asks the widget first.
          </p>
          <p>When the widget returns a preferred size, e.g. a TButton widget,
            then the InnerBorder is added twice to this size - e.g. to the Height for top and bottom space.
          </p>
          <p>If the widget does not return a preferred size, the InnerBorder has no effect.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Left">
        <short>The space at the left border.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.OnChange">
        <short>Event handler for a change in border spacing.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Right">
        <short>The space at the right border.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlBorderSpacing.Space">
        <short>Kind of array access to the space at every side.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.Space.Kind">
        <short>The side for which the space is requested.</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Top">
        <short>The space at the top border.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TAnchorSide">
        <short>Specifies how the side of a control is anchored to other controls.</short>
        <descr>
          <pre>TAnchorSide

    Class holding the reference sides of the anchors of a TControl.
    Every TControl has four AnchorSides:
    AnchorSide[akLeft], AnchorSide[akRight], AnchorSide[akTop] and
    AnchorSide[akBottom].
    Normally if Anchors contain akLeft, and the Parent is resized, the LCL
    tries to keep the distance between the left side of the control and the
    right side of its parent client area.
    With AnchorSide[akLeft] you can define a different reference side. The
    kept distance is defined by the BorderSpacing.
    
    Example1:
       +-----+  +-----+
       |  B  |  |  C  |
       |     |  +-----+
       +-----+

      If you want to have the top of B the same as the top of C use
        B.AnchorSide[akTop].Side:=asrTop;
        B.AnchorSide[akTop].Control:=C;
      If you want to keep a distance of 10 pixels between B and C use
        B.BorderSpacing.Right:=10;
        B.AnchorSide[akRight].Side:=asrLeft;
        B.AnchorSide[akRight].Control:=C;

      Do not setup in both directions, because this will create a circle, and
      circles are not allowed.
      
    Example2:
            +-------+
      +---+ |       |
      | A | |   B   |
      +---+ |       |
            +-------+
            
      Centering A relative to B:
        A.AnchorSide[akTop].Side:=asrCenter;
        A.AnchorSide[akTop].Control:=B;
      Or use this. It's equivalent:
        A.AnchorSide[akBottom].Side:=asrCenter;
        A.AnchorSide[akBottom].Control:=B;
</pre>
        </descr>
        <errors/>
        <seealso/>
      <notes><note>Make this an topic, describing *everything* related to anchoring?</note>
        </notes>
      </element>
      <!-- variable Visibility: private -->
      <element name="TAnchorSide.FControl"/>
      <element name="TAnchorSide.FKind"/>
      <element name="TAnchorSide.FOwner"/>
      <element name="TAnchorSide.FSide"/>
      <!-- function Visibility: private -->
      <element name="TAnchorSide.IsSideStored"/>
      <element name="TAnchorSide.IsSideStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TAnchorSide.SetControl"/>
      <element name="TAnchorSide.SetControl.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TAnchorSide.SetSide"/>
      <element name="TAnchorSide.SetSide.AValue">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TAnchorSide.GetOwner"/>
      <element name="TAnchorSide.GetOwner.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TAnchorSide.Create"/>
      <element name="TAnchorSide.Create.TheOwner">
        <short/>
      </element>
      <element name="TAnchorSide.Create.TheKind">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TAnchorSide.Destroy"/>
      <!-- procedure Visibility: public -->
      <element name="TAnchorSide.GetSidePosition">
        <short>Get information about the target control, side and side position.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TAnchorSide.GetSidePosition.ReferenceControl">
        <short>The control we are anchored to.</short>
      </element>
      <element name="TAnchorSide.GetSidePosition.ReferenceSide">
        <short>The side we are anchord to.</short>
      </element>
      <element name="TAnchorSide.GetSidePosition.Position">
        <short>Position of the side to anchor to.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TAnchorSide.CheckSidePosition">
        <short>Check for anchor cycles and invalid targets, and return information about the target side.</short>
        <descr/>
        <errors/>
          Can raise an exception 'TAnchorSide.CheckSidePosition invalid Side'.
        
        
        <seealso/>
      </element>
      <element name="TAnchorSide.CheckSidePosition.Result">
        <short>False when errors have been found.</short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.NewControl">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TAnchorSide.CheckSidePosition.NewSide">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TAnchorSide.CheckSidePosition.ReferenceControl">
        <short>The control we are anchored to.</short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.ReferenceSide">
        <short>The side we are anchord to.</short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.Position">
        <short>Position of the side to anchor to.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#rtl.Classes.TPersistent.Assign" name="TAnchorSide.Assign"/>
      <element name="TAnchorSide.Assign.Source">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TAnchorSide.IsAnchoredToParent">
        <short>True when we are anchored to our parent, at least on ParentSide</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TAnchorSide.IsAnchoredToParent.Result">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TAnchorSide.IsAnchoredToParent.ParentSide">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TAnchorSide.FixCenterAnchoring">
        <short>Remove conflicting anchors.</short>
        <descr>With asrCenter, both sides are controlled by one anchor.
          Disable opposite anchor and all aligning.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TAnchorSide.Owner">
        <short>The control being anchored.</short>
        <descr>For example AButton1.AnchorSide[akBottom].Owner = AButton1.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TAnchorSide.Kind">
        <short>The control side being anchored.</short>
        <descr>Every control has four AnchorSide, one for each side. For example AButton1.AnchorSide[akLeft].Kind=akLeft.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TAnchorSide.Control">
        <short>The target control of the anchor.</short>
        <descr>For example if the right side of a Button1 is anchored to the left side of Edit1,
          then Button1.AnchorSide[akRight].Control=Edit1 and Button1.AnchorSide[akRight].Side=asrLeft.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TAnchorSide.Side">
        <short>The side of the target Control, to which we anchor.</short>
        <descr>For example if the right side of a Button1 is anchored to the left side of Edit1,
          then Button1.AnchorSide[akRight].Control=Edit1 and Button1.AnchorSide[akRight].Side=asrLeft.</descr>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlActionLink">
        <short>Links an Action to a control.</short>
        <descr>
          <p>An ActionLink is created by a control, when an Action is assigned to the control.
            TControl.Action effectively becomes control.ActionLink.Action.
          </p>
          <p>The ActionLink propagates changes of Action properties to the client control.
            It's assumed that properties of the <b>same value</b> (in the Control and Action) are linked to the Action,
            and follow changes to the Action properties.
          </p>
          <p>Linked control properties are (by default):
          </p>
          <ul>
            <li>Caption</li>
            <li>Enabled</li>
            <li>Hint</li>
            <li>HelpContext, HelpKeyword, HelpType: these are linked only if all three property values match.</li>
            <li>Visible</li>
            <li>OnClick is linked to Action.Execute</li>
          </ul>
          <p>The control can update itself, when it receives a Change notification from the ActionLink
            <link id="TControl.ActionChange"/>.
          </p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: protected -->
      <element name="TControlActionLink.FClient">
        <short>The client control that is linked to the action.</short>
        <descr>It can be assumed that FClient is not Nil.</descr>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#rtl.Classes.TBasicActionLink.AssignClient" name="TControlActionLink.AssignClient">
        <short>Called during construction, sets FClient to the given control.</short>
      </element>
      <element name="TControlActionLink.AssignClient.AClient">
        <short>The control linked to the action.</short>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.ActnList.TActionLink.IsCaptionLinked" name="TControlActionLink.IsCaptionLinked"/>
      <element name="TControlActionLink.IsCaptionLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.ActnList.TActionLink.IsEnabledLinked" name="TControlActionLink.IsEnabledLinked"/>
      <element name="TControlActionLink.IsEnabledLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.ActnList.TActionLink.IsHelpLinked" name="TControlActionLink.IsHelpLinked">
        <short>Help properties are assumed linked only when all these properties match.</short>
        <descr>Compares the HelpContext, HelpKeyword and HelpType properties.</descr>
      </element>
      <element name="TControlActionLink.IsHelpLinked.Result">
        <short>True only if all three Control properties match the Action properties.</short>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.ActnList.TActionLink.IsHintLinked" name="TControlActionLink.IsHintLinked"/>
      <element name="TControlActionLink.IsHintLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.ActnList.TActionLink.IsVisibleLinked" name="TControlActionLink.IsVisibleLinked"/>
      <element name="TControlActionLink.IsVisibleLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlActionLink.IsOnExecuteLinked">
        <short>True if the client's OnClick is the action's OnExecute handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.IsOnExecuteLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlActionLink.DoShowHint">
        <short>Compose the hint string, depending on HintShortCuts.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Forms.TApplication.HintShortCuts"/>
        </seealso>
      </element>
      <element name="TControlActionLink.DoShowHint.Result">
        <short>Always True.</short>
      </element>
      <element name="TControlActionLink.DoShowHint.HintStr">
        <short>The hint to show.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetCaption">
        <short>Sets the client's Caption, if the old values match.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.ActnList.TActionLink.SetCaption">TActionLink.SetCaption</link>
        </seealso>
      </element>
      <element name="TControlActionLink.SetCaption.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetEnabled">
        <short>Sets client's Enabled, if the old values match.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetEnabled.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHint">
        <short>Sets client's Hint, if the old values match.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHelpContext">
        <short>Sets client's HelpContext, if the old Help properties match (IsHelpLinked).
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpContext.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHelpKeyword">
        <short>Sets client's HelpKeyword, if the old Help properties match (IsHelpLinked).
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpKeyword.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHelpType">
        <short>Sets client's HelpType, if the old Help properties match (IsHelpLinked).
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpType.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetVisible">
        <short>Sets client's Visible, if the old values match.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetVisible.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetOnExecute">
        <short>Set client's OnClick, if the old values match.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetOnExecute.Value">
        <short/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element link="TControlActionLink" name="TControlActionLinkClass">
        <short>Class of <link id="TControlActionLink"/>.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlAutoSizePhase">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspNone">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspChangingProperties">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspCreatingHandles">
        <short>create/destroy handles</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspComputingBounds">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspRealizingBounds">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAutoSizePhase.caspShowing">
        <short>make handles visible</short>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- set type Visibility: default -->
      <element link="TControlAutoSizePhase" name="TControlAutoSizePhases"/>
      <!-- constant Visibility: default -->
      <element link="TControlAutoSizePhase" name="AutoSizePhaseNames">
        <short>Names for TControlAutoSizePhase.</short>
      </element>
      <!-- range type Visibility: default -->
      <element name="TTabOrder">
        <short>Type of <link id="TWinControl.TabOrder"/>.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TControlShowHintEvent">
        <short>Handler type for OnShowHint.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlShowHintEvent.Sender">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlShowHintEvent.HintInfo">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TContextPopupEvent">
        <short>Handler type for OnContextPopup.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TContextPopupEvent.Sender">
        <short>The clicked control.</short>
      </element>
      <element name="TContextPopupEvent.MousePos">
        <short>Mouse position in client coordinates; (-1,-1) if the event was not generated by a click.</short>
      </element>
      <element name="TContextPopupEvent.Handled">
        <short>Set Handled to True when everything was handled; False shows the associated PopupMenu, by default.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlFlag">
        <short>Flags mostly for pending actions.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlFlag.cfLoading">
        <short>set by TControl.ReadState, unset by TControl.Loaded when all on form finished loading</short>
      </element>
      <element name="TControlFlag.cfAutoSizeNeeded">
        <short>Set when AutoSize was delayed</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlFlag.cfLeftLoaded">
        <short>Set when Left was set during loading.</short>
      </element>
      <element name="TControlFlag.cfTopLoaded">
        <short>Set when Top was set during loading.</short>
      </element>
      <element name="TControlFlag.cfWidthLoaded">
        <short>Set when Width was set during loading.</short>
      </element>
      <element name="TControlFlag.cfHeightLoaded">
        <short>Set when Height was set during loading.</short>
      </element>
      <element name="TControlFlag.cfClientWidthLoaded">
        <short>Set when ClientWidth was set during loading.</short>
      </element>
      <element name="TControlFlag.cfClientHeightLoaded">
        <short>Set when ClientHeight was set during loading.</short>
      </element>
      <element name="TControlFlag.cfBoundsRectForNewParentValid">
        <short>Set when BoundsRectForNewParent has been initialized.</short>
      </element>
      <element name="TControlFlag.cfBaseBoundsValid">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlFlag.cfPreferredSizeValid">
        <short>Set when PreferredSize has been calculated (CalculatePreferredSize).</short>
      </element>
      <element name="TControlFlag.cfPreferredMinSizeValid">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlFlag.cfOnChangeBoundsNeeded">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlFlag.cfProcessingWMPaint">
        <short>Set (in WndProc) while processing an LM_PAINT message.</short>
      </element>
      <element name="TControlFlag.cfKillChangeBounds">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlFlag.cfKillInvalidatePreferredSize">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlFlag.cfKillAdjustSize">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- set type Visibility: default -->
      <element link="TControlFlag" name="TControlFlags"/>
      <!-- enumeration type Visibility: default -->
      <element name="TControlHandlerType">
        <short>Notification handler types.</short>
        <descr>Notification handlers only receive an Sender, and must know themselves why they have been invoked.</descr>
        <seealso/>
      </element>
      <element name="TControlHandlerType.chtOnResize">
        <short>Notification request for OnResize.</short>
      </element>
      <element name="TControlHandlerType.chtOnChangeBounds">
        <short>Notification request for OnChangeBounds.</short>
      </element>
      <element name="TControlHandlerType.chtOnVisibleChanging">
        <short>Notification request for OnVisibleChanging.</short>
      </element>
      <element name="TControlHandlerType.chtOnVisibleChanged">
        <short>Notification request for OnVisibleChanged.</short>
      </element>
      <element name="TControlHandlerType.chtOnEnabledChanging">
        <short>Notification request for OnEnabledChanging.</short>
      </element>
      <element name="TControlHandlerType.chtOnEnabledChanged">
        <short>Notification request for OnEnabledChanged.</short>
      </element>
      <element name="TControlHandlerType.chtOnKeyDown">
        <short>Notification request for OnKeyDown.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TLayoutAdjustmentPolicy">
        <short>Indicates the policy for the LCL to execute automatic adjustments in the form layout</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.lapDefault">
        <short>widgetset dependent</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.lapFixedLayout">
        <short>A fixed absolute layout in all platforms</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.lapAutoAdjustWithoutHorizontalScrolling">
        <short>Smartphone platforms use this one, the x axis is stretched to fill the screen and the y is scaled to fit the DPI</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.lapAutoAdjustForDPI">
        <short>For desktops using High DPI, scale x and y to fit the DPI</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TLazAccessibilityRole">
        <short>Indicates the role which a accessible object takes in the user interface</short>
        <descr/>
        <seealso>
          <link id="TLazAccessibleObject"/>
        </seealso>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larAnimation">
        <short>An object that displays an animation</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larButton">
        <short>A button</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larCell">
        <short>A cell in a table</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larChart">
        <short>An object that displays a graphical representation of data</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larCheckBox">
        <short>An object that can be checked or unchecked, or sometimes in an intermediary state</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larClock">
        <short>A clock displaying time</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larColorPicker">
        <short>A control which allows selecting a color</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larComboBox">
        <short>A list of choices that the user can select from</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larDateField">
        <short>A controls which displays and possibly allows to choose a date</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larGrid">
        <short>A grid control which displays cells</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larGroup">
        <short>A control which groups others, such as a TGroupBox</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larIgnore">
        <short>Something to be ignored. For example a blank space between other objects</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larImage">
        <short>A graphic or picture or an icon</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larLabel">
        <short>A text label as usually placed near other widgets</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larListBox">
        <short>A list of items, from which the user can select one or more items</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larListItem">
        <short>An item in a list of items</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larMenuBar">
        <short>A main menu bar</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larMenuItem">
        <short>A item in a menu</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larProgressIndicator">
        <short>A control which shows a progress indication</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larRadioButton">
        <short>A radio button, see for example TRadioButton</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larResizeGrip">
        <short>A grip that the user can drag to change the size of widgets</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larScrollBar">
        <short>A control to scroll another one</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larSpinner">
        <short>A control which allows to increment / decrement a value</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larTabControl">
        <short>A control with tabs, like TPageControl</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larTextEditorMultiline">
        <short>A multi-line text editor (for example: TMemo, SynEdit)</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larTextEditorSingleline">
        <short>A single-line text editor (for example: TEdit)</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larTrackBar">
        <short>A control which allows to drag a slider</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larTreeView">
        <short>A list of items in a tree structure</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larTreeItem">
        <short>An item in a tree structure</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TLazAccessibilityRole.larWindow">
        <short>A top level window</short>
      </element>
      <!-- class Visibility: default -->
      <element name="TLazAccessibleObject">
        <short>Represents an accessible object with which the user of a accessibility tool can interact.</short>
        <descr>
          <p>Every TControl has a TLazAccessibleObject instace associated with it, which means that every TControl is potentially accessible, but to actually be usable the accessible object needs to have its properties set, the most important of which are the role, description and value. Native windowed classes should already receive accessibility properties from the underlying widgetset utilized, while TCustomControl descendents will have their accessibility taken care by the LCL itself. User applications should add accessibility for their own TCustomControl descendent classes and also possibly customize the descriptions of some elements. It is also possible to make an accessible object invisible for user, which is done by setting its AccessibleRole property to larIgnored.</p>
          <p>Accessibility support in Lazarus is also documented in the wiki in http://wiki.lazarus.freepascal.org/LCL_Accessibility</p>
        </descr>
        <seealso>
          <link id="TControl"/>
          <link id="TControl.AccessibleRole"/>
          <link id="TControl.AccessibleDescription"/>
          <link id="TControl.AccessibleValue"/>
          <link id="TLazAccessibilityRole"/>
        </seealso>
      </element>
      <!-- variable Visibility: public -->
      <element name="TLazAccessibleObject.OwnerControl">
        <short>The control that this accessible object is attached to. It might be the main accessible object of this control or it might represent a sub-part of a control.</short>
        <descr><p>The control that this accessible object is attached to. It might be the main accessible object of this control or it might represent a sub-part of a control which does not have a corresponding TControl, like an item of TTreeView. One can verify if this is the main accessible object of the control by checking if (lAccessibleObject.OwnerControl = lAccessibleObject.OwnerControl.GetAccessibleObject())</p>
        </descr>
        <seealso>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>
      <!-- variable Visibility: public -->
      <element name="TLazAccessibleObject.Parent">
        <short>The parent TLazAccessibleObject of this accessible object</short>
      </element>
      <!-- variable Visibility: public -->
      <element name="TLazAccessibleObject.DataObject">
        <short>Available to be used to connect to an object</short>
      </element>
      <!-- variable Visibility: public -->
      <element name="TLazAccessibleObject.SecondaryHandle">
        <short>Available for Widgetsets to use</short>
      </element>
      <element link="#rtl.System.TObject.Create" name="TLazAccessibleObject.Create"/>
      <element link="#rtl.System.TObject.Destroy" name="TLazAccessibleObject.Destroy"/>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.HandleAllocated">
        <short>Returns if the handle of this object was already allocated or not</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.InitializeHandle">
        <short>Utilized to set all properties of this property via widgetset routines when creating the handle</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.SetAccessibleDescription">
        <short>Setter for the property AccessibleDescription</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.SetAccessibleValue">
        <short>Setter for the property AccessibleValue</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.SetAccessibleRole">
        <short>Setter for the property AccessibleRole</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.FindOwnerWinControl">
        <short>Inspect the tree of accessible objects upwards until it finds a parent which is attached directly to a windowed control, a TWinControl</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.AddChildAccessibleObject">
        <short>Creates a new child accessible object and returns it</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.InsertChildAccessibleObject">
        <short>Inserts an already created child accessible object as a child of this one</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.ClearChildAccessibleObjects">
        <short>Removes all children of this control. It will free them if they are not attached to a TControl</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.RemoveChildAccessibleObject">
        <short>Removes a child accessible object</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.GetChildAccessibleObject">
        <short>Obtains a child accessible object by its index</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.GetChildAccessibleObject">
        <short>Obtains a child accessible object by its index</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.GetChildAccessibleObjectWithDataObject">
        <short>Obtains a child accessible object by its DataObject property</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.GetChildAccessibleObjectsCount">
        <short>Returns the number of direct children that this accessible object has</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.GetSelectedChildAccessibleObject">
        <short>Returns the currently selected child accessible object or nil if none are selected. Override this method in your sub class.</short>
        <seealso>
          <link id="TControl.GetSelectedChildAccessibleObject"/>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TLazAccessibleObject.GetChildAccessibleObjectAtPos">
        <short>Returns the child of this control located at a particular position given as a client position of the control</short>
        <seealso>
          <link id="TControl.GetChildAccessibleObjectAtPos"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TLazAccessibleObject.AccessibleDescription">
        <short>The description of this accessible object</short>
        <seealso>
          <link id="TControl.AccessibleDescription"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TLazAccessibleObject.AccessibleValue">
        <short>The value of this accessible object</short>
        <seealso>
          <link id="TControl.AccessibleValue"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TLazAccessibleObject.AccessibleRole">
        <short>The role of this accessible object</short>
        <seealso>
          <link id="TControl.AccessibleRole"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TLazAccessibleObject.Position">
        <short>The position of this accessible object</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TLazAccessibleObject.Size">
        <short>The size of this accessible object</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TLazAccessibleObject.Handle">
        <short>The widgetset handle of this accessible object</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TControl">
        <short>The base class for visible controls.</short>
      </element>
      <!-- variable Visibility: private -->
      <element link="TControl.ActionLink" name="TControl.FActionLink"/>
      <element link="TControl.Align" name="TControl.FAlign"/>
      <element link="TControl.AnchoredControls" name="TControl.fAnchoredControls"/>
      <element link="TControl.Anchors" name="TControl.FAnchors"/>
      <element link="TControl.AnchorSides" name="TControl.FAnchorSides"/>
      <element link="TControl.AutoSize" name="TControl.FAutoSize"/>
      <element link="TControl.AutoSizingAll" name="TControl.FAutoSizingAll"/>
      <element link="TControl.AutoSizingLockCount" name="TControl.FAutoSizingLockCount"/>
      <element name="TControl.FAutoSizingSelf">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element link="TControl.BaseBounds" name="TControl.FBaseBounds"/>
      <element name="TControl.FBaseBoundsLock">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element link="TControl.BaseParentClientSize" name="TControl.FBaseParentClientSize"/>
      <element link="TControl.BiDiMode" name="TControl.FBiDiMode"/>
      <element link="TControl.BorderSpacing" name="TControl.FBorderSpacing"/>
      <element link="TControl.BoundsRectForNewParent" name="TControl.FBoundsRectForNewParent"/>
      <element link="TControl.Caption" name="TControl.FCaption"/>
      <element link="TControl.CaptureMouseBottons" name="TControl.FCaptureMouseButtons"/>
      <element link="TControl.Color" name="TControl.FColor"/>
      <!-- variable Visibility: public -->
      <element name="TControl.FCompStyle">
        <short>Deprecated, don't use it.</short>
      </element>
      <element link="TControl.Constraints" name="TControl.FConstraints"/>
      <element link="TControlFlag" name="TControl.FControlFlags"/>
      <element name="TControl.FControlHandlers">
        <short>Array of the installable notification handlers.
        </short>
      </element>
      <element link="TControl.ControlState" name="TControl.FControlState">
        <short>State flags.
        </short>
      </element>
      <element link="TControl.ControlStyle" name="TControl.FControlStyle"/>
      <element link="TControl.Cursor" name="TControl.FCursor">
        <short>The cursor shape for this control.
        </short>
      </element>
      <element link="TControl.DesktopFont" name="TControl.FDesktopFont"/>
      <element link="TControl.DockOrientation" name="TControl.FDockOrientation"/>
      <element link="TControl.DragCursor" name="TControl.FDragCursor"/>
      <element link="TControl.DragKind" name="TControl.FDragKind"/>
      <element link="TControl.DragMode" name="TControl.FDragMode"/>
      <element link="TControl.Enabled" name="TControl.FEnabled"/>
      <element link="TControl.FloatingDockSiteClass" name="TControl.FFloatingDockSiteClass"/>
      <element link="TControl.Font" name="TControl.FFont"/>
      <element link="TControl.Height" name="TControl.FHeight"/>
      <element link="TControl.HelpContext" name="TControl.FHelpContext"/>
      <element link="TControl.HelpKeyword" name="TControl.FHelpKeyword"/>
      <element link="TControl.HelpType" name="TControl.FHelpType"/>
      <element link="TControl.Hint" name="TControl.FHint"/>
      <element link="TControl.HostDockSite" name="TControl.FHostDockSite"/>
      <element link="TControl.IsControl" name="TControl.FIsControl"/>
      <element name="TControl.FLastDoChangeBounds"/>
      <element name="TControl.FLastDoChangeClientSize"/>
      <element name="TControl.FLastResizeClientHeight"/>
      <element name="TControl.FLastResizeClientWidth"/>
      <element name="TControl.FLastResizeHeight"/>
      <element name="TControl.FLastResizeWidth"/>
      <element link="TControl.Left" name="TControl.FLeft"/>
      <element name="TControl.FLoadedClientSize">
        <short>Intended ClientSize, initialized during loading</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element link="TControl.LRDockWidth" name="TControl.FLRDockWidth"/>
      <element link="TControl.MouseEntered" name="TControl.FMouseEntered"/>
      <element link="TControl.OnChangeBounds" name="TControl.FOnChangeBounds"/>
      <element link="TControl.OnClick" name="TControl.FOnClick"/>
      <element link="TControl.OnConstrainedResize" name="TControl.FOnConstrainedResize"/>
      <element link="TControl.OnContextPopup" name="TControl.FOnContextPopup"/>
      <element link="TControl.OnDblClick" name="TControl.FOnDblClick"/>
      <element link="TControl.OnDragDrop" name="TControl.FOnDragDrop"/>
      <element link="TControl.OnDragOver" name="TControl.FOnDragOver"/>
      <element link="TControl.OnEditingDone" name="TControl.FOnEditingDone"/>
      <element link="TControl.OnEndDock" name="TControl.FOnEndDock"/>
      <element link="TControl.OnEndDrag" name="TControl.FOnEndDrag"/>
      <element link="TControl.OnMouseDown" name="TControl.FOnMouseDown"/>
      <element link="TControl.OnMouseEnter" name="TControl.FOnMouseEnter"/>
      <element link="TControl.OnMouseLeave" name="TControl.FOnMouseLeave"/>
      <element link="TControl.OnMouseMove" name="TControl.FOnMouseMove"/>
      <element link="TControl.OnMouseUp" name="TControl.FOnMouseUp"/>
      <element link="TControl.OnMouseWheel" name="TControl.FOnMouseWheel"/>
      <element link="TControl.OnMouseWheelDown" name="TControl.FOnMouseWheelDown"/>
      <element link="TControl.OnMouseWheelUp" name="TControl.FOnMouseWheelUp"/>
      <element link="TControl.OnQuadClick" name="TControl.FOnQuadClick"/>
      <element link="TControl.OnResize" name="TControl.FOnResize"/>
      <element link="TControl.OnShowHint" name="TControl.FOnShowHint"/>
      <element link="TControl.OnStartDock" name="TControl.FOnStartDock"/>
      <element link="TControl.OnStartDrag" name="TControl.FOnStartDrag"/>
      <element link="TControl.OnTripleClick" name="TControl.FOnTripleClick"/>
      <element link="TControl.Parent" name="TControl.FParent"/>
      <element link="TControl.ParentBiDiMode" name="TControl.FParentBiDiMode"/>
      <element link="TControl.ParentColor" name="TControl.FParentColor"/>
      <element link="TControl.ParentFont" name="TControl.FParentFont"/>
      <element link="TControl.ShowHint" name="TControl.FParentShowHint"/>
      <element link="TControl.PopupMenu" name="TControl.FPopupMenu"/>
      <element name="TControl.FPreferredHeight"/>
      <element name="TControl.FPreferredMinHeight"/>
      <element name="TControl.FPreferredMinWidth"/>
      <element name="TControl.FPreferredWidth"/>
      <element link="TControl.ReadBounds" name="TControl.FReadBounds"/>
      <element link="TControl.SessionProperties" name="TControl.FSessionProperties"/>
      <element link="TControl.ShowHint" name="TControl.FShowHint"/>
      <element name="TControl.FSizeLock">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element link="TControl.TBDockHeight" name="TControl.FTBDockHeight"/>
      <element link="TControl.Top" name="TControl.FTop"/>
      <element link="TControl.UndockHeight" name="TControl.FUndockHeight"/>
      <element link="TControl.UndockWidth" name="TControl.FUndockWidth"/>
      <element link="TControl.Visible" name="TControl.FVisible"/>
      <element link="TControl.Width" name="TControl.FWidth"/>
      <element link="TControl.WindowProc" name="TControl.FWindowProc"/>
      <!-- function Visibility: private -->
      <element link="TControl.CaptureMouseBottons" name="TControl.CaptureMouseButtonsIsStored"/>
      <element name="TControl.CaptureMouseButtonsIsStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoActionChange">
        <short>Internal handler for a changed Action, invoked from the ActionLink.</short>
        <descr>When the action is assigned to this control, updates related properties using <link id="TControl.ActionChange">ActionChange</link>.</descr>
      </element>
      <element name="TControl.DoActionChange.Sender">
        <short>The changed Action.</short>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.AutoSizingAll" name="TControl.GetAutoSizingAll"/>
      <element name="TControl.GetAutoSizingAll.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.AnchorSide" name="TControl.GetAnchorSide"/>
      <element name="TControl.GetAnchorSide.Result">
        <short/>
      </element>
      <element name="TControl.GetAnchorSide.Kind">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.AnchoredControls" name="TControl.GetAnchoredControls"/>
      <element name="TControl.GetAnchoredControls.Result">
        <short/>
      </element>
      <element name="TControl.GetAnchoredControls.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.BoundsRect" name="TControl.GetBoundsRect"/>
      <element name="TControl.GetBoundsRect.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.ClientHeight" name="TControl.GetClientHeight"/>
      <element name="TControl.GetClientHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.ClientWidth" name="TControl.GetClientWidth"/>
      <element name="TControl.GetClientWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.LRDockWidth" name="TControl.GetLRDockWidth"/>
      <element name="TControl.GetLRDockWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.MouseCapture" name="TControl.GetMouseCapture"/>
      <element name="TControl.GetMouseCapture.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.TBDockHeight" name="TControl.GetTBDockHeight"/>
      <element name="TControl.GetTBDockHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetText">
        <short>Returns the Text property.</short>
        <descr>Uses RealGetText (FCaption), instead of GetTextBuf (WM_GETTEXT), if possible.</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.GetTextBuf">GetTextBuf</link>
          <link id="#lcl.Controls.TControl.RealGetText"/>
        </seealso>
      </element>
      <element name="TControl.GetText.Result">
        <short>The Text property.</short>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.UndockHeight" name="TControl.GetUndockHeight"/>
      <element name="TControl.GetUndockHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.UndockWidth" name="TControl.GetUndockWidth"/>
      <element name="TControl.GetUndockWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.Anchors" name="TControl.IsAnchorsStored"/>
      <element name="TControl.IsAnchorsStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.BiDiMode" name="TControl.IsBiDiModeStored"/>
      <element name="TControl.IsBiDiModeStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.Caption" name="TControl.IsCaptionStored"/>
      <element name="TControl.IsCaptionStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.Enabled" name="TControl.IsEnabledStored"/>
      <element name="TControl.IsEnabledStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.Font" name="TControl.IsFontStored"/>
      <element name="TControl.IsFontStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.Hint" name="TControl.IsHintStored"/>
      <element name="TControl.IsHintStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.HelpContext" name="TControl.IsHelpContextStored"/>
      <element name="TControl.IsHelpContextStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.HelpKeyword" name="TControl.IsHelpKeyWordStored"/>
      <element name="TControl.IsHelpKeyWordStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.OnClick" name="TControl.IsOnClickStored"/>
      <element name="TControl.IsOnClickStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.ShowHint" name="TControl.IsShowHintStored"/>
      <element name="TControl.IsShowHintStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.Visible" name="TControl.IsVisibleStored"/>
      <element name="TControl.IsVisibleStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoBeforeMouseMessage">
        <short>Generate MouseEnter and MouseLeave events</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoConstrainedResize">
        <short>Adjust the intended (given) Bounds, according to Constraints.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TControl.Constraints"/>
          <link id="TControl.ConstrainedResize"/>
        </seealso>
      </element>
      <element name="TControl.DoConstrainedResize.NewLeft">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewTop">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewWidth">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewHeight">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoMouseDown">
        <short>Message handler for mouse button going down. Calls MouseDown handler.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TControl.DoMouseUp"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseDown"/>
        </seealso>
      </element>
      <element name="TControl.DoMouseDown.Message">
        <short/>
      </element>
      <element name="TControl.DoMouseDown.Button">
        <short/>
      </element>
      <element name="TControl.DoMouseDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoMouseUp">
        <short>Message handler for mouse button going up. Calls MouseUp handler.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TControl.DoMouseDown"/>
          <link id="TControl.MouseUp"/>
          <link id="TControl.OnMouseUp"/>
        </seealso>
      </element>
      <element name="TControl.DoMouseUp.Message">
        <short/>
      </element>
      <element name="TControl.DoMouseUp.Button">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetAnchorSide">
        <short>Setter for AnchorSideLeft...</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetAnchorSide.Kind">
        <short/>
      </element>
      <element name="TControl.SetAnchorSide.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.BorderSpacing" name="TControl.SetBorderSpacing"/>
      <element name="TControl.SetBorderSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.BoundsRect" name="TControl.SetBoundsRect"/>
      <element name="TControl.SetBoundsRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.BoundsRectForNewParent" name="TControl.SetBoundsRectForNewParent"/>
      <element name="TControl.SetBoundsRectForNewParent.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.ClientHeight" name="TControl.SetClientHeight"/>
      <element name="TControl.SetClientHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.ClientRect" name="TControl.SetClientSize"/>
      <element name="TControl.SetClientSize.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.ClientWidth" name="TControl.SetClientWidth"/>
      <element name="TControl.SetClientWidth.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.Constraints" name="TControl.SetConstraints"/>
      <element name="TControl.SetConstraints.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.DesktopFont" name="TControl.SetDesktopFont"/>
      <element name="TControl.SetDesktopFont.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.DragCursor" name="TControl.SetDragCursor"/>
      <element name="TControl.SetDragCursor.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.Font" name="TControl.SetFont"/>
      <element name="TControl.SetFont.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.Height" name="TControl.SetHeight"/>
      <element name="TControl.SetHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.HelpContext" name="TControl.SetHelpContext"/>
      <element name="TControl.SetHelpContext.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.HelpKeyword" name="TControl.SetHelpKeyword"/>
      <element name="TControl.SetHelpKeyword.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.HostDockSite" name="TControl.SetHostDockSite"/>
      <element name="TControl.SetHostDockSite.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.Left" name="TControl.SetLeft"/>
      <element name="TControl.SetLeft.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.MouseCapture" name="TControl.SetMouseCapture"/>
      <element name="TControl.SetMouseCapture.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.ParentShowHint" name="TControl.SetParentShowHint"/>
      <element name="TControl.SetParentShowHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.ParentColor" name="TControl.SetParentColor"/>
      <element name="TControl.SetParentColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.ParentFont" name="TControl.SetParentFont"/>
      <element name="TControl.SetParentFont.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.PopupMenu" name="TControl.SetPopupMenu"/>
      <element name="TControl.SetPopupMenu.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.ShowHint" name="TControl.SetShowHint"/>
      <element name="TControl.SetShowHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetText">
        <short>Sets the Text property.</short>
        <descr>Uses RealSetText instead of SetTextBuf, if possible.</descr>
        <seealso>
          <link id="TControl.Text">Text</link>
          <link id="#lcl.Controls.TControl.RealSetText">RealSetText</link>
          <link id="#lcl.Controls.TControl.SetTextBuf">SetTextBuf</link>
        </seealso>
      </element>
      <element name="TControl.SetText.Value">
        <short>The new Text.</short>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.Top" name="TControl.SetTop"/>
      <element name="TControl.SetTop.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.Width" name="TControl.SetWidth"/>
      <element name="TControl.SetWidth.Value">
        <short/>
      </element>
      <element link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass" name="TControl.WSRegisterClass"/>
      <!-- function Visibility: protected -->
      <element link="TControl.Cursor" name="TControl.GetCursor"/>
      <element name="TControl.GetCursor.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.Cursor" name="TControl.SetCursor"/>
      <element name="TControl.SetCursor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.Visible" name="TControl.SetVisible"/>
      <element name="TControl.SetVisible.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoOnParentHandleDestruction">
        <short/>
        <descr>implement in descendants
        </descr>
        <errors/>
        <seealso/>
      <notes><note>?</note><note>what?</note>
        </notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoAutoSize">
        <short>For internal use only - call AdjustSize instead!
        </short>
        <descr>
          <p>IMPORTANT: Many Delphi controls override this method and many call this method directly after setting some properties.</p>
          <p>During handle creation not all interfaces can create complete Device Contexts which are needed to calculate things like text size.</p>
          <p>That's why you should always call <link id="#lcl.Controls.TControl.AdjustSize">AdjustSize</link> instead of <var>DoAutoSize</var>.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.AutoSize">AutoSize topic</link>
          <link id="#lcl.Controls.TControl.AdjustSize">TControl.AdjustSize</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoAllAutoSize">
        <short>Run DoAutoSize until done.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.BeginAutoSizing">
        <short>Sets AutoSizing=true, used to prevent loops.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.EndAutoSizing">
        <short>End of the autosizing process, resets AutoSizing to False.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.AnchorSideChanged">
        <short>Request further processing after an anchor side was changed.</short>
      </element>
      <element name="TControl.AnchorSideChanged.TheAnchorSide">
        <short>Ignored.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ForeignAnchorSideChanged">
        <short>Request further processing after an anchor side has changed, that anchors another control to this one.</short>
      </element>
      <element name="TControl.ForeignAnchorSideChanged.TheAnchorSide">
        <short/>
      </element>
      <element name="TControl.ForeignAnchorSideChanged.Operation">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.Align" name="TControl.SetAlign"/>
      <element name="TControl.SetAlign.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.Anchors" name="TControl.SetAnchors"/>
      <element name="TControl.SetAnchors.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.AutoSize" name="TControl.SetAutoSize"/>
      <element name="TControl.SetAutoSize.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.BoundsChanged">
        <short>Invoked when the Bounds of the control have been changed. Override as required.</short>
      </element>
      <element name="TControl.CreateControlBorderSpacing">
        <short>Creates the default ControlBorderSpacing object.
          Allow descendant controls to override this default.</short>
        <seealso>
          <link id="TControlBorderSpacing"/>
        </seealso>
      </element>
      <element name="TControl.CreateControlBorderSpacing.Result">
        <short>The created ControlBorderSpacing instance.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoConstraintsChange">
        <short>Reacts on a change in the control's constraints.
          Calls AdjustSize by default.
        </short>
      </element>
      <element name="TControl.DoConstraintsChange.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoBorderSpacingChange">
        <short>Reacts on a change in the control's border spacing.</short>
      </element>
      <element name="TControl.DoBorderSpacingChange.Sender">
        <short/>
      </element>
      <element name="TControl.DoBorderSpacingChange.InnerSpaceChanged">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.IsBorderSpacingInnerBorderStored">
        <short>Checks for a defined (non-zero) BorderSpacing.InnerBorder.</short>
      </element>
      <element name="TControl.IsBorderSpacingInnerBorderStored.Result">
        <short>True when InnerBorder has to be taken into account.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SendMoveSizeMessages">
        <short>Sends Move and Size messages through the LCL message paths.
        </short>
        <descr>
          <p>Overridden in TWinControl, in TControl it's a NOP.
          </p>
          <p>This method simulates the VCL behaviour and has no real effect.
          </p>
        </descr>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControl.SendMoveSizeMessages.SizeChanged">
        <short/>
      </element>
      <element name="TControl.SendMoveSizeMessages.PosChanged">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize">
        <short>Invokes the <link id="#lcl.Controls.TControl.OnConstrainedResize"/> handler, allowing to modify the suggested Constraints.
        </short>
      </element>
      <element name="TControl.ConstrainedResize.MinWidth">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MinHeight">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MaxWidth">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MaxHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CalculatePreferredSize">
        <short>Override this method to return the preferred height and width.
        </short>
        <descr>
          <p>Calculates the preferred width and height for a control,
            which is used by the LCL autosizing algorithms as the default size.
            Negative or 0 are treated as undefined and the LCL uses other sizes instead.
          </p>
          <p>
            <var>TWinControl</var> overrides this and asks the interface for theme dependent values.
            See 
            
            <link id="TWinControl.CalculatePreferredSize"/> for more information.
          </p>
          <p>WithThemeSpace: If true, adds space for stacking.
          </p>
          <p>For example: <var>TRadioButton</var> has a minimum size.
            But for stacking multiple TRadioButtons there should be some space around.
            This space is theme dependent, so the parameter is passed to the widgetset.
          </p>
        </descr>
      </element>
      <element name="TControl.CalculatePreferredSize.PreferredWidth">
        <short>Set this argument to the preferred width.</short>
      </element>
      <element name="TControl.CalculatePreferredSize.PreferredHeight">
        <short>Set this argument to the preferred height.</short>
      </element>
      <element name="TControl.CalculatePreferredSize.WithThemeSpace">
        <short>True when space around stacked controls should be added.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoOnResize">
        <short>Invokes the <link id="#lcl.Controls.TControl.OnResize">OnResize</link> notification handler.
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoOnChangeBounds">
        <short>Invokes the <link id="#lcl.Controls.TControl.OnChangeBounds">OnChangeBounds</link> event handler</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CheckOnChangeBounds">
        <short>Checks for changes and calls <link id="#lcl.Controls.TControl.DoOnChangeBounds">DoOnChangeBounds</link> if needed.
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Resize">
        <short>Checks for changes and calls <link id="#lcl.Controls.TControl.DoOnResize">DoOnResize</link> if needed.
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.RequestAlign">
        <short>Smart calling of <var>Parent.AlignControls</var> (very indirectly).
        </short>
        <seealso>
          <link id="TWinControl.AlignControls"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UpdateAnchorRules">
        <short>Update the rules for anchoring the control</short>
      <notes><note>or of anchored controls?</note>
        </notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ChangeBounds">
        <short>Sets the bounds (left, top, height, width) optionally the BaseBounds of the control.</short>
        <descr>
          <p>ChangeBounds is called whenever the position or size of the control is set,
            either via the properties or by the layouter of the LCL.
          </p>
          <p>SetBounds calls internally ChangeBounds with KeepBase=false,
            while the LCL layouter calls it with KeepBase=true.
          </p>
          <p>Override this for code that might change the preferred size or resizes other controls.
          </p>
          <p>You can call this function in your custom controls.
            Keep in mind that the given aLeft, aTop, aWidth, aHeight might not be valid and will be changed by the LCL before applied.
          </p>
        </descr>
      </element>
      <element name="TControl.ChangeBounds.ALeft">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.ATop">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.AWidth">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.AHeight">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.KeepBase">
        <short>True when the BaseBounds should not be modified.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoSetBounds">
        <short>Internal function to set the control's bounds (Left, Top, Height, Width).</short>
        <descr>
          <p>DoSetBounds is a low level function to set the private variables FLeft, FTop, FWidth, FHeight.
            Do not call this function, only the LCL calls it.
          </p>
          <p>It also updates FClientWidth and FClientHeight accordingly.
          </p>
          <p>Override this to update the content layout of the control, for example scroll bars.
            As always: do not paint here, but call Invalidate and paint in OnPaint or override Paint.
          </p>
        </descr>
      <notes><note>The following doesn't look correct?</note>
        </notes>
      </element>
      <element name="TControl.DoSetBounds.ALeft">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.ATop">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.AWidth">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.AHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ScaleConstraints">
        <short>Scale the minimum and maximum Width and Height.</short>
        <descr>ScaleConstraints is called during ChangeScale, you never will call it directly.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.ScaleConstraints.Multiplier">
        <short/>
      </element>
      <element name="TControl.ScaleConstraints.Divider">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ChangeScale">
        <short>Apply scaling (multiplier and divider) to the control's coordinates and Font.</short>
        <descr/>
      </element>
      <element name="TControl.ChangeScale.Multiplier">
        <short/>
      </element>
      <element name="TControl.ChangeScale.Divider">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.CanAutoSize">
        <short>Function to determine if autosizing is possible, and if so,
          gets the new width and height</short>
        <descr>Override this to return different values.
        </descr>
      </element>
      <element name="TControl.CanAutoSize.Result">
        <short>TControl returns True.</short>
      </element>
      <element name="TControl.CanAutoSize.NewWidth">
        <short>Suggested width, can be adjusted in an overridden version.</short>
      </element>
      <element name="TControl.CanAutoSize.NewHeight">
        <short>Suggested height, can be adjusted in an overridden version.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UpdateAlignIndex">
        <short>Move this control to position 0 of Parent.FAlignOrder.</short>
        <descr>Affects the order in which client controls with the same alignment are positioned
        </descr>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.BiDiMode" name="TControl.SetBiDiMode"/>
      <element name="TControl.SetBiDiMode.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControl.ParentBiDiMode" name="TControl.SetParentBiDiMode"/>
      <element name="TControl.SetParentBiDiMode.AValue">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.IsAParentAligning">
        <short>Determine if a parent control is involved in the alignment process</short>
      </element>
      <element name="TControl.IsAParentAligning.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="TControl.ClientOrigin" name="TControl.GetClientOrigin"/>
      <element name="TControl.GetClientOrigin.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="TControl.ClientRect" name="TControl.GetClientRect"/>
      <element name="TControl.GetClientRect.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetLogicalClientRect">
        <short>Logical client area, can be bigger than the visible client area.</short>
        <descr>A <link id="Forms.TScrollingWinControl"/> has a logical client area, of which only a portion can be visible.
          The origin always is (0,0), regardless of an ScrollOffset.</descr>
        <seealso>
          <link id="TControl.BoundsRect"/>
          <link id="TControl.ClientRect"/>
          <link id="TControl.GetScrolledClientRect"/>
        </seealso>
      </element>
      <element name="TControl.GetLogicalClientRect.Result">
        <short>TControl returns the ClientRect.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetScrolledClientRect">
        <short>Get the visible part of the logical client area.</short>
        <descr>
          <p>Includes the ScrollOffset in a TScrollingWinControl Parent.</p>
          <p>TControl: When the Parent is a TScrollingWinControl, the ClientRect is offset by its ScrollOffset.
            This Rect can be intersected with the visible ClientArea of the Parent, to get the really visible part of the control.
          </p>
          <p>TWinControl: The visible ClientRect is offset by ScrollOffset, to reflect the visible part of the logical ClientRect.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TControl.GetScrolledClientRect"/>
        </seealso>
      </element>
      <element name="TControl.GetScrolledClientRect.Result">
        <short>The scrolled ClientRect (TopLeft, BottomRight).
        </short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetClientScrollOffset">
        <short>Returns the offset of the scrolled client area (in a scrolling TWinControl).</short>
        <descr>The overridden method may fail when the TScrollingWinControl has only one scrollbar
        </descr>
        <seealso>
          <link id="TControl.GetScrolledClientRect"/>
          <link id="#lcl.Forms.TScrollingWinControl.GetClientScrollOffset"/>
        </seealso>
      <notes><note>!?</note>
        </notes>
      </element>
      <element name="TControl.GetClientScrollOffset.Result">
        <short>The X and Y offsets of the visible client area, equal to the scrollbar positions.</short>
      </element>
      <!-- function Visibility: protected -->
      <element link="TControl.ControlOrigin" name="TControl.GetControlOrigin">
        <short>Returns the origin (top left pixel) of the control, in screen coordinates.</short>
      </element>
      <element name="TControl.GetControlOrigin.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="TControl.ClientHeight" name="TControl.IsClientHeightStored"/>
      <element name="TControl.IsClientHeightStored.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="TControl.ClientWidth" name="TControl.IsClientWidthStored"/>
      <element name="TControl.IsClientWidthStored.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.WidthIsAnchored">
        <short>True when both the control's left and right side are anchored.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WidthIsAnchored.Result">
        <short>True if the Width varies with the Parent.Width.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.HeightIsAnchored">
        <short>True when both the control's top and bottom side are anchored.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.HeightIsAnchored.Result">
        <short>True if the Height varies with the Parent.Height.</short>
      </element>
      <element name="TControl.WMCancelMode">
        <short>Message handler for
          cancel mode request.
        </short>
      </element>
      <element name="TControl.WMCancelMode.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMContextMenu">
        <short>Message handler for
          context menu popup request.
        </short>
      </element>
      <element name="TControl.WMContextMenu.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonDown">
        <short>Message handler for
          left mouse button going down.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonDown.Message">
        <short/>
      </element>
      <element name="TControl.WMRButtonDown">
        <short>Message handler for
          right mouse button going down.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonDown">
        <short>Message handler for
          middle mouse button going down.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonDBLCLK">
        <short>Message handler for
          left mouse button double click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonDBLCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonDBLCLK">
        <short>Message handler for
          right mouse button double click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonDBLCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonDBLCLK">
        <short>Message handler for
          middle mouse button double click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonDBLCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonTripleCLK">
        <short>Message handler for
          left mouse button triple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonTripleCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonTripleCLK">
        <short>Message handler for
          right mouse button triple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonTripleCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonTripleCLK">
        <short>Message handler for
          middle mouse button triple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonTripleCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonQuadCLK">
        <short>Message handler for
          left mouse button quadruple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonQuadCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonQuadCLK">
        <short>Message handler for
          right mouse button quadruple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonQuadCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonQuadCLK">
        <short>Message handler for
          middle mouse button quadruple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonQuadCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMXButtonDown">
        <short>Message handler for
          extra mouse button going down.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMXButtonDBLCLK">
        <short>Message handler for
          extra mouse button double click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonDBLCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMXButtonTripleCLK">
        <short>Message handler for
          extra mouse button triple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonTripleCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMXButtonQuadCLK">
        <short>Message handler for
          extra mouse button quadruple click.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonQuadCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMXButtonUp">
        <short>Message handler for
          extra mouse button going up.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMouseMove">
        <short>Message handler for
          mouse moved.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMouseMove.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonUp">
        <short>Message handler for
          left mouse button going up.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonUp">
        <short>Message handler for
          right mouse button going up.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonUp">
        <short>Message handler for
          middle mouse button going up.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonUp.Message">
        <short/>
      </element>
      <element name="TControl.WMMouseWheel">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControl.WMMouseWheel.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMove">
        <short>Message handler for
          control moved.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMMove.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMSize">
        <short>Message handler for
          changed control size.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMSize.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMWindowPosChanged">
        <short>Message handler for
          changed control position.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WMWindowPosChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.LMCaptureChanged">
        <short>Message handler for
          changed capture.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.LMCaptureChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.CMBiDiModeChanged">
        <short>Message handler for BiDi mode changed.</short>
      </element>
      <element name="TControl.CMBiDiModeChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMSysFontChanged">
        <short>Message handler for
          changed system Font.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMSysFontChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMEnabledChanged">
        <short>Message handler for
          changed Enabled state.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMEnabledChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMHitTest">
        <short>Message handler for
          hit test.
        </short>
        <descr>The hit test handler determines the specific part of a control (caption, border...) at the given mouse position.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMHitTest.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMMouseEnter">
        <short>Message handler for
          mouse entering the control.
        </short>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMMouseEnter.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMMouseLeave">
        <short>Message handler for
          mouse leaving the control.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMMouseLeave.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMHintShow">
        <short>Message handler for
          hint display.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMHintShow.Message">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.CMParentBiDiModeChanged">
        <short>Message handler for parent control's BiDi mode changed.</short>
      </element>
      <element name="TControl.CMParentBiDiModeChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMParentFontChanged">
        <short>Message handler for
          changed parent Font.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMParentFontChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMParentColorChanged">
        <short>Message handler for
          changed parent Color.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMParentColorChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMParentShowHintChanged">
        <short>Message handler for
          changed parent ShowHint.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMParentShowHintChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMVisibleChanged">
        <short>Message handler for
          changed visibility.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CMVisibleChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMTextChanged">
        <short>Message handler for control's Text changed.</short>
      </element>
      <element name="TControl.CMTextChanged.Message">
        <short/>
      </element>
      <element name="TControl.CMWantSpecialKey">
        <short>Message handler for
          special character (TAB...).
        </short>
      </element>
      <element name="TControl.CMWantSpecialKey.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMCursorChanged">
        <short>Message handler for
          changed cursor.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControl.CMCursorChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CalculateDockSizes">
        <short>Saves the docked and undocked extent of the control.</short>
        <descr>
          <p>In floating state sets UndockWidth/Height to the current Width/Height.</p>
          <p>In docked state sets LRDockWidth/TBDockHeight to the current Width/Height.</p>
          <remark>[Note: should save both in any case, independent from DockOrientation or host Align.
            <br/>Rationale: a DockManager will either ignore these values, or use them according to the *new* alignment.
            <br/>Without a DockManager both extents are required, because no (valid) alignment information applies.]
          </remark>
        </descr>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.CreateFloatingDockSite">
        <short>Create a floating dock site with a client area equal to the given screen coordinates.
        </short>
        <descr>The new dock site is owned by the control
        </descr>
      <notes><note>Delphi: by Application!?</note>
        </notes>
      </element>
      <element name="TControl.CreateFloatingDockSite.Result">
        <short>The dock site, can be Nil for a TWinControl that can float by itself.</short>
      </element>
      <element name="TControl.CreateFloatingDockSite.Bounds">
        <short>The bounds of the client area of the floating window.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDockEdge">
        <short>Determine the side to which the dragged control shall be docked.</short>
      </element>
      <element name="TControl.GetDockEdge.Result">
        <short/>
      </element>
      <element name="TControl.GetDockEdge.MousePos">
        <short>Mouse position in client coordinates.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDragImages">
        <short>Get the list of images usable during dragging.</short>
      </element>
      <element name="TControl.GetDragImages.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetFloating">
        <short>Guess whether the control is floating.</short>
        <descr>Floating state is assumed when the control has a HostDockSite of FloatingDockSiteClass, and is the only docked client.</descr>
      </element>
      <element name="TControl.GetFloating.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetFloatingDockSiteClass">
        <short>Returns the class for a floating host dock site.</short>
        <descr>
          <p>An instance of this class is created whenever a control shall float,
            but can not (or shall not) float by itself.
          </p>
          <p>Only TWinControls can float on the screen (with Parent=Nil), but not ordinary TControls.
          </p>
          <p>Since dockable forms are not supported by every platform,
            also a dockable TWinControl may need an floating host,
            which presents a docking handle to the user (e.g. a dock caption).
          </p>
        </descr>
        <errors/>
        <seealso>
          <link id="TControl.CreateFloatingDockSite"/>
        </seealso>
      </element>
      <element name="TControl.GetFloatingDockSiteClass.Result">
        <short>The class of a floating host dock site for this control.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.BeginAutoDrag">
        <short>For internal use: user has started dragging the control.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoFloatMsg">
        <short>Handler called when the control starts floating.</short>
        <descr>
          <p>Since TControls cannot float for themselves,
            a FloatHost site is created and the control is docked into it.</p>
          <p>When the control already has a Parent (FloatHost site),
            the Parent's position and extent is adjusted to fit the DockRect as its ClientRect.</p>
        </descr>
      </element>
      <element name="TControl.DoFloatMsg.ADockSource">
        <short>The DockObject of the current drag-dock operation.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DockTrackNoTarget">
        <short>Adjust the DockRect for floating state (no drop target under the mouse).</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DockTrackNoTarget.Source">
        <short>The dragged DockObject, containing the DockRect to adjust.</short>
      </element>
      <element name="TControl.DockTrackNoTarget.X">
        <short>The mouse position, in screen coordinates.</short>
      </element>
      <element name="TControl.DockTrackNoTarget.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoDock">
        <short>Internal method, called by Dock. Adjusts the control's position and extent for the new docksite.</short>
        <descr>
          <p>If NewDockSite=Nil, Parent is set to Nil (in preparation of floating the control).
          </p>
          <p>Otherwise ARect is ignored (bug?), and recomputed to fit approximately into the ClientRect of the NewDockSite.
          </p>
          <p>Finally the computed coordinates are stored, in BoundsRectForNewParent when the NewDockSite differs from Parent, else in BoundsRect.
          </p>
        </descr>
        <errors>A correct implementation should allow for computations in a derived class,
          and accept and handle the changed bounds without any further adjustments.
        </errors>
        <seealso/>
      </element>
      <element name="TControl.DoDock.NewDockSite">
        <short>The site where the control will be docked, or Nil when it becomes floating.</short>
      </element>
      <element name="TControl.DoDock.ARect">
        <short>The control's new Bounds, in screen coordinates when NewDockSite is Nil, else in client coordinates of NewDockSite.
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoDragMsg">
        <short>Handler for a drag message, sent by the DragManager to the current target control.</short>
        <descr>
          <p>These messages can be sent while dragging:
          </p>
          <ul>
            <li>On dmFindTarget: Request to determine the possible target control for an drop.
              <br/>A TControl returns itself, a TWinControl finds the child control closest to the mouse position.
            </li>
            <li>On dmDragEnter/Leave/Move: Notification of mouse moves.
              <br/>Invokes DragOver, or DockOver if docking.
              Result indicates acceptance of an drop.</li>
            <li>On dmDragDrop: The dragged object has been dropped onto this control.
              <br/>Invokes DragDrop, or DockDrop if docking.</li>
          </ul>
          <p>The <var>Source</var> argument of the invoked methods is the DragDockObject when docking.
            Else if the DragObject has been AutoCreated, the dragged control is passed as the Source;
            otherwise the DragObject itself is passed as Source.
          </p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoDragMsg.Result">
        <short>Result is polymorphic:
          On dmFindTarget the result is the target control reference,
          on dmDragDrop it's zero,
          else it indicates acceptance of an drop.
        </short>
      </element>
      <element name="TControl.DoDragMsg.ADragMessage">
        <short>The task to perform.</short>
      </element>
      <element name="TControl.DoDragMsg.APosition">
        <short>The mouse position in <b>screen</b> coordinates.</short>
      </element>
      <element name="TControl.DoDragMsg.ADragObject">
        <short>The drag object.</short>
      </element>
      <element name="TControl.DoDragMsg.ATarget">
        <short>The drop target, Nil if none.</short>
      </element>
      <element name="TControl.DoDragMsg.ADocking">
        <short>Distinguishes between a drag-drop and drag-dock operation.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoEndDock">
        <short>Invokes the <link id="#lcl.Controls.TControl.OnEndDock">OnEndDock</link> handler.</short>
      </element>
      <element name="TControl.DoEndDock.Target">
        <short/>
      </element>
      <element name="TControl.DoEndDock.X">
        <short/>
      </element>
      <element name="TControl.DoEndDock.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoEndDrag">
        <short>Invokes the <link id="#lcl.Controls.TControl.OnEndDrag">OnEndDrag</link> handler.</short>
      </element>
      <element name="TControl.DoEndDrag.Target">
        <short/>
      </element>
      <element name="TControl.DoEndDrag.X">
        <short/>
      </element>
      <element name="TControl.DoEndDrag.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoStartDock">
        <short>Invokes the <link id="#lcl.Controls.TControl.OnStartDock">OnStartDock</link> handler</short>
      </element>
      <element name="TControl.DoStartDock.DragObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoStartDrag">
        <short>Invokes the <link id="#lcl.Controls.TControl.OnStartDrag">OnStartDrag</link> handler</short>
      </element>
      <element name="TControl.DoStartDrag.DragObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DragCanceled">
        <short>Notifies the control of a canceld drag.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DragOver">
        <short>Called when an object is dragged over this control.
          Determines whether a drop is acceptable, using the OnDragOver handler.
        </short>
        <descr>
          <p>An OnDragOver handler is required, or any drop will be rejected (Accept becomes False).</p>
          <p>When an OnDragOver handler is installed, Accept is set to True and can be changed by the handler.</p>
          <remark>Caution: Source can be either a TDragObject, or the dragged control.</remark>
        </descr>
        <seealso>
          <link id="TControl.OnDragOver"/>
          <link id="TControl.DockOver"/>
        </seealso>
      </element>
      <element name="TControl.DragOver.Source">
        <short>The dragged object, a control or a DragObject.</short>
      </element>
      <element name="TControl.DragOver.X">
        <short>The mouse position in client coordinates.</short>
      </element>
      <element name="TControl.DragOver.Y">
        <short/>
      </element>
      <element name="TControl.DragOver.State">
        <short>State change flag (dsDragEnter, dsDragMove, dsDragLeave).</short>
      </element>
      <element name="TControl.DragOver.Accept">
        <short>Set to True when a drop is allowed.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.PositionDockRect">
        <short>Get the DockRect for an possible drop.</short>
        <descr>Either calls the DockManager.PositionDockRect of the target site,
          or DragDockObject.AdjustDockRect after moving the undocked control rectangle to the DragPos.
          AdjustDockRect takes the hotspot of the DockRect into account.
        </descr>
        <errors/>
        <seealso>
          <link id="TDragDockObject.AdjustDockRect"/>
        </seealso>
      </element>
      <element name="TControl.PositionDockRect.DragDockObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.DragMode" name="TControl.SetDragMode"/>
      <element name="TControl.SetDragMode.Value">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDefaultDockCaption">
        <short>Returns the string for the dock caption, by default the control's Name.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetDefaultDockCaption.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Click">
        <short>Invokes the
          <link id="#lcl.Controls.TControl.OnClick">OnClick</link>
          and ActionLink.Execute
          handlers.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DblClick">
        <short>Invokes the
          <link id="#lcl.Controls.TControl.OnDblClick">OnDblClick</link>
          handler.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.TripleClick">
        <short>Invokes the
          <link id="#lcl.Controls.TControl.OnTripleClick">OnTripleClick</link>
          handler.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.QuadClick">
        <short>Invokes the
          <link id="#lcl.Controls.TControl.OnQuadClick">OnQuadClick</link>
          handler.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseDown">
        <short>Handler for MouseDown events.</short>
        <descr>
          <p>Called by the MouseDown message handler.
            Handles Focus changes,
            notifies the DragManager while dragging.
            Finally calls the <link id="TControl.OnMouseDown"/> handler.</p>
        </descr>
      </element>
      <element name="TControl.MouseDown.Button">
        <short>which buttons are down</short>
      </element>
      <element name="TControl.MouseDown.Shift">
        <short>which of Ctrl, Shift or Alt keys are also pressed</short>
      </element>
      <element name="TControl.MouseDown.X">
        <short>Mouse position in <b>client</b> coordinates.</short>
      </element>
      <element name="TControl.MouseDown.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseMove">
        <short>Handler for MouseMove events.</short>
        <descr>
          <p>Called by the MouseMove message handler.
            The DragManager is notified while the control is being dragged.
            Finally the <link id="#lcl.Controls.TControl.OnMouseMove">OnMouseMove</link> handler is invoked.</p>
        </descr>
      </element>
      <element name="TControl.MouseMove.Shift">
        <short>The currently pressed mouse buttons and modifier keys.
        </short>
      </element>
      <element name="TControl.MouseMove.X">
        <short>Mouse position in <b>client</b> coordinates.</short>
      </element>
      <element name="TControl.MouseMove.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseUp">
        <short>Invokes the
          <link id="#lcl.Controls.TControl.OnMouseUp">OnMouseUp</link> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.MouseUp.Button">
        <short>The currently pressed modifier keys.
        </short>
      </element>
      <element name="TControl.MouseUp.Shift">
        <short>The currently pressed mouse buttons.
        </short>
      </element>
      <element name="TControl.MouseUp.X">
        <short>Mouse position in <b>client</b> coordinates.</short>
      </element>
      <element name="TControl.MouseUp.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseEnter">
        <short>Invokes the
          <link id="#lcl.Controls.TControl.OnMouseEnter">OnMouseEnter</link> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseLeave">
        <short>Invokes the
          <link id="#lcl.Controls.TControl.OnMouseLeave">OnMouseLeave</link> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.DialogChar">
        <short>Do something useful with accelerators etc.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DialogChar.Result">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControl.DialogChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UpdateMouseCursor">
        <short>Show the Cursor shape, unless it's crDefault.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.UpdateMouseCursor.X">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControl.UpdateMouseCursor.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Changed">
        <short>Call this method whenever a change has occured, to trigger further processing.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetPalette">
        <short>Override
          <var>GetPalette</var> to return the handle of a color palette.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetPalette.Result">
        <short>The Palette handle, zero (no Palette) by default.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.ChildClassAllowed">
        <short>Returns True if the specified class is allowed for children of this control.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.ChildClassAllowed.Result">
        <short>True when the class is acceptable.</short>
      </element>
      <element name="TControl.ChildClassAllowed.ChildClass">
        <short>The class type of the child control.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#rtl.Classes.TComponent.ReadState" name="TControl.ReadState"/>
      <element name="TControl.ReadState.Reader">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#rtl.Classes.TComponent.Loaded" name="TControl.Loaded"/>
      <!-- procedure Visibility: protected -->
      <element name="TControl.LoadedAll">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DefineProperties">
        <short>Defines which non-published properties should be streamed (none here).</short>
        <seealso>
          <link id="#rtl.Classes.TComponent.DefineProperties">TComponent.DefineProperties</link>
          <link id="#rtl.Classes.TPersistent.DefineProperties">TPersistent.DefineProperties</link>
        </seealso>
      </element>
      <element name="TControl.DefineProperties.Filer">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.AssignTo">
        <short>Implements the assignment to an Action object, otherwise calls the inherited method.
        </short>
        <descr>
          <p>The copied properties are:</p>
          <ul>
            <li>Enabled</li>
            <li>Hint</li>
            <li>Caption</li>
            <li>Visible</li>
            <li>OnExecute (copied to OnClick)</li>
            <li>HelpContext</li>
            <li>HelpKeyword</li>
            <li>HelpType</li>
          </ul>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TPersistent.AssignTo"/>
        </seealso>
      </element>
      <element name="TControl.AssignTo.Dest">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.FormEndUpdated">
        <short>Called when the update of the containing Form has ended.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.InvalidateControl">
        <short>Request a repaint of the control.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.InvalidateControl.CtrlIsVisible">
        <short/>
      </element>
      <element name="TControl.InvalidateControl.CtrlIsOpaque">
        <short/>
      </element>
      <element name="TControl.InvalidateControl.IgnoreWinControls">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.FontChanged">
        <short>Handles changes of the Font property.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ParentFontChanged">
        <short>[Delphi compatible] Does nothing here, all work is done in CMParentFontChanged.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element link="TControl.Action" name="TControl.GetAction"/>
      <element name="TControl.GetAction.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.RealGetText">
        <short>Returns the Caption property.</short>
        <descr>This method is called by <var>GetText</var>, when GetTextBuf is not overridden.</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.GetTextBuf">GetTextBuf</link>
          <link id="#lcl.Controls.TControl.RealSetText">RealSetText</link>
          <link id="#lcl.Controls.TControl.SetTextBuf">SetTextBuf</link>
        </seealso>
      </element>
      <element name="TControl.RealGetText.Result">
        <short>The Caption property.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.RealSetText">
        <short>Sets the Caption property.</short>
        <descr>This method is called by <var>SetText</var>, when SetTextBuf is not overridden.</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.SetTextBuf">SetTextBuf</link>
          <link id="#lcl.Controls.TControl.RealGetText">RealGetText</link>
          <link id="#lcl.Controls.TControl.GetTextBuf">GetTextBuf</link>
        </seealso>
      </element>
      <element name="TControl.RealSetText.Value">
        <short>The string to store.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.TextChanged">
        <short>Handles changes of the Text property.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetCachedText">
        <short>Returns the cached Text property (FCaption).</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetCachedText.Result">
        <short>True if successful.</short>
      </element>
      <element name="TControl.GetCachedText.CachedText">
        <short>Here: FCaption (can be overridden).</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.Action" name="TControl.SetAction"/>
      <element name="TControl.SetAction.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.Color" name="TControl.SetColor"/>
      <element name="TControl.SetColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.Enabled" name="TControl.SetEnabled"/>
      <element name="TControl.SetEnabled.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.Hint" name="TControl.SetHint"/>
      <element name="TControl.SetHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.Name" name="TControl.SetName"/>
      <element name="TControl.SetName.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.Parent" name="TControl.SetParent"/>
      <element name="TControl.SetParent.NewParent">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetParentComponent">
        <short>Sets the Parent property, if NewParentComponent is a TWinControl.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetParentComponent.NewParentComponent">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WndProc">
        <short>The general message handler for this control.</short>
        <descr>Preprocesses several messages, then calls Dispatch to invoke the applicable message handler.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.WndProc.TheMessage">
        <short>The message to handle.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ParentFormHandleInitialized">
        <short>Internal handler for activities after a form widget has been created.
        </short>
        <descr>
          <p>Called by <var>ChildHandlesCreated</var> of parent form.
          </p>
          <p>Functions like GetTextWidth require valid widgets and their device contexts.
            That's why AutoSizing is delayed till this moment.
          </p>
        </descr>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CaptureChanged">
        <short>Handler for mouse capture moved to a different control.</short>
        <descr>Notifies the DragManager of the changed capture control, to stop dragging this control.
          A very dangerous implementation, that can cause immediate abort of dragging before dragging really starts.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Notification">
        <short>Notification handler for insertion or deletion of components.</short>
        <descr>
          <p>First the inherited <link id="#rtl.Classes.TComponent.Notification"/> is invoked,
            to notify all attached notification handlers.</p>
          <p>If Operation is removal, additional actions are performed, depending on AComponent:<br/>
            PopupMenu, Action, or anchors to the removed control are detached.</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.Notification"/>
        </seealso>
      </element>
      <element name="TControl.Notification.AComponent">
        <short>The component being inserted or removed.</short>
      </element>
      <element name="TControl.Notification.Operation">
        <short>The action (opInsert or opRemove).</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.CanTab">
        <short>If True, the Tab key can be used to navigate to this control.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.CanTab.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDeviceContext">
        <short>Returns a device context handle for the control, from Parent.
        </short>
        <descr>Initializes the device context position to the control origin,
          and shrinks its clipping rectangle to the control bounds.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetDeviceContext.Result">
        <short>The device context.</short>
      </element>
      <element name="TControl.GetDeviceContext.WindowHandle">
        <short>Returns the window handle of the device context.</short>
      </element>
      <!-- function Visibility: protected -->
      <element link="TControl.Enabled" name="TControl.GetEnabled"/>
      <element name="TControl.GetEnabled.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="TControl.PopupMenu" name="TControl.GetPopupMenu"/>
      <element name="TControl.GetPopupMenu.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoOnShowHint">
        <short>Invokes the <var>OnShowHint</var> event handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoOnShowHint.HintInfo">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoMouseWheel">
        <short>Invokes the OnMouseWheel handlers, when the wheel has been turned.
        </short>
        <descr>
          <p>Multiple wheel handlers can be implemented.
            First the general OnMouseWheel handler is tried, and if it doesn't report the event handled,
            then OnMouseWheelUp or OnMouseWheelDown are tried.
          </p>
          <p>The actual WheelDelta is available <b>only</b> to the OnMouseWheel handler,
            not to the up and down handlers [Delphi compatible].
          </p>
        </descr>
        <seealso>
          <link id="TMouseWheelEvent"/>
          <link id="TMouseWheelUpDownEvent"/>
        </seealso>
      </element>
      <element name="TControl.DoMouseWheel.Result">
        <short>Set Result to True if handled.</short>
      </element>
      <element name="TControl.DoMouseWheel.Shift">
        <short>State of the modifier keys and mouse buttons.</short>
      </element>
      <element name="TControl.DoMouseWheel.WheelDelta">
        <short>How many notches the wheel has been turned.</short>
      </element>
      <element name="TControl.DoMouseWheel.MousePos">
        <short>The mouse coordinates</short>
      <notes><note>client/screen?</note>
        </notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoMouseWheelDown">
        <short>Invokes the OnMouseWheelDown handler.</short>
      </element>
      <element name="TControl.DoMouseWheelDown.Result">
        <short>True if handled.</short>
      </element>
      <element link="TMouseWheelEvent.Shift" name="TControl.DoMouseWheelDown.Shift">
        <short/>
      </element>
      <element link="TMouseWheelEvent.MousePos" name="TControl.DoMouseWheelDown.MousePos">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoMouseWheelUp">
        <short>Invokes the OnMouseWheelUp handler.</short>
      </element>
      <element name="TControl.DoMouseWheelUp.Result">
        <short>True if handled.</short>
      </element>
      <element link="TMouseWheelEvent.Shift" name="TControl.DoMouseWheelUp.Shift">
        <short/>
      </element>
      <element link="TMouseWheelEvent.MousePos" name="TControl.DoMouseWheelUp.MousePos">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.VisibleChanging">
        <short>Notifies all <var>OnVisibleChanging</var> handlers.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.VisibleChanged">
        <short>Notifies all OnVisibleChanged handlers.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.EnabledChanging">
        <short>Notifies all OnEnabledChanging handlers.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.EnabledChanged">
        <short>Notifies all OnEnabledChanged handlers.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.AddHandler">
        <short>Adds an notification handler.</short>
        <descr>Notification handlers allow to notify other components of certain events.
          When the registered event occurs, all installed (added) handlers are invoked.
        </descr>
      </element>
      <element name="TControl.AddHandler.HandlerType">
        <short>Type of the event.</short>
      </element>
      <element name="TControl.AddHandler.AMethod">
        <short>The handler to be added.</short>
      </element>
      <element name="TControl.AddHandler.AsFirst">
        <short>Unused.</short>
      <notes><note>If true, the handler is added before all installed handlers?</note>
        </notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.RemoveHandler">
        <short>Removes the given notification handler.</short>
        <seealso>
          <link id="TControl.AddHandler"/>
        </seealso>
      </element>
      <element name="TControl.RemoveHandler.HandlerType">
        <short>Type of the notification.</short>
      </element>
      <element name="TControl.RemoveHandler.AMethod">
        <short>The handler to be removed.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoCallNotifyHandler">
        <short>Invokes all notification handlers of the specified type.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoCallNotifyHandler.HandlerType">
        <short>The event that has occured.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoContextPopup">
        <short>Invokes the OnContextPopup handler.</short>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.DoContextPopup.MousePos">
        <short>Mouse position, used to place the menu.</short>
      </element>
      <element name="TControl.DoContextPopup.Handled">
        <short>To be set by the handler, when it has handled the menu display and selection.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetZOrder">
        <short>Moves the control in front or back of all sibling controls.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.SetZOrder.TopMost">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetControlClassDefaultSize">
        <short>Returns the default size for this class of controls (when added to a form).</short>
      </element>
      <element name="TControl.GetControlClassDefaultSize.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="TControl.Color" name="TControl.ColorIsStored"/>
      <element name="TControl.ColorIsStored.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetActionLinkClass">
        <short>The default ActionLink class (TControlActionLink).</short>
        <descr>Used when the control is linked to an Action.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetActionLinkClass.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ActionChange">
        <short>Handler for a changed Action.</short>
        <descr>Several properties are copied from the new Action.</descr>
      </element>
      <element name="TControl.ActionChange.Sender">
        <short>The changed Action.</short>
      </element>
      <element name="TControl.ActionChange.CheckDefaults">
        <short>When True, forces update of all properties. Otherwise only properties in default state are overwritten.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.DragDrop">
        <short>Invokes the OnDragDrop handler, when a dragged object is dropped onto this control.</short>
        <seealso>
          <link id="TControl.OnDragDrop"/>
        </seealso>
      </element>
      <element name="TControl.DragDrop.Source">
        <short>The dropped object (control or DragDrop object)</short>
      </element>
      <element name="TControl.DragDrop.X">
        <short>The drop position in client coordinates.</short>
      </element>
      <element name="TControl.DragDrop.Y">
        <short>The drop position in client coordinates.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Dock">
        <short>Moves the control into a new docksite.</short>
        <descr>
          <p>Calls <link id="TControl.DoDock">DoDock</link> to prepare for the new position of the control,
            when docked into an unmanaged or floating docksite.</p>
          <p>When the old and new docksites are different,
            the control is removed from the DockClients of the old docksite, and added to the DockClients of the new docksite;
            afterwards the docksites are notified by calling their DoAddDockClient and DoRemoveDockClient methods, to adjust the control's Parent.</p>
        </descr>
        <errors>An exception is raised if there is already a docking process in progress for this control</errors>
      </element>
      <element name="TControl.Dock.NewDockSite">
        <short>The host site into which which the control is to be docked, Nil for floating.</short>
      </element>
      <element name="TControl.Dock.ARect">
        <short>The control's new Bounds, in screen coordinates when NewDockSite is Nil, else in client coordinates of NewDockSite.
        </short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ManualDock">
        <short>Docks a control programmatically.</short>
        <descr>
          <p>Docks this control into NewDockSite, relative to DropControl.
            When NewDockSite is Nil, the control becomes floating.
          </p>
          <p>When the new docksite uses an DockManager, and DropControl is not Nil,
            the control will be docked relative to DropControl,
            as specified by ControlSide.
          </p>
          <p>The interpretation of ControlSide depends on the DockManager of NewDockSite,
            or on the OnDockDrop handler in an unmanaged  docksite.
          </p>
          <p>A tree docking manager (TDockTree) should interpret alCustom as NoteBook docking,
            i.e. a tabbed notebook is created in place of DropControl,
            and both DropControl and this control are docked into pages of this notebook.
          </p>
        </descr>
      </element>
      <element name="TControl.ManualDock.Result">
        <short>True if successfully docked.</short>
      </element>
      <element name="TControl.ManualDock.NewDockSite">
        <short>The site into which the control is docked; Nil to make it float.</short>
      </element>
      <element name="TControl.ManualDock.DropControl">
        <short>The sibling relative to which the control is inserted; can be Nil.
        </short>
      </element>
      <element name="TControl.ManualDock.ControlSide">
        <short>The side of DropControl on which the control is to be docked.
        </short>
      </element>
      <element name="TControl.ManualDock.KeepDockSiteSize">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ManualFloat">
        <short>Undocks the control into floating state.</short>
        <descr>TWinControls float for themselves,
          for TControls a floating host dock site is created, and the control is docked into it.
        </descr>
      </element>
      <element name="TControl.ManualFloat.Result">
        <short>True if succesfully floated.</short>
      </element>
      <element name="TControl.ManualFloat.TheScreenRect">
        <short>The screen area where the floating control is moved; the client area of a float host site.</short>
      </element>
      <element name="TControl.ManualFloat.KeepDockSiteSize">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ReplaceDockedControl">
        <short>Replaces a previously docked control.</short>
        <descr>
          <p>This method exists for use by an DockManager, for NoteBook docking.
            It should not be used in application code.
          </p>
          <p>Delphi has introduced another method DockReplaceDockClient,
            which is used when the replaced Control is in an unmanaged docksite.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ManualDock"/>
        </seealso>
      </element>
      <element name="TControl.ReplaceDockedControl.Result">
        <short>True if the docked control has been successfully replaced.</short>
      </element>
      <element name="TControl.ReplaceDockedControl.Control">
        <short>The control to be replaced, will be docked into NewDockSite.</short>
      </element>
      <element name="TControl.ReplaceDockedControl.NewDockSite">
        <short>The new dock site for Control, typically a docking Notebook.
        </short>
      </element>
      <element name="TControl.ReplaceDockedControl.DropControl">
        <short>The control to which Control is docked.</short>
      </element>
      <element name="TControl.ReplaceDockedControl.ControlSide">
        <short>The side of DropControl, to which Control is docked.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.Dragging">
        <short>Returns True if the control is being dragged</short>
      </element>
      <element name="TControl.Dragging.Result">
        <short>Returns True if the control is being dragged</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetAccessibleObject">
        <short>Returns True if the control is being dragged</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.CreateAccessibleObject">
        <short>Creates the TLazAccessibleObject for this control. This method should just create the object and return it. It is useful for classes which desire to have a descendent of TLazAccessibleObject instead of the base class.</short>
        <seealso>
          <link id="TLazAccessibleObject"/>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetSelectedChildAccessibleObject">
        <short>Returns the currently selected child accessible object. This method is provided for controls which wish to override this behavior without sub-classing TLazAccessibleObject.</short>
        <seealso>
          <link id="TLazAccessibleObject"/>
          <link id="TLazAccessibleObject.GetSelectedChildAccessibleObject"/>
          <link id="TControl.CreateAccessibleObject"/>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetChildAccessibleObjectAtPos">
        <short>Returns the child object in a given position of the control given in client coordinates. This method is provided for controls which wish to override this behavior without sub-classing TLazAccessibleObject.</short>
        <seealso>
          <link id="TLazAccessibleObject"/>
          <link id="TLazAccessibleObject.GetChildAccessibleObjectAtPos"/>
          <link id="TControl.CreateAccessibleObject"/>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AdjustSize">
        <short>Smart way to <var>DoAutoSize</var>.
        </short>
        <descr>
          <p>This method does the same as Delphi <var>TWinControl.DoAutoSize</var>.
            But since <var>DoAutoSize</var> is commonly overriden by descendant components, it is not useful to perform all tests, which can result in too much overhead.
            To reduce this the LCL calls <var>AdjustSize</var> instead.
          </p>
          <p>During loading and handle creation the calls are delayed.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.AutoSize"/>
        </seealso>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.AutoSizePhases">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControl.AutoSizePhases.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.AutoSizeDelayed">
        <short>Returns true if auto-sizing must be has been delayed, until some other process is complete.</short>
      </element>
      <element name="TControl.AutoSizeDelayed.Result">
        <short>True if auto-sizing has been delayed.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.AutoSizeCheckParent">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControl.AutoSizeCheckParent.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorToNeighbour">
        <short>Anchor to Sibling at Side.
        </short>
        <descr>
          <p>Setup AnchorSide to anchor a side to the side of a neighbour sibling.
            For example Right side to Left side, or Top side to Bottom.</p>
        </descr>
      </element>
      <element name="TControl.AnchorToNeighbour.Side">
        <short>The side to be anchored to Sibling.</short>
      </element>
      <element name="TControl.AnchorToNeighbour.Space">
        <short>The minimum space to Sibling.</short>
      </element>
      <element name="TControl.AnchorToNeighbour.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorParallel">
        <short>Anchor parallel to Sibling, at Side.
        </short>
        <descr/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControl.AnchorParallel.Side">
        <short>The side to anchor to the sibling.</short>
      </element>
      <element name="TControl.AnchorParallel.Space">
        <short>The minimum space to Sibling.</short>
      </element>
      <element name="TControl.AnchorParallel.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorHorizontalCenterTo">
        <short>Setup AnchorSide to center the control horizontally relative to a sibling.
        </short>
      </element>
      <element name="TControl.AnchorHorizontalCenterTo.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorVerticalCenterTo">
        <short>Setup AnchorSide to center the control vertically relative to Sibling.
        </short>
      </element>
      <element name="TControl.AnchorVerticalCenterTo.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorToCompanion">
        <short>Anchor to Sibling at Side, with the same extent.
        </short>
        <descr>Table or tree style anchoring, into a neighbour cell of Sibling.
          Obtain the row height (or column width) from Sibling.
        </descr>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControl.AnchorToCompanion.Side">
        <short>The side to anchor to the sibling.</short>
      </element>
      <element name="TControl.AnchorToCompanion.Space">
        <short>The minimum space to Sibling.</short>
      </element>
      <element name="TControl.AnchorToCompanion.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>
      <element name="TControl.AnchorToCompanion.FreeCompositeSide">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorSame">
        <short>Copy Sibling's anchoring for Side.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AnchorSame.Side">
        <short>The side to anchor like the sibling does.</short>
      </element>
      <element name="TControl.AnchorSame.Sibling">
        <short>The sibling control from which to inherit anchoring.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorAsAlign">
        <short>Anchor to Parent, following same rules as for Align.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AnchorAsAlign.TheAlign">
        <short/>
      </element>
      <element name="TControl.AnchorAsAlign.Space">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorClient">
        <short>Anchor to Parent's full client area.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AnchorClient.Space">
        <short>The around space.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.AnchoredControlCount">
        <short>The number of controls anchored to this one.</short>
      </element>
      <element name="TControl.AnchoredControlCount.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetBounds">
        <short>Sets the bounds (left, top, height, width) of the control.</short>
        <descr>
          <p>SetBounds can be used to change the left, top, width, height all at once, reducing some overhead.
          </p>
          <p>Use DisableAutoSize/EnableAutoSize to reduce recomputing/moving/resizing further.
          </p>
          <p>SetBounds is called when the properties Left, Top, Width, Height, or BoundsRect is set.
          </p>
          <p>SetBounds updates the BaseBounds and BaseParentClientSize, which are used by anchoring to keep the distance.
            For example loading a Form with TMemo and the lfm contains TMemo's Left and Width, then SetBounds is called two times for the memo.
          </p>
          <p>When the user maximizes a window, SetBounds is called for the form, but not for the Memo, keeping the BaseBounds of the Memo.
            If the Memo is anchored to the right, the Width of the Memo is changed based on the BaseBounds and BaseParentClientSize.
          </p>
          <p>Keep in mind that the given aLeft, aTop, aWidth, aHeight might not be valid and will be changed by the LCL before applied.
          </p>
          <p>Delphi calls SetBounds more often. SetBounds calls ChangeBounds with KeepBase=false.
          </p>
        </descr>
      </element>
      <element name="TControl.SetBounds.aLeft">
        <short>The X coordinate of the left side of the control.</short>
      </element>
      <element name="TControl.SetBounds.aTop">
        <short>The Y coordinate of the top of the control</short>
      </element>
      <element name="TControl.SetBounds.aWidth">
        <short>The width of the control.</short>
      </element>
      <element name="TControl.SetBounds.aHeight">
        <short>The height of the control.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetInitialBounds">
        <short>Sets the bounds of the control initially, when it is created.</short>
        <descr>Does nothing while the control is loaded.
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.SetBounds">SetBounds</link>
        </seealso>
      </element>
      <element name="TControl.SetInitialBounds.aLeft">
        <short>X coordinate of top left pixel</short>
      </element>
      <element name="TControl.SetInitialBounds.aTop">
        <short>Y coordinate of top left pixel</short>
      </element>
      <element name="TControl.SetInitialBounds.aWidth">
        <short>Width of control</short>
      </element>
      <element name="TControl.SetInitialBounds.aHeight">
        <short>Height of control</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetBoundsKeepBase">
        <short>Set the bounds, keeping the base values</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControl.SetBoundsKeepBase.aLeft">
        <short/>
      </element>
      <element name="TControl.SetBoundsKeepBase.aTop">
        <short/>
      </element>
      <element name="TControl.SetBoundsKeepBase.aWidth">
        <short/>
      </element>
      <element name="TControl.SetBoundsKeepBase.aHeight">
        <short/>
      </element>
      <element name="TControl.SetBoundsKeepBase.Lock">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.GetPreferredSize">
        <short>Returns default/preferred height and width, for use in autosizing.</short>
        <descr>
          <p>Called during AutoSize calculations. Only positive values are valid. Negative or 0 are treated as undefined and the LCL uses other sizes instead.</p>
          <p>WithThemeSpace: If true, adds space for stacking.</p>
          <p>For example: <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be
            some space around. This space is theme dependent, so the parameter is passed to the widgetset</p>
          <p>
            <var>TWinControl</var> overrides this and asks the interface for theme dependent values. See
            
            
            <link id="TWinControl.CalculatePreferredSize"/> for more information.</p>
        </descr>
      <notes><note>link?</note>
        </notes>
      </element>
      <element name="TControl.GetPreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TControl.GetPreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TControl.GetPreferredSize.Raw">
        <short>If False then the values will be adjusted by the constraints,
          and undefined values will be replaced by GetDefaultWidth/GetDefaultHeight.
        </short>
      </element>
      <element name="TControl.GetPreferredSize.WithThemeSpace">
        <short>If true, adds space for stacking.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetDefaultWidth">
        <short>The default width for this control,
          independent of any calculated values like Width and GetPreferredSize.
        </short>
      </element>
      <element name="TControl.GetDefaultWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetDefaultHeight">
        <short>The default height for this control,
          independent of any calculated values like Height and GetPreferredSize.
        </short>
      </element>
      <element name="TControl.GetDefaultHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetDefaultColor">
        <short>Get the default color for this widget, from Parent or color type.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.ParentColor"/>
          <link id="TControl.GetColorResolvingParent"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
        </seealso>
      </element>
      <element name="TControl.GetDefaultColor.Result">
        <short/>
      </element>
      <element name="TControl.GetDefaultColor.DefaultColorType">
        <short>The color type to use, as the last resort.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetColorResolvingParent">
        <short>Returns the color of the control while resolving clDefault and ParentColor</short>
        <descr>This convenience routine will allow to obtain the Color of the control while resolving clDefault.
          It will never return clDefault, but it might return non-RGB color. To obtain a purely RGB result
          use GetRGBColorResolvingParent.</descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.GetDefaultColor"/>
          <link id="TControl.ParentColor"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetRGBColorResolvingParent">
        <short>Returns a RGB value for the color of the control</short>
        <descr>This convenience routine will allow to obtain the Color of the control while resolving clDefault,
          ParentColor and system color indexes and returns a RGB TColor.</descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.GetDefaultColor"/>
          <link id="TControl.ParentColor"/>
          <link id="TControl.GetColorResolvingParent"/>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetSidePosition">
        <short>The client coordinate of the given side.</short>
      </element>
      <element name="TControl.GetSidePosition.Result">
        <short/>
      </element>
      <element name="TControl.GetSidePosition.Side">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.CNPreferredSizeChanged">
        <short>Message handler for preferred size changed.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.InvalidatePreferredSize">
        <short>Mark the preferred size no longer valid, for this control and all parents (implies that we will look for another).</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetAnchorsDependingOnParent">
        <short>Returns the sides which are anchored to the Parent.</short>
      </element>
      <element name="TControl.GetAnchorsDependingOnParent.Result">
        <short/>
      </element>
      <element name="TControl.GetAnchorsDependingOnParent.WithNormalAnchors">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.DisableAutoSizing">
        <short>Turn off automatic sizing - implies that default is accepted or sizing is done manually</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.EnableAutoSizing">
        <short>Turns on (enables) automatic sizing</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UpdateBaseBounds">
        <short>Update the basic boundaries of the control - essential if there has been a lot of re-sizing.</short>
      </element>
      <element name="TControl.UpdateBaseBounds.StoreBounds">
        <short/>
      </element>
      <element name="TControl.UpdateBaseBounds.StoreParentClientSize">
        <short/>
      </element>
      <element name="TControl.UpdateBaseBounds.UseLoadedValues">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.WriteLayoutDebugReport">
        <short>Used for debugging.</short>
      </element>
      <element name="TControl.WriteLayoutDebugReport.Prefix">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControl.Create"/>
      <element name="TControl.Create.TheOwner">
        <short>The owning component.</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TControl.Destroy">
        <short>Removes the control from its Parent.</short>
        <descr>
          <p>Detaches the control from Parent, removes graphics, frees memory and Operating System handles, pointers etc.</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.Destroy">TComponent.Destroy</link>
          <link id="#LCL.LCLClasses.TLCLComponent.Destroy">TLCLComponent.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.EditingDone">
        <short>Invokes the <var>OnEditingDone</var> event handler.</short>
        <descr>
          <p>Called when user has finished editing. This procedure can be used by data links to commit the changes.</p>
          <p>For example:</p>
          <ul>
            <li>When focus switches to another control (default).</li>
            <li>When user selected another item.</li>
          </ul>
          <p>It's totally up to the control, what events will commit.</p>
        </descr>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ExecuteDefaultAction">
        <short>Called when the RETURN button is pressed, signifying default action.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ExecuteCancelAction">
        <short>Called when ESCAPE is hit or the CANCEL button is clicked - signifying CANCEL.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.BeginDrag">
        <short>Starts dragging the control (programmatically).</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.BeginDrag.Immediate">
        <short>If False, start dragging only after the mouse has moved.</short>
      </element>
      <element name="TControl.BeginDrag.Threshold">
        <short>Minimum mouse movement before delayed dragging starts (in pixels); -1 means DragManager default; ignored if Immediate=True.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.BringToFront">
        <short>Bring the control in front of all sibling controls.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.HasParent">
        <short>Returns True if there is a parent component responsible for streaming</short>
        <descr>
          <p>This function will be called during streaming to decide if a component has to be streamed by its owner or parent</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.HasParent">TComponent.HasParent</link>
        </seealso>
      </element>
      <element name="TControl.HasParent.Result">
        <short>True if there is a Parent.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetParentComponent">
        <short>Returns Parent (implements TComponent.GetParentComponent).</short>
      </element>
      <element name="TControl.GetParentComponent.Result">
        <short>The Parent property.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsParentOf">
        <short>Determines whether this control is a parent of AControl.</short>
        <descr>The recursive search in all Parents of AControl finds not only immediate parent/child controls.
        </descr>
      </element>
      <element name="TControl.IsParentOf.Result">
        <short>True if this control is a parent of AControl.</short>
      </element>
      <element name="TControl.IsParentOf.AControl">
        <short>The control of which this control may be a parent.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetTopParent">
        <short>Find which control is the top parent (which has no further parent itself).</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetTopParent.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsVisible">
        <short>Returns True if the control is visible, including all of its Parents.</short>
        <seealso>
          <link id="TControl.Visible"/>
        </seealso>
      </element>
      <element name="TControl.IsVisible.Result">
        <short>True only if all Parents also are visible.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsControlVisible">
        <short>True if the control is Visible, or is in design mode.</short>
        <descr>
          <p>Does not check for invisible parents.</p>
        </descr>
        <errors/>
        <seealso>
          <link id="TControl.Visible"/>
        </seealso>
      </element>
      <element name="TControl.IsControlVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsEnabled">
        <short>Returns True if the control is Enabled, including all of its Parents.</short>
      </element>
      <element name="TControl.IsEnabled.Result">
        <short>True only if all Parents also are enabled.</short>
      </element>
      <!-- function Visibility: public -->
      <element link="TControl.ParentShowHint" name="TControl.IsParentShowHint">
        <short>Public read access to the protected ParentShowHint property.</short>
      </element>
      <element name="TControl.IsParentShowHint.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.FormIsUpdating">
        <short>True if the form is being updated</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.FormIsUpdating.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsProcessingPaintMsg">
        <short>True while painting the control.</short>
        <descr>As the name says,
          the cfProcessingWMPaint flag in FControlFlags is set while a LM_PAINT message is processed,
          and IsProcessingPaintMsg checks this flag.
        </descr>
      </element>
      <element name="TControl.IsProcessingPaintMsg.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Hide">
        <short>Hides this control, by setting Visible to False.</short>
        <seealso>
          <link id="#lcl.Controls.TControl.Visible"/>
          <link id="#lcl.Controls.TControl.Show"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element link="TControl.Repaint" name="TControl.Refresh"/>
      <!-- procedure Visibility: public -->
      <element name="TControl.Repaint">
        <short>Immediate redraw of the control, bypassing the message queue.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Invalidate">
        <short>Force a delayed Repaint of the control, by marking its visible area of the control as invalid.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.CheckChildClassAllowed">
        <short>Returns True if the class is allowed for child controls.</short>
        <descr>Only few controls restrict the class of acceptable child controls.
          E.g. a PageControl only accepts TTabSheet descendants as children.
        </descr>
        <errors>An EInvalidOperation can be generated (see ExceptionOnInvalid).
        </errors>
      </element>
      <element name="TControl.CheckChildClassAllowed.Result">
        <short>True if the class is allowed for child controls.</short>
      </element>
      <element name="TControl.CheckChildClassAllowed.ChildClass">
        <short>The class of the intended child control.</short>
      </element>
      <element name="TControl.CheckChildClassAllowed.ExceptionOnInvalid">
        <short>When True, raise an exception when the class is not allowed.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.CheckNewParent">
        <short>Checks if this control can become a child of AParent.</short>
        <descr>This check is performed during SetParent.
          It calls CheckChildClassAllowed and whether AParent=Self.
        </descr>
        <errors>An EInvalidOperation occurs when any test fails.
        </errors>
      </element>
      <element name="TControl.CheckNewParent.AParent">
        <short>The new Parent for this control.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SendToBack">
        <short>Moves all sibling controls in front of this control.
        </short>
        <descr>
          <p>Use SendToBack to supply an specific background (image) for the Parent control.
          </p>
          <p>Only those portions of the control will be visible,
            which are not covered by other controls.
          </p>
        </descr>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetTempCursor">
        <short>Change the cursor shape temporarily,
          preserving the stored <link id="TControl.Cursor"/>.
        </short>
      </element>
      <element name="TControl.SetTempCursor.Value">
        <short>The temporary cursor shape to use.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.UpdateRolesForForm">
        <short>Internal method, called by a Form when its DefaultControl or CancelControl has changed.
        </short>
        <descr>This method is overridden in TCustomButton,
          where it updates the button's Cancel and Default properties.
        </descr>
        <seealso>
          <link id="TControl.ActiveDefaultControlChanged"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ActiveDefaultControlChanged">
        <short>Notification of a changed
          active DefaultControl of a form.</short>
        <descr>When the user pressed ENTER in a form, its DefaultControl will receive a Click event.
        </descr>
        <errors>Currently NewControl can be Nil, even if it should not be.
        </errors>
      </element>
      <element name="TControl.ActiveDefaultControlChanged.NewControl">
        <short>The new DefaultControl.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetTextBuf">
        <short>Copy the <link id="TControl.Text">Text</link> property into Buffer.</short>
        <descr>
          <p>This method only exists for Delphi compatibility.
          </p>
          <p>Don't use or override it, unless really necessary.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.RealGetText">RealGetText</link>
        </seealso>
      </element>
      <element name="TControl.GetTextBuf.Result">
        <short>Length of the copied text.</short>
      </element>
      <element name="TControl.GetTextBuf.Buffer">
        <short>Pointer to the buffer receiving the string.</short>
      </element>
      <element name="TControl.GetTextBuf.BufSize">
        <short>Length of the buffer.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetTextLen">
        <short>The length of Text, here: of Caption.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.GetTextLen.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetTextBuf">
        <short>Updates the <link id="TControl.Text">Text</link> property from a PChar buffer.</short>
        <descr>
          <p>This method only exists for Delphi compatibility.
          </p>
          <p>Don't use or override it, unless really necessary.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.RealSetText">RealSetText</link>
        </seealso>
      </element>
      <element name="TControl.SetTextBuf.Buffer">
        <short>Pointer to the buffer containing the zero-terminated text.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.Perform">
        <short>Direct call of an message handler, bypassing the message queue.</short>
        <descr>The parameters and result depend on the concret message.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.Perform.Result">
        <short/>
      </element>
      <element name="TControl.Perform.Msg">
        <short/>
      </element>
      <element name="TControl.Perform.WParam">
        <short/>
      </element>
      <element name="TControl.Perform.LParam">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ScreenToClient">
        <short>Convert absolute screen coordinates into client-relative coordinates</short>
        <seealso>
          <link id="TControl.ClientToScreen"/>
        </seealso>
      </element>
      <element name="TControl.ScreenToClient.Result">
        <short/>
      </element>
      <element name="TControl.ScreenToClient.APoint">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ClientToScreen">
        <short>Convert client-relative coordinates into absolute screen coordinates.</short>
        <seealso>
          <link id="TControl.ScreenToClient"/>
        </seealso>
      </element>
      <element name="TControl.ClientToScreen.Result">
        <short/>
      </element>
      <element name="TControl.ClientToScreen.APoint">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ScreenToControl">
        <short>Convert absolute screen coordinates into control-relative coordinates.</short>
        <seealso>
          <link id="TControl.ControlToScreen"/>
          <link id="TControl.ScreenToClient"/>
          <link id="TControl.ClientToScreen"/>
        </seealso>
      </element>
      <element name="TControl.ScreenToControl.Result">
        <short/>
      </element>
      <element name="TControl.ScreenToControl.APoint">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ControlToScreen">
        <short>Convert control-relative coordinates into absolute screen coordinates.</short>
        <seealso>
          <link id="TControl.ScreenToControl"/>
          <link id="TControl.ScreenToClient"/>
          <link id="TControl.ClientToScreen"/>
        </seealso>
      </element>
      <element name="TControl.ControlToScreen.Result">
        <short/>
      </element>
      <element name="TControl.ControlToScreen.APoint">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetChildsRect">
        <short>Get the visible part of a possibly scrolled client area.</short>
        <descr>If <var>Scrolled</var> is False, the ScrollOffset is ignored,
          so that the ClientRect is returned.
        </descr>
      </element>
      <element name="TControl.GetChildsRect.Result">
        <short>The visible part of the client area.</short>
      </element>
      <element name="TControl.GetChildsRect.Scrolled">
        <short>True forces scrolling taken into account.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Show">
        <short>Makes the control visible, by setting Visible to True.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TControl.ShowControl"/>
          <link id="TControl.Visible"/>
          <link id="TControl.Hide"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Update">
        <short>Redraw invalidated parts of the control immediately.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.HandleObjectShouldBeVisible">
        <short>True if the control shall be visible, unless it's being destroyed.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TControl.IsVisible"/>
        </seealso>
      </element>
      <element name="TControl.HandleObjectShouldBeVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ParentDestroyingHandle">
        <short>Returns True if any parent is destroying its Handle (and its childrens').</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.ParentDestroyingHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ParentHandlesAllocated">
        <short>Returns True if all Parents have handles allocated, and are not being destroyed.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.ParentHandlesAllocated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.InitiateAction">
        <short>Update the action associated with this control.</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ShowHelp">
        <short>Show the Help associated with this control.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.HasHelp">
        <short>True when a HelpKeyword or HelpContext ID is assigned.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.HasHelp.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.LCLClasses.TLCLComponent.RemoveAllHandlersOfObject" name="TControl.RemoveAllHandlersOfObject"/>
      <element name="TControl.RemoveAllHandlersOfObject.AnObject">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnResize">
        <short>Adds an handler for the <var>OnResize</var> event.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnResize.OnResizeEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnResize.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnResize">
        <short>Removes an handler for the <var>OnResize</var> event.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnResize.OnResizeEvent">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnChangeBounds">
        <short>Adds an handler for the <var>OnChangeBounds</var> event.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnChangeBounds.OnChangeBoundsEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnChangeBounds.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnChangeBounds">
        <short>Removes an handler for the <var>OnChangeBounds</var> event.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnChangeBounds.OnChangeBoundsEvent">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnVisibleChanging">
        <short>Adds an <var>OnVisibleChanging</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanging.OnVisibleChangingEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanging.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnVisibleChanging">
        <short>Removes an <var>OnVisibleChanging</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnVisibleChanging.OnVisibleChangingEvent">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnVisibleChanged">
        <short>Adds an
          <var>OnVisibleChanged</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanged.OnVisibleChangedEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanged.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnVisibleChanged">
        <short>Removes an <var>OnVisibleChanged</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnVisibleChanged.OnVisibleChangedEvent">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnEnabledChanged">
        <short>Adds an
          <var>OnEnabledChanged</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnEnabledChanged.OnEnabledChangedEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnEnabledChanged.AsFirst">
        <short/>
      </element>
      <!-- missing RemoveHandlerOnEnableChanging -->
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnEnableChanging">
        <short>Removes an <var>OnEnabledChanged</var> handler.</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>The name doesn't look correct, should read RemoveHandlerOnEnabledChanged?</note>
        </notes>
      </element>
      <element name="TControl.RemoveHandlerOnEnableChanging.OnEnableChangingEvent">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnKeyDown">
        <short>Adds an handler for the <var>OnKeyDown</var> event.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnKeyDown.OnKeyDownEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnKeyDown.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnKeyDown">
        <short>Removes an handler for the <var>OnKeyDown</var> event.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnKeyDown.OnKeyDownEvent">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.UseRightToLeftAlignment">
        <short>True when BiDiMode is bdRightToLeft.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftAlignment.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.UseRightToLeftReading">
        <short>True when BiDiMode is not bdLeftToRight.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftReading.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.UseRightToLeftScrollBar">
        <short>True when scrollbars appear at the left side of the control.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftScrollBar.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsRightToLeft">
        <short>True when BiDiMode is not bdLeftToRight.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControl.IsRightToLeft.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Action">
        <short>The Action associated with this control.</short>
        <descr>The Action property is a shortcut to ActionLink.Action.
        </descr>
        <seealso>
          <link id="TControl.ActionLink"/>
          <link id="#rtl.Classes.TBasicAction"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.AccessibleDescription">
        <short>The accessible description of the control.This should describe the role of the control, for example for TLabel it could be "a text caption".</short>
        <descr>The accessible description of the control. This should describe the role of the control, for example for TLabel it could be "a text caption". This property is connected and synchronized with TControl.GetAccessibleObject().AccessibleDescription.</descr>
        <seealso>
          <link id="TLazAccessibleObject.AccessibleDescription"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.AccessibleValue">
        <short>The accessible value of the control. For example, for a TLabel it would be the same as the Caption property of the label.</short>
        <descr>The accessible value of the control. For example, for a TLabel it would be the same as the Caption property of the label. This property is connected and synchronized with TControl.GetAccessibleObject().AccessibleValue.</descr>
        <seealso>
          <link id="TLazAccessibleObject.AccessibleValue"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.AccessibleRole">
        <short>The accessible role of the control which classifies what kind of object this is. See TLazAccessibleRole for a list of possible values</short>
        <seealso>
          <link id="TLazAccessibleRole"/>
          <link id="TLazAccessibleObject.AccessibleRole"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ActionLink">
        <short>Link to the default Action associated with this control.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Align">
        <short>Specifies the placement of the control inside its Parent.</short>
        <descr>
          <p>A control can stick to one side of its Parent control.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TAlign">TAlign</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.AnchoredControls">
        <short>The list of controls anchored to this one.</short>
      </element>
      <element name="TControl.AnchoredControls.Index">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Anchors">
        <short>The set of anchor definitions for this control.</short>
        <descr>
          <p>Determines which sides of the control are anchored to other controls.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TAnchors"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.AnchorSide">
        <short>Array of anchor definitions, indexed by the control sides.</short>
        <descr>
          <p>Valid anchor definitions are flagged in <link id="TControl.Anchors">Anchors</link>.
          </p>
          <p>AnchorSide specifies how a side is anchored to other controls (siblings or Parent).
          </p>
          <p>Various AnchorAs and AnchorTo methods simplify the establishment of anchors.
          </p>
        </descr>
        <seealso>
          <link id="TAnchorSide"/>
          <link id="TControl.AnchorAsAlign"/>
          <link id="TControl.AnchorToNeighbour"/>
        </seealso>
      <notes><note>Anchors may be invalidated by cycle and other checks?</note>
        </notes>
      </element>
      <element name="TControl.AnchorSide.Kind">
        <short>The anchored side of the control.</short>
      <notes><note>possibly?</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element link="TControl.AnchorSide" name="TControl.AnchorSideBottom"/>
      <element link="TControl.AnchorSide" name="TControl.AnchorSideLeft"/>
      <element link="TControl.AnchorSide" name="TControl.AnchorSideRight"/>
      <element link="TControl.AnchorSide" name="TControl.AnchorSideTop"/>
      <!-- property Visibility: protected -->
      <element name="TControl.AutoSize">
        <short>Allows to automatically adjust the size of the control, according to its content.</short>
        <descr>
          <p>The effect depends on the concrete control type.
            For example a label or button can become bigger or smaller to accommodate a longer or shorter caption.
          </p>
          <p>Default is false, ie no auto-sizing
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.Autosize">Autosize topic</link>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.AutoSizing">
        <short>True while autosizing is in progress.</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.AutoSizingAll">
        <short>Flag to prevent recursive AutoSizing (in DoAllAutoSize).</short>
        <descr>By default Parent.AutoSizingAll is read, because a mere TControl cannot have child controls.
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.AutoSizingLockCount">
        <short>Internal counter, in/decreased by DisableAutoSizing/EnableAutoSizing.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BaseBounds">
        <short>The rectangle of the designed bounds.</short>
        <descr>The current Bounds can change, due to scaling, anchoring or autosizing.
        </descr>
        <seealso>
          <link id="TControl.Anchors"/>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AutoSize"/>
          <link id="TControl.Scale"/>
          <link id="TControl.SetBoundsKeepBase"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BaseParentClientSize">
        <short>The Parent's client size, for which the BaseBounds are valid.</short>
        <descr>
          <p>BaseBounds and BaseParentClientSize determine the distance to keep from Parent's sides,
            when a side is anchored to the Parent (akLeft...), and the Parent is resized.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.BiDiMode">
        <short>Customization (of text controls) in bidirectional reading environments.
        </short>
        <descr>
          <p>In "normal" reading mode (left-to-right, LTR) text entry starts at the left,
            text is almost left justified,
            and vertical scrollbars sit at the right side of the control.
          </p>
          <p>In right-to-left mode text entry starts at the right,
            text is almost right justified,
            and vertical scrollbars sit at the left side of the control.
          </p>
          <p>In a bidirectional environment these different placements and adjustments can be configured (swapped) in various (but not all) ways.
          </p>
          <p>(Allows RTL languages such as Arabic and Hebrew to be used)
          </p>
          <p>Wild guess: The default mode is established by the platform,
            RTL reading is not supported on all (Windows) platforms.
          </p>
        </descr>
        <seealso>
          <link id="TControl.UseRightToLeftAlignment"/>
          <link id="TControl.UseRightToLeftReading"/>
          <link id="TControl.UseRightToLeftScrollBar"/>
          <link id="TControl.IsRightToLeft"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BorderSpacing">
        <short>Determines the inner and outer border spacing for this control.</short>
        <descr>
          <p>The outer border determines the minimal distance to sibling controls,
            the inner border is the area between the control's BoundsRect and ClientRect.
          </p>
          <p>When a control sits in a cell of a table (Grid) control,
            its horizontal and vertical alignment inside the cell can be specified, too.
          </p>
        </descr>
      <notes><note>?</note><note>instead?</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BoundsRect">
        <short>The TopLeft and BottomRight of the control, in client coordinates.</short>
        <descr>
          <p>The BoundsRect rectangle describes the TopLeft and BottomRight coordinates of the control, relative to its parent.
          </p>
          <p>The values are based on the Top, Left, Width and Height properties of the control.
          </p>
          <p>Set BoundsRect to move and/or resize the control.
            This can reduce flicker, occuring otherwise when Top, Width etc. are set individually.
          </p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BoundsRectForNewParent">
        <short>Temporary BoundsRect, used when the control e.g. is docked into a different Parent.</short>
        <descr>
          <p>The rectangle describes the placement of the control when its Parent is changed later.</p>
          <p>Setting the rectangle also sets a flag, indicating that the values are available.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Caption">
        <short>The text describing the control to the user.</short>
        <descr>
          <p>By default, the <var>Caption</var> is the same as the control's <var>Name</var> in the Object Inspector,
            and the developer must set it explicitly to some different text.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.RealGetText"/>
          <link id="#lcl.Controls.TControl.RealSetText"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.CaptureMouseButtons">
        <short>Which mouse button(s) to be used for capture? Default is the left button.
        </short>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientHeight">
        <short>The height of the client area of the control.</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientOrigin">
        <short>Screen coordinates of the TopLeft pixel (of the client area) of the control.</short>
        <descr>
          <p>Only TWinControls have a client area, for other controls ClientOrigin is the same as Origin.</p>
          <p>Note that this value is the position as stored in the object, not always in sync with the widget.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientRect">
        <short>Size of the client area of the control.</short>
        <descr>The origin is always (0,0). Bottom and Right reflect the ClientWidth and ClientHeight of the control.</descr>
        <seealso>
          <link id="#rtl.Classes.TRect"/>
          <link id="TControl.GetLogicalClientRect"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientWidth">
        <short>The width of the client area of the control.</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Color">
        <short>The background color of the control.</short>
        <descr>
          <p>The default Color is the same as the parent window Color. If the color is clDefault
            then the result will need to be passed through GetDefaultColor to resolve clDefault.
            Convenience routines which obtains the color resolving clDefault and ParentColor are also
            provided as TControl.GetColorResolvingParent and TControl.GetRGBColorResolvingParent</p>
        </descr>
        <seealso>
          <link id="TControl.ParentColor"/>
          <link id="#lcl.Graphics.TColor"/>
          <link id="TControl.GetDefaultColor"/>
          <link id="TControl.GetColorResolvingParent"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Constraints">
        <short>The minimal and maximal Width and Height of this control.</short>
        <descr/>
        <seealso>
          <link id="#lcl.Controls.TSizeConstraints"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ControlOrigin">
        <short>The top left pixel of this control, in screen coordinates.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientOrigin"/>
          <link id="TControl.BoundsRect"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ControlState">
        <short>State flags, telling whether the control has been clicked, data being read, control being re-drawn, etc.</short>
        <descr/>
        <seealso>
          <link id="#lcl.Controls.TControlState"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ControlStyle">
        <short>Style flags, specifying whether the control responds to mouse clicks, can be re-sized, has particular actions, etc.</short>
        <descr/>
        <seealso>
          <link id="#lcl.Controls.TControlStyle"/>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Cursor">
        <short>The shape of the mouse pointer, when the mouse is over this control.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.DesktopFont">
        <short>Allows to use the desktop font for text display in this control.</short>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.DockOrientation">
        <short>How the control is currently docked.
           (horizontally, vertically, in a notebook, or not at all)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.DragCursor">
        <short>The cursor shape shown while the control is dragged.</short>
        <descr>Default is crDrag. When no drop is allowed, the cursor changes temporarily to crNoDrop.</descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.DragKind">
        <short>The operation when the control is dragged - Drag or Dock.</short>
        <descr>Set to dkDrag for drag-drop, or to dkDock for drag-dock operation.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.DragMode">
        <short>Allows the user to drag the control.</short>
        <descr>
          <p>Default is dmManual, meaning that dragging must be started in code.</p>
          <p>Set to dmAutomatic to allow the user to drag this control.
            In this mode dragging can start immediately (on left mouse button press)
            or delayed, after the mouse has been moved away by a number of pixels (Threshold).</p>
        </descr>
        <seealso>
          <link id="TControl.DragKind"/>
          <link id="TDragManager.DragImmediate"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Enabled">
        <short>Determines whether the control reacts on mouse or keyboard input.</short>
        <descr>Disabled controls usually appear 'greyed-out'</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Floating">
        <short>Tries to find out whether the control is floating (not part of a form).</short>
        <descr/>
        <seealso>
          <link id="TControl.FloatingDockSiteClass"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.FloatingDockSiteClass">
        <short>The class for a floating host dock site for this control.</short>
        <descr/>
        <seealso>
          <link id="TControl.Floating"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Font">
        <short>The <link id="#lcl.Graphics.TFont">font</link> to be used for text display in this control.</short>
        <seealso>
          <link id="#lcl.Graphics.TFont"/>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Height">
        <short>The vertical size of the control.</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.HelpContext">
        <short>The ID for context-sensitive Help on this control.</short>
        <descr/>
        <seealso>
          <link id="TControl.HelpKeyword"/>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.HelpKeyword">
        <short>The keyword for context-sensitive Help on this control.</short>
        <descr/>
        <seealso>
          <link id="TControl.HelpContext"/>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.HelpType">
        <short>Determines whether context-sensitive Help is selected by numeric ID or keyword.</short>
        <descr/>
        <seealso>
          <link id="TControl.HelpContext"/>
          <link id="TControl.HelpKeyword"/>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Hint">
        <short>The text to show in the Hint window for this control.</short>
        <descr/>
        <seealso>
          <link id="TControl.ShowHint"/>
          <link id="TControl.ParentShowHint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.HostDockSite">
        <short>The host site (TWinControl) into which this control is docked. Nil if not docked.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.IsControl">
        <short>Determines whether this object shall be streamed as a control.</short>
        <descr>Delphi compatible property, affecting only the streaming of <var>Form</var> properties.
        </descr>
      <notes><note>Has no effect in the LCL?</note>
        </notes>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Left">
        <short>The client coordinate of the left edge of the control.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.LRDockWidth">
        <short>The Width when last docked, with siblings to the left or right.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.MouseCapture">
        <short>True when mouse messages are currently captured by this control.</short>
        <descr>
          <p>In normal operation all mouse messages are sent to the control under the mouse pointer.
            Mouse messages also can be sent to a capturing control,
            e.g. when a control is dragged.
          </p>
          <p>Applications should capture mouse events only for special purposes,
            and release the capture as soon as a the target position has been determined.
            Limited user feedback is possible while the mouse is captured,
            not all application controls will work properly so long.</p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.MouseEntered">
        <short>True when the mouse has entered the control.</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnChangeBounds">
        <short>Event handler for a change of the Bounds of the control.</short>
        <descr/>
        <seealso>
          <link id="#rtl.Classes.TNotifyEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnClick">
        <short>Notification handler for mouse clicks.</short>
        <descr>
          <p>A mouse click is associated with the default action for controls, and is often the ONLY event handled in user code.
          </p>
          <p>The reaction on an click can be specified by a user supplied method,
            and/or by selecting an action from a supplied <var>ActionList</var>
          </p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TNotifyEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnConstrainedResize">
        <short>This handler can supply specific Constraints (size limits), when the control is resized.</short>
        <descr/>
        <seealso>
          <link id="TConstrainedResizeEvent"/>
          <link id="TControl.Constraints"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnContextPopup">
        <short>Invoked when a context-sensitive pop-up menu is requested.</short>
        <descr>The handler can show and handle the menu selection itself.
          If so, it should set Handled to True.
          Otherwise the installed PopupMenu is shown.
        </descr>
        <seealso>
          <link id="TContextPopupEvent"/>
          <link id="TControl.PopupMenu"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnDblClick">
        <short>Event Handler for double mouse clicks.</short>
        <descr>
          <p>Double-clicking is much more common in a Windows environment than in Unix or Linux,
            where single-clicking is the default method for selecting an object.
            However, in all environments there could be valid use for a double-click,
            and a method should be supplied if appropriate.
          </p>
        </descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnDragDrop">
        <short>This handler determines the action on an drop onto this control, in a drag-drop operation.
        </short>
        <descr>
          <p>Unlike for a drag-dock operation,
            no default action is associated with an drag-drop;
            the OnDragDrop handler is the only way to do something meaningful on an drag-drop.
          </p>
        </descr>
        <seealso>
          <link id="TControl.TDragDropEvent"/>
          <link id="TControl.DragDrop"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnDragOver">
        <short>Event handler for a control being dragged over this control.</short>
        <descr>The handler can reject an drop, by setting Accept to False.
        </descr>
        <seealso>
          <link id="TDragOverEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnEditingDone">
        <short>Event handler when editing is done.</short>
        <descr>The user definitely has finished editing,
          the resulting text e.g. can be validated.
        </descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnEndDock">
        <short>Notification handler for the end of a docking operation.</short>
        <descr/>
        <seealso>
          <link id="TEndDragEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnEndDrag">
        <short>Notification handler for the end of a dragging operation.</short>
        <descr/>
        <seealso>
          <link id="TEndDragEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseDown">
        <short>Event handler for mouse button going down.</short>
        <seealso>
          <link id="TControl.OnClick"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseEnter">
        <short>Event handler for mouse entering the area of the control.</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseLeave">
        <short>Event handler for mouse leaving the area of the control.</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseMove">
        <short>Event handler for mouse movement within the control.</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseUp">
        <short>Event handler for mouse button going up.</short>
        <seealso>
          <link id="TControl.OnClick"/>
        </seealso>
      </element>
      <element name="TControl.OnMouseWheel">
        <short>Event handler for mouse wheel turned.</short>
        <descr>
          <p>By default all mouse wheel actions are translated into scroll events.
            Write an OnMouseWheel handler to react on turns of the mouse wheel.
          </p>
          <p>The OnMouseWheelUp and OnMouseWheelDown handlers are notified only,
            they are not suited for customization of mouse wheel events.
          </p>
        </descr>
        <seealso>
          <link id="TMouseWheelEvent"/>
        </seealso>
      </element>
      <element name="TControl.OnMouseWheelDown">
        <short>Notification handler for downward movement of mouse wheel.</short>
        <seealso>
          <link id="TControl.OnMouseWheel"/>
          <link id="TMouseWheelUpDownEvent"/>
        </seealso>
      </element>
      <element name="TControl.OnMouseWheelUp">
        <short>Notification handler for upward movement of mouse wheel.</short>
        <seealso>
          <link id="TControl.OnMouseWheel"/>
          <link id="TMouseWheelUpDownEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnQuadClick">
        <short>Event handler for quadruple mouse clicks.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnResize">
        <short>Notification handler for a resize of the control.</short>
        <descr>
          <p>This event is triggered after the Width, Height, ClientWidth or ClientHeight of the control has changed.
            During autosize the size can change multiple times, but only the last change triggers the OnResize.
          </p>
          <p>Use OnResize to react on size changes.
            To also react on moves, use the OnChangeBounds event.
          </p>
          <p>If you want to customize the resize behaviour, use OnConstrainedResize instead.
          </p>
          <p>Common mistake:
            Keep in mind that ClientWidth and ClientHeight can change even when Width, Height stays the same.
            For example when the theme changes, the Width and Height remain the same, but the changed frame reduces the ClientWidth and ClientHeight.
            This does not happen that often under Windows, but it happens quite often on other platforms.
          </p>
          <p>Especially it is not sufficient to write only a TForm.OnResize handler to resize all controls on the form. This is a common bug in Delphi applications.
          </p>
        </descr>
        <seealso>
          <link id="TControl.OnConstrainedResize"/>
          <link id="#rtl.Classes.TNotifyEvent"/>
        </seealso>
      <notes><note>???</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnShowHint">
        <short>Event Handler when a hint shall be shown.</short>
        <descr/>
        <seealso>
          <link id="TControl.Hint"/>
          <link id="#lcl.Controls.THintInfo"/>
          <link id="#lcl.Controls.TControlShowHintEvent"/>
        </seealso>
      <notes><note>Tasks, Usage?</note>
        </notes>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnStartDock">
        <short>Event handler for the start of a docking operation.</short>
        <descr>
          <p>The handler can provide a special DragDock object, otherwise a default object is created.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TDragDockObject"/>
          <link id="TControl.OnStartDrag"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnStartDrag">
        <short>Event handler for the start of a dragging operation.</short>
        <descr>
          <p>The handler can provide a special DragControl object, otherwise a default object is created.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TDragObject"/>
          <link id="TControl.OnStartDock"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnTripleClick">
        <short>Event handler for triple mouse clicks.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Parent">
        <short>The control within which the control is shown.</short>
        <descr>
          <p>When the Parent moves or hides, all its children move or hide together with it.
</p>
          <p>Every TControl must have a Parent, else it is never shown.
</p>
          <p>The Parent of a floating form is Nil.
</p>
          <p>Set the parent last to reduce updates. For example:
Button1:=TButton.Create(Self);
Button1.Name:='Button1';
Button1.Caption:='Click me'; // parent is not set, so it does not update the whole form
Button1.Parent:=Form1; // set parent as last, the LCL now applies all properties
</p>
          <p>Delphi/VCL: Parent must be set first under Delphi, because many properties work differently if they are set before or after Handle creation. The LCL applies the properties when the Handle is created.
</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ParentBiDiMode">
        <short>Allows to use the BiDiMode settings of Parent. Default is true.</short>
        <seealso>
          <link id="TControl.BiDiMode"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ParentColor">
        <short>If true, the Color of the control will be the same as the one from the Parent. Default is true.</short>
        <descr>While this property is True, all changes to the Color of the parent will be 
          also done to the Color of the control, syncronizing them and keeping them with the same value. 
          If the Color of the control is changed by the application, then ParentColor will be automatically set to False.
          The combination of ParentColor with clDefault can cause problems in resolving clDefault. To obtain the Color
          property of a control while taking into account clDefault and ParentColor one whould use TControl.GetColorResolvingParent.
          This method might return a non-RGB color, but will never return clDefault. To obtain a purely RGB result use
          TColor.GetRGBColorResolvingParent
        </descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.GetColorResolvingParent"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ParentFont">
        <short>If true, the Font of the control will be the same as the one from the Parent. Default is true.</short>
        <descr>While this property is True, all changes to the font of the parent will be 
          also done to the font of the control, syncronizing them and keeping them with the same value. 
          If the Font of the control is changed by the application, then ParentFont will be automatically set to False.
        </descr>
        <seealso>
          <link id="TControl.Font"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ParentShowHint">
        <short>If true, the value of ShowHint for the control will be the same as the one from the Parent. Default is true.</short>
        <descr>While this property is True, all changes to the ShowHint property of the parent will be 
          also done to the ShowHint property of the control, syncronizing them and keeping them with the same value. 
          If the ShowHint property of the control is changed by the application, then ParentShowHint will be automatically set to False.
        </descr>
        <seealso>
          <link id="TControl.Hint"/>
          <link id="TControl.ShowHint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.PopupMenu">
        <short>A context-sensitive menu that pops up when the right mouse button is clicked over this control</short>
        <descr/>
        <seealso>
          <link id="#lcl.Menus.TPopupMenu"/>
          <link id="TControl.OnContextPopup"/>
          <link id="TControl.TContextPopupEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ReadBounds">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.SessionProperties">
        <short>The stored (saved) properties of the current session, expressed as a string</short>
        <descr/>
        <seealso/>
      <notes><note>What's 'session'?</note><note>Usage?</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ShowHint">
        <short>Enables the <link id="#lcl.Controls.TControl.Hint">Hint</link> display.</short>
        <descr>
          <p>When True, the Hint text is shown when the mouse hovers over the control.
          </p>
          <p>Display of the actual hint is controlled by OnShowHint.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Hint">Hint</link>
          <link id="#lcl.Controls.TControl.OnShowHint">OnShowHint</link>
          <link id="TControl.ParentShowHint">ParentShowHint</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.TBDockHeight">
        <short>The Height when last docked, with siblings above or below.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.Text">
        <short>The character string associated with the control.</short>
        <descr>
          <p>This is the character string, shown in controls with visible text content (<link id="#lcl.StdCtrls.TEdit">TEdit</link>...).</p>
          <remark>BEWARE: In other controls it can be the Name or Caption of the control, quite tricky to use.</remark>
          <p>The Delphi VCL implementation stores Text mostly in the widgets,
            using the virtual <var>Get/SetTextBuf</var> methods to exchange text between widgets and VCL.
            This means a lot of text copies and message handling in WM_GETTEXT and WM_SETTEXT.
          </p>
          <p>The LCL instead (typically) stores Text in a field of the control,
            and transfers it from/to the widgets only when required.
          </p>
          <p>To maintain VCL compatibility,
            the virtual <var>RealGet/SetText</var> methods have been introduced,
            which read or write the Caption string directly.
          </p>
          <p>The default <var>Get/SetTextBuf</var> implementation calls the <var>RealGet/SetText</var> methods,
            resulting in a string-to-PCHAR and another PCHAR-to-string conversion.
            But as long as <var>Get/SetTextBuf</var> is not overridden,
            <var>Get/SetText</var> can (and does) safely call <var>RealGet/SetText</var> immediately,
            to avoid beforementioned conversions.
          </p>
          <p>To keep things optimal, LCL components should always override RealGet/SetText;
            Get/SetTextBuf is only kept for compatibility.
          </p>
        </descr>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Top">
        <short>The client coordinate of the top edge of the control.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.UndockHeight">
        <short>The height of the control in floating state.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.UndockWidth">
        <short>The width of the control in floating state.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Visible">
        <short>Allows to show or hide the control, and all of its children.
        </short>
        <descr>
          <p>Visible is set to True by <var>Show</var>, or to False by <var>Hide</var>.
            Calling these methods is equivalent to setting the Visible property.
          </p>
          <remark>Reading the Visible property does not take into account control's parent visibility.
            Use the IsVisible method to get the real visibility.</remark>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.IsVisible"/>
          <link id="#lcl.Controls.TControl.Show"/>
          <link id="#lcl.Controls.TControl.Hide"/>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Width">
        <short>The horizontal extent of the control.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.WindowProc">
        <short>The handler for all messages.</short>
        <descr>
          <p>WindowProc is set to <link id="TControl.WndProc"/> by default.
          </p>
          <p>When you ever change WindowProc, then remember the previous setting
            and delegate all unhandled messages to that method.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TWndMethod">TWndMethod</link>
          <link id="#lcl.LMessages.TLMessage">TLMessage</link>
          <link id="TControl.Perform">Perform</link>
        </seealso>
      </element>
      <!-- range type Visibility: default -->
      <element name="TBorderWidth">
        <short>Integer type for <link id="TWinControl.BorderWidth"/>.</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetChildProc">
        <short>Type of a callback method, to be called for all children of a control.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.GetChildren"/>
        </seealso>
      </element>
      <element name="TGetChildProc.Child">
        <short>The child control.</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlChildSizing">
        <short>How Child controls are to be sized relative to parent.</short>
        <descr>
          <code>{ LeftRightSpacing, TopBottomSpacing: integer;
        minimum space between client border and nearest child control.
        For example: ClientLeftRight=5 means leftmost child's Left position is at least 5.

    HorizontalSpacing, VerticalSpacing: integer;
        minimum space between each child control.
  }

  {   Defines how child controls are resized/aligned.

      cesAnchorAligning, cssAnchorAligning
        Anchors and Align work like Delphi. For example if Anchors property of
        the control is [akLeft], it means fixed distance between left border of
        parent's client area. [akRight] means fixed distance between right
        border of the control and the right border of the parent's client area.
        When the parent is resized the child is moved to keep the distance.
        [akLeft,akRight] means fixed distance to left border and fixed distance
        to right border. When the parent is resized, the controls width is
        changed (resized) to keep the left and right distance.
        Same for akTop,akBottom.

        Align=alLeft for a control means set Left leftmost, Top topmost and
        maximize Height. The width is kept, if akRight is not set. If akRight
        is set in the Anchors property, then the right distance is kept and
        the control's width is resized.
        If there several controls with Align=alLeft, they will not overlapp and
        be put side by side.
        Same for alRight, alTop, alBottom. (Always expand 3 sides).

        Align=alClient. The control will fill the whole remaining space.
        Setting two children to Align=alClient does only make sense, if you set
        maximum Constraints.

        Order: First all alTop children are resized, then alBottom, then alLeft,
        then alRight and finally alClient.

      cesScaleChilds, cssScaleChilds
        Scale children, keep space between them fixed.
        Children are resized to their normal/advised size. If there is some space
        left in the client area of the parent, then the children are scaled to
        fill the space. You can set maximum Constraints. Then the other children
        are scaled more.
        For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and
        C.Width=30 (total=60). If the Parent's client area has a ClientWidth of
        120, then the children are scaled with Factor 2.
        If B has a maximum constraint width of 30, then first the children will be
        scaled with 1.5 (A.Width=15, B.Width=30, C.Width=45). Then A and C
        (15+45=60 and 30 pixel space left) will be scaled by 1.5 again, to a
        final result of: A.Width=23, B.Width=30, C.Width=67 (23+30+67=120).

      cesHomogenousChildGrowth, cssHomogenousChildDecrease
        Enlarge children equally.
        Children are resized to their normal/advised size. If there is some space
        left in the client area of the parent, then the remaining space is
        distributed equally to each child.
        For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and
        C.Width=30 (total=60). If the Parent's client area has a ClientWidth of
        120, then 60/3=20 is added to each Child.
        If B has a maximum constraint width of 30, then first 10 is added to
        all children (A.Width=20, B.Width=30, C.Width=40). Then A and C
        (20+40=60 and 30 pixel space left) will get 30/2=15 additional,
        resulting in: A.Width=35, B.Width=30, C.Width=55 (35+30+55=120).

      cesHomogenousSpaceGrowth
        Enlarge space between children equally.
        Children are resized to their normal/advised size. If there is some space
        left in the client area of the parent, then the space between the children
        is expanded.
        For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and
        C.Width=30 (total=60). If the Parent's client area has a ClientWidth of
        120, then there will be 60/2=30 space between A and B and between
        B and C.
  }

</code>
        </descr>
        <errors/>
        <seealso/>
      <notes><note>???</note>
        </notes>
      </element>
      <!-- variable Visibility: private -->
      <element link="TControlChildSizing.Control" name="TControlChildSizing.FControl"/>
      <element link="TControlChildSizing.ControlsPerLine" name="TControlChildSizing.FControlsPerLine"/>
      <element link="TControlChildSizing.EnlargeHorizontal" name="TControlChildSizing.FEnlargeHorizontal"/>
      <element link="TControlChildSizing.EnlargeVertical" name="TControlChildSizing.FEnlargeVertical"/>
      <element link="TControlChildSizing.HorizontalSpacing" name="TControlChildSizing.FHorizontalSpacing"/>
      <element link="TControlChildSizing.Layout" name="TControlChildSizing.FLayout"/>
      <element link="TControlChildSizing.LeftRightSpacing" name="TControlChildSizing.FLeftRightSpacing"/>
      <element link="TControlChildSizing.OnChange" name="TControlChildSizing.FOnChange"/>
      <element link="TControlChildSizing.ShrinkHorizontal" name="TControlChildSizing.FShrinkHorizontal"/>
      <element link="TControlChildSizing.ShrinkVertical" name="TControlChildSizing.FShrinkVertical"/>
      <element link="TControlChildSizing.TopBottomSpacing" name="TControlChildSizing.FTopBottomSpacing"/>
      <element link="TControlChildSizing.VerticalSpacing" name="TControlChildSizing.FVerticalSpacing"/>
      <!-- procedure Visibility: private -->
      <element link="TControlChildSizing.ControlsPerLine" name="TControlChildSizing.SetControlsPerLine"/>
      <element name="TControlChildSizing.SetControlsPerLine.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlChildSizing.EnlargeHorizontal" name="TControlChildSizing.SetEnlargeHorizontal"/>
      <element name="TControlChildSizing.SetEnlargeHorizontal.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlChildSizing.EnlargeVertical" name="TControlChildSizing.SetEnlargeVertical"/>
      <element name="TControlChildSizing.SetEnlargeVertical.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlChildSizing.HorizontalSpacing" name="TControlChildSizing.SetHorizontalSpacing"/>
      <element name="TControlChildSizing.SetHorizontalSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlChildSizing.Layout" name="TControlChildSizing.SetLayout"/>
      <element name="TControlChildSizing.SetLayout.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlChildSizing.LeftRightSpacing" name="TControlChildSizing.SetLeftRightSpacing"/>
      <element name="TControlChildSizing.SetLeftRightSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlChildSizing.ShrinkHorizontal" name="TControlChildSizing.SetShrinkHorizontal"/>
      <element name="TControlChildSizing.SetShrinkHorizontal.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlChildSizing.ShrinkVertical" name="TControlChildSizing.SetShrinkVertical"/>
      <element name="TControlChildSizing.SetShrinkVertical.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlChildSizing.TopBottomSpacing" name="TControlChildSizing.SetTopBottomSpacing"/>
      <element name="TControlChildSizing.SetTopBottomSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TControlChildSizing.VerticalSpacing" name="TControlChildSizing.SetVerticalSpacing"/>
      <element name="TControlChildSizing.SetVerticalSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlChildSizing.Change">
        <short>Notifies Control and invokes the
          <var>OnChange</var> handler.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TWinControl.DoChildSizingChange"/>
        </seealso>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControlChildSizing.Create"/>
      <element name="TControlChildSizing.Create.OwnerControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#rtl.Classes.TPersistent.Assign" name="TControlChildSizing.Assign"/>
      <element name="TControlChildSizing.Assign.Source">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="TPersistent.AssignTo" name="TControlChildSizing.AssignTo"/>
      <element name="TControlChildSizing.AssignTo.Dest">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlChildSizing.IsEqual">
        <short>True if the specified sizing is equal to this one.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.IsEqual.Result">
        <short/>
      </element>
      <element name="TControlChildSizing.IsEqual.Sizing">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlChildSizing.SetGridSpacing">
        <short>Set all spaceing to the same value.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetGridSpacing.Spacing">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.Control">
        <short>The <var>Control</var> to which childsizing applies.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.ControlsPerLine">
        <short>number of controls per line</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.EnlargeHorizontal">
        <short>Various ways to fit controls into the available Width.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.EnlargeVertical">
        <short>Various ways to fit controls into the available Height.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.HorizontalSpacing">
        <short>Minimum space between children.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.Layout">
        <short>Allows to also arrange the child controls in rows or columns.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.LeftRightSpacing">
        <short>Minimum distance between children and client border.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.OnChange">
        <short>Event handler for any change in the data.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.ShrinkHorizontal">
        <short>Various ways to fit controls into the available Width.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.ShrinkVertical">
        <short>Various ways to fit controls into the available Height.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.TopBottomSpacing">
        <short>Minimum distance between children and client border.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.VerticalSpacing">
        <short>Minimum space between children.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element link="TControlActionLink" name="TWinControlActionLink"/>
      <element link="TControlActionLink" name="TWinControlActionLinkClass">
        <short>Class of
          <var>TWinControlActionLink</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TWinControlFlag">
        <short>State flags of TWinControl.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlFlag.wcfClientRectNeedsUpdate">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControlFlag.wcfColorChanged">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControlFlag.wcfFontChanged">
        <short>Set if font was changed before handle creation.</short>
      </element>
      <element name="TWinControlFlag.wcfAllAutoSizing">
        <short>Set during DoAllAutosize.</short>
      </element>
      <element name="TWinControlFlag.wcfAligningControls">
        <short>Set during <link id="TWinControl.AlignControls"/>
        </short>
      </element>
      <element name="TWinControlFlag.wcfEraseBackground">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControlFlag.wcfCreatingHandle">
        <short>Set while constructing the handle of this control.</short>
      </element>
      <element name="TWinControlFlag.wcfInitializing">
        <short>Set while initializing during handle creation.</short>
      </element>
      <element name="TWinControlFlag.wcfCreatingChildHandles">
        <short>Set while constructing the handles of the children.</short>
      </element>
      <element name="TWinControlFlag.wcfRealizingBounds">
        <short>Set inside RealizeBoundsRecursive.</short>
      </element>
      <element name="TWinControlFlag.wcfBoundsRealized">
        <short>Set before bounds are sent to the widget.
          Used to suppress consequential size messages, sent by the widget.
        </short>
      </element>
      <element name="TWinControlFlag.wcfUpdateShowing">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControlFlag.wcfHandleVisible">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControlFlag.wcfAdjustedLogicalClientRectValid">
        <short>Set when the adjusted ClientRect is valid.</short>
        <seealso>
          <link id="TWinControl.GetAdjustedLogicalClientRect"/>
        </seealso>
      </element>
      <element name="TWinControlFlag.wcfKillIntfSetBounds">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- set type Visibility: default -->
      <element link="TWinControlFlag" name="TWinControlFlags">
        <short>Set of TWinControlFlag.</short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TAlignInfo">
        <short>Used in custom alignment (alCustom).</short>
        <descr>This record was added only after D7.
          It's used in CustomInsertBefore and CustomAlignPosition methods and handlers.
        </descr>
        <seealso>
          <link id="TWinControl.CustomAlignPosition"/>
          <link id="TWinControl.CustomAlignInsertBefore"/>
        </seealso>
      </element>
      <element name="TAlignInfo.AlignList">
        <short>The list of controls currently being aligned.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAlignInfo.ControlIndex">
        <short>Index of current control.</short>
        <descr/>
        <seealso/>
      <notes><note>in AlignList?</note>
        </notes>
      </element>
      <element name="TAlignInfo.Align">
        <short>The kind of alignment currently processed (always alCustom).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAlignInfo.Scratch">
        <short>For internal use.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function type Visibility: default -->
      <element name="TAlignInsertBeforeEvent">
        <short>Type of an OnAlignInsertBefore handler.</short>
        <descr>The handler determines the order, in which both controls are aligned later.
        </descr>
        <seealso>
          <link id="TWinControl.CustomAlignInsertBefore"/>
        </seealso>
      </element>
      <element name="TAlignInsertBeforeEvent.Result">
        <short>True if Control2 shall be placed before Control1 is placed.</short>
      </element>
      <element name="TAlignInsertBeforeEvent.Sender">
        <short>The Parent control</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TAlignInsertBeforeEvent.Control1">
        <short/>
      </element>
      <element name="TAlignInsertBeforeEvent.Control2">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TAlignPositionEvent">
        <short>Type of an OnAlignPosition handler.</short>
        <descr>The handler positions Control by changing the given coordinates.
        </descr>
        <seealso>
          <link id="TWinControl.CustomAlignPosition"/>
        </seealso>
      </element>
      <element name="TAlignPositionEvent.Sender">
        <short>The Parent control</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TAlignPositionEvent.Control">
        <short>The control to place.</short>
      </element>
      <element name="TAlignPositionEvent.NewLeft">
        <short/>
      </element>
      <element name="TAlignPositionEvent.NewTop">
        <short/>
      </element>
      <element name="TAlignPositionEvent.NewWidth">
        <short/>
      </element>
      <element name="TAlignPositionEvent.NewHeight">
        <short/>
      </element>
      <element name="TAlignPositionEvent.AlignRect">
        <short>The remaining ClientRect</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TAlignPositionEvent.AlignInfo">
        <short>Information about the current align process</short>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- object Visibility: default -->
      <element name="TWinControl">
        <short>The base class for controls which can contain other (child) controls.</short>
        <descr>The name reflects the fact that (on Windows) these controls are based on OS provided widgets, which have window Handles.
        </descr>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FAdjustClientRect">
        <short>valid if wcfAdjustClientRectValid</short>
        <descr/>
        <seealso/>
      <notes><note>what?</note>
        </notes>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FAdjustClientRectRealized">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FAlignOrder">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element link="TWinControl.BorderStyle" name="TWinControl.FBorderStyle"/>
      <element link="TWinControl.BorderWidth" name="TWinControl.FBorderWidth"/>
      <element link="TWinControl.BoundsLockCount" name="TWinControl.FBoundsLockCount"/>
      <element name="TWinControl.FBoundsRealized">
        <short>The bounds as sent to the widget.
          Used to suppress according feedback messages from the widget.
        </short>
      </element>
      <element link="TWinControl.Brush" name="TWinControl.FBrush"/>
      <element link="TWinControl.ChildSizing" name="TWinControl.FChildSizing"/>
      <element link="TWinControl.ClientWidth" name="TWinControl.FClientWidth"/>
      <element link="TWinControl.ClientHeight" name="TWinControl.FClientHeight"/>
      <element link="TWinControl.Controls" name="TWinControl.FControls"/>
      <element link="TWinControl.DefWndProc" name="TWinControl.FDefWndProc"/>
      <element link="TWinControl.DockClients" name="TWinControl.FDockClients"/>
      <element link="TWinControl.DockManager" name="TWinControl.FDockManager"/>
      <element link="TWinControl.DockSite" name="TWinControl.FDockSite"/>
      <element link="TWinControl.DoubleBuffered" name="TWinControl.FDoubleBuffered"/>
      <element link="TWinControl.Handle" name="TWinControl.FHandle"/>
      <element link="TWinControl.OnAlignInsertBefore" name="TWinControl.FOnAlignInsertBefore"/>
      <element link="TWinControl.OnAlignPosition" name="TWinControl.FOnAlignPosition"/>
      <element link="TWinControl.OnDockDrop" name="TWinControl.FOnDockDrop"/>
      <element link="TWinControl.OnDockOver" name="TWinControl.FOnDockOver"/>
      <element link="TWinControl.OnEnter" name="TWinControl.FOnEnter"/>
      <element link="TWinControl.OnExit" name="TWinControl.FOnExit"/>
      <element link="TWinControl.OnGetDockCaption" name="TWinControl.FOnGetDockCaption"/>
      <element link="TWinControl.OnGetSiteInfo" name="TWinControl.FOnGetSiteInfo"/>
      <element link="TWinControl.OnKeyDown" name="TWinControl.FOnKeyDown"/>
      <element link="TWinControl.OnKeyPress" name="TWinControl.FOnKeyPress"/>
      <element link="TWinControl.OnKeyUp" name="TWinControl.FOnKeyUp"/>
      <element link="TWinControl.OnUnDock" name="TWinControl.FOnUnDock"/>
      <element link="TWinControl.OnUTF8KeyPress" name="TWinControl.FOnUTF8KeyPress"/>
      <element link="TWinControl.ParentWindow" name="TWinControl.FParentWindow"/>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FRealizeBoundsLockCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element link="TWinControl.Showing" name="TWinControl.FShowing"/>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FTabList">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element link="TWinControl.TabOrder" name="TWinControl.FTabOrder"/>
      <element link="TWinControl.TabStop" name="TWinControl.FTabStop"/>
      <element link="TWinControl.UseDockManager" name="TWinControl.FUseDockManager"/>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FWinControlFlags">
        <short>Various control state flags.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.AlignControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.AlignControl.AControl">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TWinControl.Brush" name="TWinControl.GetBrush"/>
      <element name="TWinControl.GetBrush.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TWinControl.Controls" name="TWinControl.GetControl"/>
      <element name="TWinControl.GetControl.Result">
        <short/>
      </element>
      <element name="TWinControl.GetControl.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TWinControl.ControlCount" name="TWinControl.GetControlCount"/>
      <element name="TWinControl.GetControlCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TWinControl.DockClientCount" name="TWinControl.GetDockClientCount"/>
      <element name="TWinControl.GetDockClientCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TWinControl.DockClients" name="TWinControl.GetDockClients"/>
      <element name="TWinControl.GetDockClients.Result">
        <short/>
      </element>
      <element name="TWinControl.GetDockClients.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TWinControl.Handle" name="TWinControl.GetHandle"/>
      <element name="TWinControl.GetHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TWinControl.IsResizing" name="TWinControl.GetIsResizing"/>
      <element name="TWinControl.GetIsResizing.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TWinControl.TabOrder" name="TWinControl.GetTabOrder"/>
      <element name="TWinControl.GetTabOrder.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetVisibleDockClientCount">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.GetVisibleDockClientCount.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TWinControl.ChildSizing" name="TWinControl.SetChildSizing"/>
      <element name="TWinControl.SetChildSizing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TWinControl.DockSite" name="TWinControl.SetDockSite"/>
      <element name="TWinControl.SetDockSite.NewDockSite">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TWinControl.Handle" name="TWinControl.SetHandle"/>
      <element name="TWinControl.SetHandle.NewHandle">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TWinControl.BorderWidth" name="TWinControl.SetBorderWidth"/>
      <element name="TWinControl.SetBorderWidth.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TWinControl.ParentWindow" name="TWinControl.SetParentWindow"/>
      <element name="TWinControl.SetParentWindow.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TWinControl.TabOrder" name="TWinControl.SetTabOrder"/>
      <element name="TWinControl.SetTabOrder.NewTabOrder">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TWinControl.TabStop" name="TWinControl.SetTabStop"/>
      <element name="TWinControl.SetTabStop.NewTabStop">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TWinControl.UseDockManager" name="TWinControl.SetUseDockManager"/>
      <element name="TWinControl.SetUseDockManager.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.UpdateTabOrder">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.UpdateTabOrder.NewTabOrder">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.WantsKeyBeforeInterface">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WantsKeyBeforeInterface.Result">
        <short/>
      </element>
      <element name="TWinControl.WantsKeyBeforeInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.WantsKeyBeforeInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.Insert">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.Insert.AControl">
        <short/>
      </element>
      <element name="TWinControl.Insert.Index">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.Remove">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.Remove.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.AlignNonAlignedControls">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.AlignNonAlignedControls.ListOfControls">
        <short/>
      </element>
      <element name="TWinControl.AlignNonAlignedControls.BoundsModified">
        <short/>
      </element>
      <element link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass" name="TWinControl.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.AdjustClientRect">
        <short>Override this method when the ClientRect of a control differs from the default value.
        </short>
        <descr/>It's called often, so don't put expensive code here, or cache the result.
        
        
        <errors/>
        <seealso>
          <link id="TWinControl.GetAdjustedLogicalClientRect"/>
        </seealso>
      </element>
      <element name="TWinControl.AdjustClientRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.GetAdjustedLogicalClientRect">
        <short>Returns the adjusted ClientRect, cached value if available.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TWinControl.AdjustClientRect"/>
          <link id="TWinControlFlag.wcfAdjustedLogicalClientRectValid"/>
        </seealso>
      </element>
      <element name="TWinControl.GetAdjustedLogicalClientRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateControlAlignList">
        <short>Fills the list with the controls which must be realigned.
        </short>
        <descr>The list is initialized with all child controls,
          which have the given alignment and are visible.
        </descr>
        <errors/>
        <seealso>
          <link id="TWinControl.AlignControls"/>
        </seealso>
      </element>
      <element name="TWinControl.CreateControlAlignList.TheAlign">
        <short>List all controls with this alignment.</short>
      </element>
      <element name="TWinControl.CreateControlAlignList.AlignList">
        <short/>
      </element>
      <element name="TWinControl.CreateControlAlignList.StartControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.AlignControls">
        <short>Aligns all child controls.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TWinControlFlag.wcfAligningControls"/>
        </seealso>
      </element>
      <element name="TWinControl.AlignControls.AControl">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.AlignControls.RemainingClientRect">
        <short>The available space, becomes remaining space on exit.</short>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore">
        <short>Returns the placement order of custom-aligned child controls, using
          the <var>OnAlignInsertBefore</var> handler.</short>
        <seealso>
          <link id="TAlignInsertBeforeEvent"/>
        </seealso>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.Result">
        <short>True if Control2 shall be placed before Control1 is placed.</short>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.AControl1">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.AControl2">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition">
        <short>Returns the aligned position of a custom-aligned child control,
          using the <var>OnAlignPosition</var> handler.</short>
        <descr>
          <p>The given coordinates take into account the anchoring of AControl.
          </p>
          <p>The handler updates the coordinates as required.
          </p>
        </descr>
        <seealso>
          <link id="TAlignInsertBeforeEvent"/>
        </seealso>
      </element>
      <element name="TWinControl.CustomAlignPosition.AControl">
        <short>The control to be placed.</short>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewLeft">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewTop">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewWidth">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewHeight">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.AlignRect">
        <short>The remaining client area, within which the control can be placed.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.CustomAlignPosition.AlignInfo">
        <short>Information about the current align process</short>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoAlignChildControls">
        <short>Override this method to place all given controls.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TWinControl.AlignControls"/>
        </seealso>
      </element>
      <element name="TWinControl.DoAlignChildControls.Result">
        <short>True when all controls have been placed.</short>
      </element>
      <element name="TWinControl.DoAlignChildControls.TheAlign">
        <short>The alignment of all given controls.</short>
      </element>
      <element name="TWinControl.DoAlignChildControls.AControl">
        <short/>
      </element>
      <element name="TWinControl.DoAlignChildControls.AControlList">
        <short>The controls to be placed.</short>
      </element>
      <element name="TWinControl.DoAlignChildControls.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoChildSizingChange">
        <short>Call this after a change in the ChildSizing information, to trigger further processing.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoChildSizingChange.Sender">
        <short/>
      </element>
      <element name="TWinControl.InvalidatePreferredChildSizes">
        <short>Flags the preferred sizes of all child controls as invalid (recursively).</short>
        <seealso>
          <link id="TControlFlag.cfPreferredSizeValid"/>
          <link id="TControlFlag.cfPreferredMinSizeValid"/>
          <link id="TWinControlFlag.wcfAdjustedLogicalClientRectValid"/>
        </seealso>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.CanTab" name="TWinControl.CanTab"/>
      <element name="TWinControl.CanTab.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.ClientHeight" name="TWinControl.IsClientHeightStored"/>
      <element name="TWinControl.IsClientHeightStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TControl.ClientWidth" name="TWinControl.IsClientWidthStored"/>
      <element name="TWinControl.IsClientWidthStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoSendShowHideToInterface">
        <short>Sends the new Visible state to the widgetset.</short>
        <descr>Called by TWinControl.CMShowingChanged.</descr>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ControlsAligned">
        <short>Called by AlignControls after aligning controls.</short>
        <descr>
        </descr>
        <errors/>
        <seealso/>
      <notes><note>to do what?</note>
        </notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoSendBoundsToInterface">
        <short>Sends the control's new bounds to the widget.</short>
        <descr>Called by RealizeBounds.
        </descr>
        <errors/>
        <seealso>
          <link id="TWinControlFlag.wcfBoundsRealized"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.RealizeBounds">
        <short>Checks for BoundsRect changes and sends changed bounds to the widget, using DoSendBoundsToInterface.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.RealizeBoundsRecursive">
        <short>Sends eventually changed BoundsRects to the widgets, for this and all child controls.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TWinControl.RealizeBounds"/>
          <link id="TWinControlFlag.wcfRealizingBounds"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateSubClass">
        <short>TODO: Check if we need this method
        </short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.CreateSubClass.Params">
        <short/>
      </element>
      <element name="TWinControl.CreateSubClass.ControlClassName">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.DoConstraintsChange" name="TWinControl.DoConstraintsChange"/>
      <element name="TWinControl.DoConstraintsChange.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoSetBounds">
        <short>Updates the size and extent of the control and ClientRect.
        </short>
        <descr>
          <p>Changing the ClientRect here, to the most probable size, reduces unneccessary resizes.
          </p>
          <p>Normally the clientwidth/clientheight is adjusted automatically by the widget,
            but it is up to widget when this will be done.
            The gtk for example just puts resize requests into a queue.
            The LCL would resize the child components just after this procedure due to the clientrect.
            On complex forms with lots of nested controls, this would result in thousands of resizes.
          </p>
        </descr>
        <seealso>
          <link id="#LCL.Controls.TControl.DoSetBounds"/>
        </seealso>
      </element>
      <element name="TWinControl.DoSetBounds.ALeft">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.ATop">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.AWidth">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.AHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoAutoSize">
        <short>Shrink or enlarge the control to fit children.
        </short>
        <descr>
          <p>Because this method is frequently overridden,
            the LCL calls the added <link id="TControl.AdjustSize"/> instead,
            which checks whether DoAutoSize really should be called right now.
          </p>
          <p>DoAutoSize does roughly this:
          </p>
          <ul>
            <li>Checks whether Autosize is in fact permitted</li>
            <li>Checks for unaligned child components and fits them in as best it can</li>
            <li>Moves the constrained (aligned) child components to the correct position</li>
            <li>Adjusts the size of the client rectangle</li>
            <li>Adjusts the bounds of the whole control</li>
          </ul>
        </descr>
        <errors/>
        <seealso>
          <link id="TControl.DoAutoSize"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.DoAllAutoSize" name="TWinControl.DoAllAutoSize"/>
      <!-- function Visibility: protected -->
      <element name="TWinControl.AutoSizeCanStart">
        <short>Deprecated, don't use it.</short>
      </element>
      <element name="TWinControl.AutoSizeCanStart.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.AllAutoSized">
        <short>Called by DoAllAutoSize after all bounds are computed.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#lcl.forms.TCustomForm.AllAutoSized"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CalculatePreferredSize">
        <short>Override this method to return a different preferred height and width for autosizing.
        </short>
        <descr>
          <p>Calls the inherited method to calculate the default/preferred width and height for a <var>TWinControl</var>, which is used by the LCL autosizing algorithms as default size.
            Only positive values are valid. Negative or 0 are treated as undefined and the LCL uses other sizes instead.</p>
          <p>
            <var>TWinControl</var> overrides this:</p>
          <ul>
            <li>If there are child components, their total preferred size is calculated</li>
            <li>If this value can not be computed (e.g. the children depend too much on their
              parent clientrect), then the interface is asked for the preferred size</li>
          </ul>
          <p>For example the preferred size of a <var>TButton</var> is the size, where the label fits
            exactly. This depends heavily on the current theme and widgetset.</p>
          <p>This value is independent of constraints and siblings, only the inner parts are relevant.</p>
          <p>
            <var>WithThemeSpace</var>: If true, adds space for stacking. For example:
            
            
            <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be some space around.
            This space is theme dependent, so it is passed as a parameter to the widgetset. </p>
        </descr>
        <errors/>
        <seealso>
          <link id="TControl.CalculatePreferredSize"/>
        </seealso>
      </element>
      <element name="TWinControl.CalculatePreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TWinControl.CalculatePreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TWinControl.CalculatePreferredSize.WithThemeSpace">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.GetChildren">
        <short>Calls Proc with every child control, owned by Root.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TComponent.GetChildren">TComponent.GetChildren</link>
        </seealso>
      </element>
      <element name="TWinControl.GetChildren.Proc">
        <short>The callback procedure.</short>
      </element>
      <element name="TWinControl.GetChildren.Root">
        <short>The Owner of the reported controls.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.ChildClassAllowed">
        <short>Returns True if the given class is allowed for child controls.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ChildClassAllowed.Result">
        <short/>
      </element>
      <element name="TWinControl.ChildClassAllowed.ChildClass">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.PaintControls">
        <short>Paint all child controls which don't have a Handle.
        </short>
        <descr>Controls that are not TWinControl, have no handle of their own,
          and so they are repainted as part of the parent.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.PaintControls.DC">
        <short>The device context usable for painting child controls.</short>
      </element>
      <element name="TWinControl.PaintControls.First">
        <short>First of the controls in Controls[], which remain to paint.
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.PaintHandler">
        <short>Handler for TLMPaint, manages the painting of child controls.
         </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.PaintHandler.TheMessage">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.PaintWindow">
        <short>Paints an clipped part (child control) of the DC.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.PaintWindow.DC">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateBrush">
        <short>Creates the <link id="#lcl.Controls.TWinControl.Brush">Brush</link>, if not already created.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ScaleControls">
        <short>Scales (resizes) all child controls.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TWinControl.ChangeScale"/>
        </seealso>
      </element>
      <element name="TWinControl.ScaleControls.Multiplier">
        <short/>
      </element>
      <element name="TWinControl.ScaleControls.Divider">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.ChangeScale" name="TWinControl.ChangeScale">
        <short>Scales (resizes) the control and all child controls.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ChangeScale.Multiplier">
        <short/>
      </element>
      <element name="TWinControl.ChangeScale.Divider">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMBiDiModeChanged">
        <short>Handler for
          changed <link id="#lcl.Controls.TControl.BiDiMode">BiDiMode</link>
          message.
          Notifies the widget and all child controls.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CMBiDiModeChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMBorderChanged">
        <short>Handler for
          changed Border properties
          message.
          Adjusts and invalidates the control.
        </short>
      </element>
      <element name="TWinControl.CMBorderChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMEnabledChanged">
        <short>Handler for
          changed <link id="#lcl.Controls.TControl.Enabled">Enabled</link>
          message.
          Notifies the widgetset.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CMEnabledChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMShowingChanged">
        <short>Handler for
          changed <link id="TWinControl.Showing">Showing</link>
          message.
          Notifies the widgetset.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CMShowingChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMShowHintChanged">
        <short>Handler for
          changed <link id="TWinControl.ShowHint">ShowHint</link>
          message.
          Notifies all child controls.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CMShowHintChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMVisibleChanged">
        <short>Handler for
          changed <link id="#lcl.Controls.TControl.Visible">Visible</link>
          message.
          Handles Focus, forces UpdateControlState.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CMVisibleChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMEnter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.CMEnter.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMExit">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.CMExit.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMContextMenu">
        <short>Handler for an
          <link id="TControl.PopupMenu">ContextMenu</link> event.
          Eventually delegates handling to the affected child control.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMContextMenu.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMEraseBkgnd">
        <short>Erases the background,
          if <link id="TWinControlFlag.wcfEraseBackground">required</link>.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMEraseBkgnd.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMNotify">
        <short>Handles (dispatches) notification messages.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMNotify.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSetFocus">
        <short>Handler for receiving Focus event.</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>do what?</note>
        </notes>
      </element>
      <element name="TWinControl.WMSetFocus.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMKillFocus">
        <short>Handler for
          loosing Focus
          event.
          Eventually triggers <link id="#lcl.Controls.TControl.EditingDone"/>.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMKillFocus.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMShowWindow">
        <short>Handler for changed visibility notification
        </short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.WMShowWindow.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMEnter">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.WMEnter.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMExit">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.WMExit.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMKeyDown">
        <short>Event handler for key pressed, not handled by the widget.
          Tries <link id="TWinControl.DoRemainingKeyDown"/>.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSysKeyDown">
        <short>Event handler for sys key pressed, not handled by the widget.
          Tries <link id="TWinControl.DoRemainingKeyDown"/>.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>what's this?</note>
        </notes>
      </element>
      <element name="TWinControl.WMSysKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMKeyUp">
        <short>Event handler for
          key released, not handled by the widget.
          Tries <link id="TWinControl.DoRemainingKeyUp"/>.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSysKeyUp">
        <short>Event handler for
          system key released, not handled by the widget.
          Tries <link id="TWinControl.DoRemainingKeyUp"/>.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSysKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMChar">
        <short>Handler for
          message sent by the widget, after it has handled the keypress itself.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSysChar">
        <short>Handler for
          message sent by the widget, after it has handled the keypress itself.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSysChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMPaint">
        <short>Manages paint requests, handles double buffering.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMPaint.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMDestroy">
        <short>Handler for
          widget destroyed message. Clears the Handle.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMDestroy.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMMove">
        <short>Handler for
          widget moved message. Updates the Bounds.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMMove.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSize">
        <short>Event handler for size messages.
        </short>
        <descr>
          <p>This method is called whenever width, height, clientwidth or clientheight have changed.
          </p>
          <p>If the source of the message is the interface, the new size is stored
            in FBoundsRealized to avoid sending a size message back to the interface.
          </p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSize.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMWindowPosChanged">
        <short>Event handler for size/move messages.
        </short>
        <descr>
          <p>This method is called whenever left, top, width, height, clientwidth or clientheight have changed.
          </p>
          <p>If the source of the message is the interface, the new size is stored
            in FBoundsRealized to avoid sending a size message back to the interface.
          </p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WMWindowPosChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNKeyDown">
        <short>Handler for
          a key pushed notification.
          The message is handled by DoKeyDownBeforeInterface by default.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CNKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNSysKeyDown">
        <short>Handler for
          a system key pushed notification.
          The message is handled by DoKeyDownBeforeInterface by default.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CNSysKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNKeyUp">
        <short>Handler for
          a key released notification.
          The message is handled by DoKeyUpBeforeInterface by default.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CNKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNSysKeyUp">
        <short>Handler for
          a system key released notification.
          The message is handled by DoKeyUpBeforeInterface by default.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CNSysKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNChar">
        <short>Handler for
          a key pressed notification.
          CNChar is sent by the widget before it has handled the keypress itself.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CNChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoDragMsg">
        <short>Dispatches a drag message, sent by the DragManager.</short>
        <descr>
          <p>On dmFindTarget a TWinControl returns the child control under the mouse, or Self if none is found.
          </p>
          <p>All other messages are handled by inherited <link id="TControl.DoDragMsg"/>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.DoDragMsg"/>
        </seealso>
      </element>
      <element name="TWinControl.DoDragMsg.Result">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADragMessage">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.APosition">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADragObject">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ATarget">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADocking">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoDockClientMsg">
        <short>Handles a dmDragDock message, when a control has been docked to this site.</short>
        <descr>
          <p>Called when a control is dropped for docking.
          </p>
          <p>Asks the dropped control to Dock itself into this control (adjust HostDockSite etc.).
            <br/>
            Calls an installed DockManager to adjust the coordinates of the docked control.
          </p>
          <p>The Result is always True (unless overridden).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.DoDockClientMsg.Result">
        <short/>
      </element>
      <element name="TWinControl.DoDockClientMsg.DragDockObject">
        <short/>
      </element>
      <element name="TWinControl.DoDockClientMsg.aPosition">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoUndockClientMsg">
        <short>Notifies the DockManager of the undock of a client control.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TWinControl.DoUndockClientMsg.Result">
        <short>Always True.</short>
      </element>
      <element name="TWinControl.DoUndockClientMsg.NewTarget">
        <short/>
      </element>
      <element name="TWinControl.DoUndockClientMsg.Client">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoAddDockClient">
        <short>Adjust the Parent of a newly docked Client.</short>
        <descr>The default action is to set the Parent to the new docksite (this control),
          so that the client is displayed within the new site.</descr>
      </element>
      <element name="TWinControl.DoAddDockClient.Client">
        <short/>
      </element>
      <element name="TWinControl.DoAddDockClient.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DockOver">
        <short>Called to check whether this control allows docking and where.
        </short>
        <descr>
          <p>Called on dragmanager messages dmEnter/Leave/Move, to get the DockRect to show.
          </p>
          <p>Positions the DockRect, invokes OnDockOver (via DoDockOver)
          </p>
          <p>Everything can be overridden by the OnDockOver handler, if installed.
          </p>
        </descr>
        <seealso>
          <link id="TControl.PositionDockRect"/>
          <link id="TControl.OnDockOver"/>
        </seealso>
      </element>
      <element name="TWinControl.DockOver.Source">
        <short/>
      </element>
      <element name="TWinControl.DockOver.X">
        <short/>
      </element>
      <element name="TWinControl.DockOver.Y">
        <short/>
      </element>
      <element name="TWinControl.DockOver.State">
        <short/>
      </element>
      <element name="TWinControl.DockOver.Accept">
        <short>Initially True, set to False to reject an drop.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoDockOver">
        <short>Invoke the <link id="TWinControl.OnDockOver">OnDockOver</link> handler.</short>
      </element>
      <element name="TWinControl.DoDockOver.Source">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.X">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.Y">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.State">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.Accept">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoRemoveDockClient">
        <short>Override this method to take special actions on removal of an docked client.</short>
        <descr>The default implementation does nothing.</descr>
      </element>
      <element name="TWinControl.DoRemoveDockClient.Client">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoUnDock">
        <short>Notifies an <var>OnUnDock</var> handler and DockManager of an undocked client control.</short>
        <descr>The OnUnDock handler can deny to undock the control.
          This can cause trouble, the control better should not be draggable instead.
        </descr>
        <errors/>
        <seealso>
          <link id="TWinControl.DoUndockClientMsg"/>
          <link id="TWinControl.OnUnDock"/>
        </seealso>
      </element>
      <element name="TWinControl.DoUnDock.Result">
        <short>Set to False to deny undocking.</short>
      </element>
      <element name="TWinControl.DoUnDock.NewTarget">
        <short>The new docksite, Nil for floating.</short>
      </element>
      <element name="TWinControl.DoUnDock.Client">
        <short>The control being undocked.</short>
      </element>
      <element name="TWinControl.DoUnDock.KeepDockSiteSize">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.GetSiteInfo">
        <short>Return information about this dock site (InfluenceRect).</short>
        <descr>The InfluenceRect determines the screen coordinates,
          within which a drop is accepted.<br/>
          The InfluenceRect is the slightly inflated WindowRect of the dock site,
          adjustable in an OnGetSiteInfo handler.
        </descr>
      </element>
      <element name="TWinControl.GetSiteInfo.Client">
        <short>The dragged control</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.GetSiteInfo.InfluenceRect">
        <short>The screen rectangle within which a drop is allowed.</short>
      </element>
      <element name="TWinControl.GetSiteInfo.MousePos">
        <short>The current mouse position.</short>
      </element>
      <element name="TWinControl.GetSiteInfo.CanDock">
        <short>Can be set to False to reject an drop.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ReloadDockedControl">
        <short>Returns the docked control of the specified name.</short>
        <descr>
          <p>This method is used during the restore of the layout of a docksite.
          </p>
          <p>The control is searched in the controls owned by the owner of the docksite.
          </p>
          <p>Override to search other places, or to create a control of the requested name.
          </p>
        </descr>
      </element>
      <element name="TWinControl.ReloadDockedControl.AControlName">
        <short>The name of the control to be docked.</short>
      </element>
      <element name="TWinControl.ReloadDockedControl.AControl">
        <short>The matching control.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.CreateDockManager">
        <short>Returns the DockManager for this control.</short>
        <descr>If DockManager is nil, and UseDockManager is True, a new default DockManager is created.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CreateDockManager.Result">
        <short>The dockmanager for this site, can be Nil for an unmanaged site.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TWinControl.DockManager" name="TWinControl.SetDockManager"/>
      <element name="TWinControl.SetDockManager.AMgr">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TControl.DoFloatMsg" name="TWinControl.DoFloatMsg">
        <short>Handler called when the control starts floating.</short>
        <descr>TWinControls can float for themselves, unless they request a special FloatingDockSiteClass.
        </descr>
        <errors/>
        <seealso/>
      <notes><note>Bug: when no FloatingDockSiteClass was assigned,
          a default floating site is created?</note>
        </notes>
      </element>
      <element name="TWinControl.DoFloatMsg.ADockSource">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoGetDockCaption">
        <short>Returns the dock caption of AControl.
        </short>
        <descr>
          <p>Asks the control for its default dock caption,
            then allows the OnGetDockCaption handler to adjust this string.
          </p>
        </descr>
        <errors/>
        <seealso>
          <link id="TControl.GetDockCaption"/>
          <link id="TWinControl.OnGetDockCaption"/>
        </seealso>
      </element>
      <element name="TWinControl.DoGetDockCaption.AControl">
        <short>The control whose dock caption string is requested.</short>
      </element>
      <element name="TWinControl.DoGetDockCaption.ACaption">
        <short>The dock caption to use.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoEnter">
        <short>Invokes the <link id="#lcl.Controls.TWinControl.OnEnter">OnEnter</link> event handler.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoExit">
        <short>Invoke the <link id="#lcl.Controls.TWinControl.OnExit">OnExit</link> event handler.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoKeyDownBeforeInterface">
        <short>Handles a KeyDown event before the widget processes the key.
        </short>
        <descr>
          <p>A number of handlers is invoked, until one handles the key.
          </p>
          <p>First all application wide handlers are invoked (<link id="#lcl.Forms.TApplication.NotifyKeyDownBeforeHandler"/>).
          </p>
          <p>Then the form's handler is invoked, when KeyPreview is requested.
          </p>
          <p>Then the DragManager is asked, when dragging.
            It interprets ESC to cancel dragging, and CTRL to ignore drag targets.
          </p>
          <p>Finally the <link id="TWinControl.OnKeyDown"/> user handler is invoked.
          </p>
          <p>If no handler accepts the key, the widget continues to interpret it itself.
          </p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.Result">
        <short>Set to True when the key was handled.</short>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.Message">
        <short/>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.IsRecurseCall">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoRemainingKeyDown">
        <short>Handles keys which are not handled by the widget.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoRemainingKeyDown.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DoRemainingKeyDown.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoRemainingKeyUp">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.DoRemainingKeyUp.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DoRemainingKeyUp.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoKeyPress">
        <short>Tries all <link id="#lcl.Controls.TWinControl.OnKeyPress">OnKeyPress</link> handlers, of Parents first.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TWinControl.OnUTF8KeyPress"/>
        </seealso>
      </element>
      <element name="TWinControl.DoKeyPress.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DoKeyPress.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="TWinControl.DoKeyPress" name="TWinControl.DoUTF8KeyPress"/>
      <element name="TWinControl.DoUTF8KeyPress.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DoUTF8KeyPress.UTF8Key">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoKeyUpBeforeInterface">
        <short>Handles a KeyUp event before the widget processes the key.
        </short>
        <descr>For details see the equivalent method <link id="TWinControl.DoKeyDownBeforeInterface"/>.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoKeyUpBeforeInterface.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DoKeyUpBeforeInterface.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.ChildKey">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.ChildKey.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.ChildKey.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.SendDialogChar">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.SendDialogChar.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.SendDialogChar.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.DialogChar" name="TWinControl.DialogChar"/>
      <element name="TWinControl.DialogChar.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DialogChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ControlKeyDown">
        <short>Lets the Application handle an navigation key.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ControlKeyDown.Key">
        <short/>
      </element>
      <element name="TWinControl.ControlKeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ControlKeyUp">
        <short>Lets the Application handle an navigation key.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ControlKeyUp.Key">
        <short/>
      </element>
      <element name="TWinControl.ControlKeyUp.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyDown">
        <short>Invokes the <link id="#lcl.Controls.TWinControl.OnKeyDown">OnKeyDown</link> handler.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyDown.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyDownBeforeInterface">
        <short>Invokes the <link id="#lcl.Controls.TWinControl.OnKeyDown">OnKeyDown</link> handler.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyDownBeforeInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyDownBeforeInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyDownAfterInterface">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.KeyDownAfterInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyDownAfterInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyPress">
        <short>Invokes the <link id="#lcl.Controls.TWinControl.OnKeyPress">OnKeyPress</link> handler.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyPress.Key">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyUp">
        <short>Invokes the <link id="#lcl.Controls.TWinControl.OnKeyUp">OnKeyUp</link> handler.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyUp.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyUp.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyUpBeforeInterface">
        <short>Invokes the <link id="#lcl.Controls.TWinControl.OnKeyUp">OnKeyUp</link> handler.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyUpBeforeInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyUpBeforeInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyUpAfterInterface">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.KeyUpAfterInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyUpAfterInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.UTF8KeyPress">
        <short>Invokes the <link id="#lcl.Controls.TWinControl.OnUTF8KeyPress">OnUTF8KeyPress</link> handler.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.UTF8KeyPress.UTF8Key">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.FindNextControl">
        <short>Returns the preceding or next control in tab order.</short>
        <descr>When CurrentControl is Nil, the first control (forward)
          or last control (backward) in TabOrder is returned, depending on GoForward.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.FindNextControl.Result">
        <short>The (next) control.</short>
      </element>
      <element name="TWinControl.FindNextControl.CurrentControl">
        <short>The control which has the focus.
          If Nil, the first control (forward)
          or last control (backward) in TabOrder is returned,
          depending on GoForward.
        </short>
      </element>
      <element name="TWinControl.FindNextControl.GoForward">
        <short>False to find the preceding control.</short>
      </element>
      <element name="TWinControl.FindNextControl.CheckTabStop">
        <short>When True: only find controls with TabStop=True.</short>
      </element>
      <element name="TWinControl.FindNextControl.CheckParent">
        <short>When True: only find controls with Parent=Self.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SelectFirst">
        <short>Returns the first control in tab order.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.RealGetText" name="TWinControl.RealGetText"/>
      <element name="TWinControl.RealGetText.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="TWinControl.BorderStyle" name="TWinControl.GetBorderStyle"/>
      <element name="TWinControl.GetBorderStyle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.GetClientOrigin" name="TWinControl.GetClientOrigin"/>
      <element name="TWinControl.GetClientOrigin.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.GetClientRect" name="TWinControl.GetClientRect"/>
      <element name="TWinControl.GetClientRect.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.GetControlOrigin" name="TWinControl.GetControlOrigin">
        <short>The screen coordinates of the control.</short>
        <descr>
          <p>Returns the screen coordinates of the topleft pixel of the control on the screen.</p>
          <remark>Note that this value is the position as stored in the interface and is not always in sync with the LCL.
            When a control is moved, the LCL sets the bounds to the wanted position and sends a move message to the interface.
            It is up to the interface to handle moves instantly or queued.
          </remark>
        </descr>
      </element>
      <element name="TWinControl.GetControlOrigin.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.GetDeviceContext" name="TWinControl.GetDeviceContext"/>
      <element name="TWinControl.GetDeviceContext.Result">
        <short/>
      </element>
      <element name="TWinControl.GetDeviceContext.WindowHandle">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.IsControlMouseMsg">
        <short>Sends the mouse message to a child control.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.IsControlMouseMsg.Result">
        <short>True if a child control was found at the mouse coordinates.</short>
      </element>
      <element name="TWinControl.IsControlMouseMsg.TheMessage">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateHandle">
        <short>Creates the Handle ( = widget) if not already done.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateParams">
        <short>Initializes the window creation parameter record with the settings of the control.
        </short>
        <descr>
          <p>Definition of parameters:</p>
          <pre>TCreateParams = record
    Caption: PChar;
    Style: Cardinal;
    ExStyle: Cardinal;
    X, Y: Integer;
    Width, Height: Integer;
    WndParent: HWnd;
    Param: Pointer;
    WindowClass: TWndClass;
    WinClassName: array[0..63] of Char;
End;
</pre>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CreateParams.Params">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateWnd">
        <short>Creates the interface object (widget) and assigns it to Handle.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DestroyHandle">
        <short>Destroys this and all child widgets.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DestroyWnd">
        <short>Destroys the interface object (widget).
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoFlipChildren">
        <short>Flip children horizontally. That means mirroring the Left position.
        </short>
        <descr>Child controls arranged in left-to-right order appear in right-to-left order after flipping.
          All anchors are adjusted accordingly.
        </descr>
        <errors/>
        <seealso>
          <link id="TWinControl.FlipChildren"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.FinalizeWnd">
        <short>Prepare to remove the window (gets called before the Handle is destroyed).
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.FixupTabList">
        <short>Assigns strictly sequential TabOrder values to all child windows.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.FontChanged" name="TWinControl.FontChanged"/>
      <element name="TWinControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.InitializeWnd">
        <short>Copies cached control properties to the just created widget.</short>
        <descr>
          <p>Gets called after the Handle is created and before the child handles are created.
          </p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.Loaded">
        <short>Called when the control has been loaded from a resource, transfers the loaded property values to the widget.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.Loaded">TControl.Loaded</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.FormEndUpdated">
        <short>Realizes all cached changes after a bulk update of the form. Calls inherited
          <var>FormEndUpdated</var>, then informs each child control.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.FormEndUpdated">TControl.FormEndUpdated</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.MainWndProc">
        <short>This method allows handling messages in Windows</short>
        <descr>
        </descr>
        <errors/>
        <seealso/>
      <notes><note>?</note><note>This method does nothing, and cannot be overridden???</note>
        </notes>
      </element>
      <element name="TWinControl.MainWndProc.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ParentFormHandleInitialized">
        <short>Called after all children handles of the ParentForm are created.
          Notifies all children of the end of the handle creation phase.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.ParentFormHandleInitialized">TControl.ParentFormHandleInitialized</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ChildHandlesCreated">
        <short>Called after all child handles have been created. Resets wcfCreatingChildHandles.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.RealSetText" name="TWinControl.RealSetText"/>
      <element name="TWinControl.RealSetText.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.RemoveFocus">
        <short>Notifies the parent form of the focus loss.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.RemoveFocus.Removing">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.SendMoveSizeMessages" name="TWinControl.SendMoveSizeMessages"/>
      <element name="TWinControl.SendMoveSizeMessages.SizeChanged">
        <short/>
      </element>
      <element name="TWinControl.SendMoveSizeMessages.PosChanged">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TWinControl.BorderStyle" name="TWinControl.SetBorderStyle"/>
      <element name="TWinControl.SetBorderStyle.NewStyle">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.SetColor" name="TWinControl.SetColor"/>
      <element name="TWinControl.SetColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SetChildZPosition">
        <short>Updates the position of the child control in the Z plane (ie front-to-back).
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.SetChildZPosition.AChild">
        <short/>
      </element>
      <element name="TWinControl.SetChildZPosition.APosition">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ShowControl">
        <short>Asks the parent to show ourself.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ShowControl.AControl">
        <short>The control to show, here: ignored!</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.UpdateControlState">
        <short>Essentially updates the visible state of the control, and of the widget if already created.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.UpdateShowing">
        <short>When the widget should be visible and has not yet been created, it's created along with all children.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WndProc">
        <short>Adds special handling for focus and input messages, notifies an DockManager.
        </short>
        <descr>
          <p>LM_SETFOCUS: gets parent form and show this control as focused</p>
          <p>LM_KILLFOCUS: removes focus fromthis control</p>
          <p>LM_NCHITTEST: check transparency etc</p>
          <p>Mouse messages: send to DockManager.</p>
        </descr>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.WndProc">TControl.WndProc</link>
        </seealso>
      </element>
      <element name="TWinControl.WndProc.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WSSetText">
        <short>Sends text to the widget (from WM_SETTEXT?).
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.WSSetText.AText">
        <short>The text to send.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.AutoSizePhases">
        <short>Translates state flags into AutoSizePhases</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.AutoSizePhases.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Controls.TControl.AutoSizeDelayed" name="TWinControl.AutoSizeDelayed"/>
      <element name="TWinControl.AutoSizeDelayed.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.AutoSizeCheckParent">
        <short>Checks for a parent control or widget.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.AutoSizeCheckParent.Result">
        <short>True when a parent exists.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.BeginUpdateBounds">
        <short>Start of Bounds updates. Disables SetBounds by incrementing BoundsLockCount.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TWinControl.EndUpdateBounds"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.EndUpdateBounds">
        <short>End of Bounds update. Decrements BoundsLockCount and eventually calls SetBounds.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TWinControl.BeginUpdateBounds"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.LockRealizeBounds">
        <short>Disables sending bounds to the widget, by incrementing FRealizeBoundsLockCount.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TWinControl.UnlockRealizeBounds"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.UnlockRealizeBounds">
        <short>Enables sending bounds to the widget again, eventually updates the widget.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TWinControl.LockRealizeBounds"/>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.ControlAtPos">
        <short>Get the child control at the given client position.</short>
        <descr>
          <p>WinControls are found before Controls (if overlapping).</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ControlAtPos.Result">
        <short>The found control, Nil if none found.</short>
      </element>
      <element name="TWinControl.ControlAtPos.Pos">
        <short>The client coordinates.</short>
      </element>
      <element name="TWinControl.ControlAtPos.AllowDisabled">
        <short>Allow finding disabled controls.</short>
      </element>
      <element name="TWinControl.ControlAtPos.AllowWinControls">
        <short>Allow finding TWinControls, in addition to TControls.</short>
      </element>
      <element name="TWinControl.ControlAtPos.OnlyClientAreas">
        <short>Only search in client areas.</short>
      </element>
      <element name="TWinControl.ControlAtPos.Flags">
        <short>Encoded Allow... conditions.</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.ContainsControl">
        <short>Returns True if this is a parent of the given control.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ContainsControl.Result">
        <short>True when we are a parent of Control.</short>
      </element>
      <element name="TWinControl.ContainsControl.Control">
        <short>The (possible) child control.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.DoAdjustClientRectChange">
        <short>Asks the widget if clientrect has changed since last AlignControl,
          and calls AdjustSize on change.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.DoAdjustClientRectChange.InvalidateRect">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.InvalidateClientRectCache">
        <short>The ClientRect is cached.
          Call this procedure to invalidate the cache,
          so that next time the ClientRect is fetched from the widget.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.InvalidateClientRectCache.WithChildControls">
        <short>Also invalidate all child controls, if True.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.ClientRectNeedsInterfaceUpdate">
        <short>The ClientRect is cached - check if the cache is valid.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ClientRectNeedsInterfaceUpdate.Result">
        <short>True if update needed.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TControl.SetBounds" name="TWinControl.SetBounds">
        <short>Sets the control bounds and adjusts child and docked controls.</short>
      </element>
      <element name="TWinControl.SetBounds.aLeft">
        <short/>
      </element>
      <element name="TWinControl.SetBounds.aTop">
        <short/>
      </element>
      <element name="TWinControl.SetBounds.aWidth">
        <short/>
      </element>
      <element name="TWinControl.SetBounds.aHeight">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.GetChildsRect" name="TWinControl.GetChildsRect"/>
      <element name="TWinControl.GetChildsRect.Result">
        <short/>
      </element>
      <element name="TWinControl.GetChildsRect.Scrolled">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="TWinControl.DisableAutoSizing" name="TWinControl.DisableAlign"/>
      <!-- procedure Visibility: public -->
      <element link="TWinControl.EnableAutoSizing" name="TWinControl.EnableAlign"/>
      <!-- procedure Visibility: protected -->
      <element link="TControl.AdjustSize" name="TWinControl.ReAlign"/>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.ScrollBy">
        <short>Move all child controls.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.ScrollBy.DeltaX">
        <short>Increment for Left.</short>
      </element>
      <element name="TWinControl.ScrollBy.DeltaY">
        <short>Increment for Top</short>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TControl.WriteLayoutDebugReport" name="TWinControl.WriteLayoutDebugReport"/>
      <element name="TWinControl.WriteLayoutDebugReport.Prefix">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TWinControl.Create"/>
      <element name="TWinControl.Create.TheOwner">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TWinControl.CreateParented">
        <short>Constructor for a control that is the child of the given widget.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CreateParented.AParentWindow">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="TWinControl.CreateParented" name="TWinControl.CreateParentedControl"/>
      <element name="TWinControl.CreateParentedControl.Result">
        <short/>
      </element>
      <element name="TWinControl.CreateParentedControl.AParentWindow">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TWinControl.Destroy"/>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.DockDrop">
        <short>Handler for a DragManager dmDragDrop message,
          sent when a dragged control has been dropped onto this docksite.
        </short>
        <descr>
          <p>Asks the dropped control to dock itself into this docksite,
            updating its Parent, HostDockSite,
            and the DockClients of the old and new DockSite.
          </p>
          <p>When a DockManager is installed,
            asks the DockManager to position the docked control (InsertControl).
          </p>
          <p>Finally creates an OnDockDrop event.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoDockClientMsg"/>
          <link id="TWinControl.OnDockDrop"/>
          <link id="TDragDockObject"/>
        </seealso>
      </element>
      <element name="TWinControl.DockDrop.DragDockObject">
        <short/>
      </element>
      <element name="TWinControl.DockDrop.X">
        <short/>
      </element>
      <element name="TWinControl.DockDrop.Y">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.CanFocus">
        <short>Is this control allowed to receive the focus?</short>
        <descr>A control can get the focus only when all of its Parents except the form are Visible and Enabled.
While CanFocus checks all control parents it does not check whether a form control is placed on can have focus.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.CanFocus.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.GetControlIndex">
        <short>Finds the index value for the given control,
          in <link id="TWinControl.Controls">Controls[]</link>.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.GetControlIndex.Result">
        <short>The index in Controls, -1 if not found.</short>
      </element>
      <element name="TWinControl.GetControlIndex.AControl">
        <short>The (possible) child control.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element link="TWinControl.SetChildZPosition" name="TWinControl.SetControlIndex"/>
      <element name="TWinControl.SetControlIndex.AControl">
        <short/>
      </element>
      <element name="TWinControl.SetControlIndex.NewIndex">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.Focused">
        <short>Checks whether the control has the focus.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.Focused.Result">
        <short>True when we have the focus.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.PerformTab">
        <short>Sets the focus to the next (or preceding) control.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.PerformTab.Result">
        <short>True when the focus has been transferred.</short>
      </element>
      <element name="TWinControl.PerformTab.ForwardTab">
        <short>The direction of transfer: True for the next control in the TabOrder, False for the preceding control.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.FindChildControl">
        <short>Finds a child control by name.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.FindChildControl.Result">
        <short>True when the control has been found.</short>
      </element>
      <element name="TWinControl.FindChildControl.ControlName">
        <short>The Name of the control to find.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SelectNext">
        <short>Transfers the focus to the next child control.
        </short>
        <descr>
          <p>The search wraps around on the boundaries of the TabOrder array.
          </p>
          <p>When no next control can be found, the focus remains unchanged.
          </p>
        </descr>
        <errors/>
        <seealso>
          <link id="TWinControl.FindNextControl"/>
        </seealso>
      </element>
      <element name="TWinControl.SelectNext.CurControl">
        <short>The control which is assumed to have the focus.</short>
      </element>
      <element name="TWinControl.SelectNext.GoForward">
        <short>False when the control preceding CurControl shall be found.</short>
      </element>
      <element name="TWinControl.SelectNext.CheckTabStop">
        <short>When True, only select a control that can receive the focus.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TControl.SetTempCursor" name="TWinControl.SetTempCursor"/>
      <element name="TWinControl.SetTempCursor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.BroadCast">
        <short>Sends a message to all child controls.
        </short>
        <seealso>
          <link id="TWinControl.NotifyControls"/>
        </seealso>
      </element>
      <element name="TWinControl.BroadCast.ToAllMessage">
        <short>The message to send.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.NotifyControls">
        <short>Sends a message to all child controls.
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TWinControl.BroadCast"/>
        </seealso>
      </element>
      <element name="TWinControl.NotifyControls.Msg">
        <short>The message ID.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.DefaultHandler">
        <short>Handles all messages that the control doesn't fully handle itself.
        </short>
        <descr>
          <p>This implementation sends the message to the widget's message handler.
          </p>
          <p>Override this method to implement your own message handling.
            If the message Result is nonzero, the message already has been handled;
            otherwise set the Result to nonzero (depending on the message ID),
            when the message has been handled.
          </p>
        </descr>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.DefaultHandler">TObject.DefaultHandler</link>
        </seealso>
      </element>
      <element name="TWinControl.DefaultHandler.AMessage">
        <short>The message to process.</short>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Controls.TControl.GetTextLen" name="TWinControl.GetTextLen"/>
      <element name="TWinControl.GetTextLen.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.Invalidate">
        <short>Schedule an repaint request.
        </short>
        <descr>This implementation invokes the Invalidate method of the widget.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.AddControl">
        <short>Tell widgetset to add Handle object to parent's Handle object.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.InsertControl">
        <short>Insert control into Controls[].
        </short>
      </element>
      <element name="TWinControl.InsertControl.AControl">
        <short>The control to insert.</short>
      </element>
      <element name="TWinControl.InsertControl.Index">
        <short>Insert at index (optional).</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.RemoveControl">
        <short>Remove control from Controls[].</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.RemoveControl.AControl">
        <short>The control to remove.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TControl.Repaint" name="TWinControl.Repaint"/>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.Update" name="TWinControl.Update"/>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SetFocus">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.FlipChildren">
        <short>Flip children horizontally. That means mirroring the Left position and anchoring.
        </short>
        <descr>Child controls arranged in left-to-right order appear in right-to-left order after flipping.
          All anchors are adjusted accordingly.
        </descr>
        <errors/>
        <seealso>
          <link id="TWinControl.DoFlipChildren"/>
        </seealso>
      </element>
      <element name="TWinControl.FlipChildren.AllLevels">
        <short>Flip recursive?</short>
      </element>
      <!-- procedure Visibility: public -->
      <element link="TWinControl.ChangeScale" name="TWinControl.ScaleBy"/>
      <element name="TWinControl.ScaleBy.Multiplier">
        <short/>
      </element>
      <element name="TWinControl.ScaleBy.Divider">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.GetDockCaption">
        <short>Returns the caption for the docked control.</short>
      </element>
      <element name="TWinControl.GetDockCaption.Result">
        <short/>
      </element>
      <element name="TWinControl.GetDockCaption.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.UpdateDockCaption">
        <short>Updates the Caption to reflect the names of the docked clients.</short>
        <descr>
          <p>Called when this is a hostdocksite and either the list of docked clients have changed, or one of their captions.</p>
          <p>When a control is currently being undocked, but still is in the DockClients list, Exclude is set to this control.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.UpdateDockCaption.Exclude">
        <short>Control to exclude from the DockCaption.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.GetTabOrderList">
        <short>Fill the list with all TabStop controls, recursing into child controls.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.GetTabOrderList.List">
        <short>The list to which the controls shall be added.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.HandleAllocated">
        <short>Check whether a widget has been assigned to this control.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.HandleAllocated.Result">
        <short>True when a widget exists (Handle is not Nil).</short>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.ParentHandlesAllocated" name="TWinControl.ParentHandlesAllocated"/>
      <element name="TWinControl.ParentHandlesAllocated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.HandleNeeded">
        <short>Call this method when your code requires a valid Handle for this control.
        </short>
        <descr>
          <p>An attempt is made to create a widget, when not already done.</p>
          <remark>In certain situations it may be impossible to create a widget right now!</remark>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.BrushCreated">
        <short>Has a <link id="TWinControl.Brush">Brush</link>
          been created for this control?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.BrushCreated.Result">
        <short>True when a Brush has been created.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.EraseBackground">
        <short>Fills the entire control with the designed background color and pattern.
        </short>
        <descr>
          <p>This method can be called during Paint requests only, which provide an valid DC.
          </p>
          <p>The background may be transparent or non-rectangular as well!
          </p>
        </descr>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.EraseBackground.DC">
        <short>The device context to use; may be clipped to a certain shape.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.IntfUTF8KeyPress">
        <short>Called by the interface after the navigation and specials keys are handled;
          i.e. after KeyDown but before KeyPress.
        </short>
        <descr>Essentially expands an repeat count into multiple keystrokes,
          but not for SysKeys.
        </descr>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.Result">
        <short>True when multiple keystrokes have been processed.</short>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.UTF8Key">
        <short>The UTF-8 encoding of the character.</short>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.RepeatCount">
        <short>Must be greater than zero, the exact value is ignored</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.SystemKey">
        <short>Must be False, else nothing happens.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.PaintTo">
        <short>Paints only when a widget exists.</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>what?</note>
        </notes>
      </element>
      <element name="TWinControl.PaintTo.DC">
        <short/>
      </element>
      <element name="TWinControl.PaintTo.X">
        <short/>
      </element>
      <element name="TWinControl.PaintTo.Y">
        <short/>
      </element>
      <element name="TWinControl.PaintTo.ACanvas">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SetShape">
        <short>Specifies the (non-rectangular) shape of the widget.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TWinControl.SetShape.AShape">
        <short/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TWinControl.BorderStyle">
        <short>Allows to show a border (line) around the control,
        </short>
        <seealso>
          <link id="TWinControl.BorderWidth"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.BorderWidth">
        <short>Width of the Border around the control; default is zero.
        </short>
        <seealso>
          <link id="TWinControl.BorderStyle"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.BoundsLockCount">
        <short>For internal use: When greater zero, updates of the BoundsRect are blocked.
        </short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Brush">
        <short>The Brush used to paint the background of the control.
        </short>
        <seealso>
          <link id="#lcl.graphics.TBrush"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.CachedClientHeight">
        <short>The intended ClientHeight, as sent to the widget.
        </short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.CachedClientWidth">
        <short>The intended ClientWidth, as sent to the widget.
        </short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.ChildSizing">
        <short>Parameters for child control arrangement and spacing.
        </short>
        <seealso>
          <link id="#lcl.Controls.TControlChildSizing"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.ControlCount">
        <short>The number of immediate child controls.
        </short>
        <seealso>
          <link id="TWinControl.Controls"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Controls">
        <short>The indexed list of immediate child controls.</short>
        <descr>The index also indicates the Z-order of the children, zero for topmost
        </descr>
        <seealso>
          <link id="TWinControl.ControlCount"/>
        </seealso>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TWinControl.Controls.Index">
        <short>Index of the requested control.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DefWndProc">
        <short>The default WndProc on Windows widgetset and platforms.
        </short>
      <notes><note>Usage?</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockClientCount">
        <short>The number of clients docked into this control.</short>
        <descr>
          <p>The docked controls can be accessed in<link id="TWinControl.DockClients">DockClients[]</link>.</p>
          <p>
            <var>DockClientCount</var> is equivalent to DockClients.Count, but handles the special case when DockClients is Nil.</p>
        </descr>
        <seealso>
          <link id="TWinControl.DockClients"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockClients">
        <short>The indexed list of controls docked into this control.</short>
        <seealso>
          <link id="TWinControl.DockClientCount"/>
        </seealso>
      </element>
      <element name="TWinControl.DockClients.Index">
        <short>Index of the requested docked client.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockManager">
        <short>The docking layout manager for this control.</short>
        <descr>
          <p>A docksite can be managed (using an DockManager) or unmanaged (positioning docked controls in the event handlers).
            The DockManager determines the placement of docked controls,
            by setting DropOnControl and DropAlign before the drop,
            and by resizing and positioning the control when it's dropped.</p>
          <p>A DockManager is used only when UseDockManager also is True.
            Setting UseDockManager to True creates an DockManager of the DefaultDockManagerClass for this docksite, if none was previously installed.</p>
          <p>An unmanaged docksite, without an DockManager,
            can handle the placement of dropped controls in the OnDockOver and OnDockDrop event handlers.</p>
        </descr>
        <seealso>
          <link id="TWinControl.UseDockManager"/>
          <link id="TWinControl.DockSite"/>
          <link id="TWinControl.OnDockDrop"/>
          <link id="TWinControl.OnDockOver"/>
          <link id="TDockManager"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockSite">
        <short>Allows to drag-dock other controls into this control.
        </short>
        <descr>
          <p>A DockSite reacts on controls dragged over this control,
            signals acceptance and where a dragged control would be dropped.
          </p>
          <remark>A DockSite should initially be empty, not containing any child controls.
          </remark>
        </descr>
        <seealso>
          <link id="TWinControl.DockManager"/>
          <link id="TWinControl.UseDockManager"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DoubleBuffered">
        <short>Allows to reduce flicker in the painting of the control.</short>
        <descr>
          <p>Paint requests typically are buffered in the message queue.
            When a paint message arrives, all elements of the control are drawn onto the screen,
            according to their type, style, state and content.
          </p>
          <p>This can cause flicker, when stacked controls wipe out preceding paintings,
            e.g. when unchanged text is erased from the screen before it is painted again,
            when it takes some time to retrieve the text of list entries,
            or wrapping long text at the current control boundaries.
            Owner-drawing also can cause noticeable flicker.
          </p>
          <p>To reduce such flicker, DoubleBuffered controls use a buffer bitmap
            into which all painting is redirected.
            When the bitmap has been updated, a paint request is queued for the control.
            When that paint request is received again,
            the prepared bitmap is output in one fast BitBlt transfer, eliminating any flicker.
          </p>
          <p>All this happens automatically, when DoubleBuffered is set to True,
            no further changes are required in application or custom control code.
          </p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Handle">
        <short>A reference to the widget, associated with this control.
        </short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.IsResizing">
        <short>Check IsResizing and drop or delay changes to the control,
          until the new size has been determined.
        </short>
      </element>
      <element name="TWinControl.OnAlignInsertBefore">
        <short>Handler for custom-aligned child controls,
          determines the order of control placement.
        </short>
      </element>
      <element name="TWinControl.OnAlignPosition">
        <short>Handler for custom-aligned child controls,
          determines the position of the child control.
        </short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnDockDrop">
        <short>Notification handler for the drop of a control to be docked.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnDockOver">
        <short>Event handler for moves of a control over this docksite.
          Determines acceptance or rejection of an possible drop.
        </short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnEnter">
        <short>Handler for control receiving the focus.
        </short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnExit">
        <short>Handler for control loosing the focus.
          This is a good place for checking the finished user input.
        </short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TWinControl.OnGetDockCaption">
        <short>This handler can provide a special DockCaption,
          different from the Caption default.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TWinControl.OnGetSiteInfo">
        <short>Provides information about the DockSite.
        </short>
        <descr>
          <p>The handler can adjust the InfluenceRect,
            within which mouse moves are recognized by this control.
          </p>
          <p>The handler also can deny any drops, depending on the type of the dragged control.
          </p>
          <p>This event occurs before OnDockOver.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnDockOver"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnKeyDown">
        <short>Handler for
          keyboard key pressed.
        </short>
        <descr>
          <p>This handler can filter keys, for special use in e.g. non-textual controls.
          </p>
          <p>The handler receives all keystrokes, including control and other non-visual keys.
            Keys are encoded as <b>virtual</b> keys, with separate active modifier keys.
          </p>
          <p>Text input instead should be checked in an OnKeyPress handler.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyUp"/>
          <link id="TWinControl.OnKeyPress"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnKeyPress">
        <short>Handler for a character entered by the user.
        </short>
        <descr>
          <p>This handler only receives characters, not control or other special keycodes.
            Control keys should be handled by an OnKeyDown handler instead.
          </p>
          <p>The handler can convert the character into a different one.
          </p>
          <remark>We recommend you to use OnUTF8KeyPress to prevent data loss.
            Characters are converted from UTF8 to the system encoding in OnKeyPressEvent,
            with possible loss of characters outside the Ansi codepage.
          </remark>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyDown"/>
          <link id="TWinControl.OnUTF8KeyPress"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnKeyUp">
        <short>Handler for
          keyboard key released.
        </short>
        <descr>
          <p>Unlike OnKeyDown, this event occurs only once for auto-repeated keys.
          </p>
          <p>For details see <link id="TWinControl.OnKeyDown"/>.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyDown"/>
          <link id="TWinControl.OnKeyPress"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnUnDock">
        <short>Event handler for control being undocked from this DockSite.</short>
        <descr>
          <p>The handler can disallow undocking.
          </p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnUTF8KeyPress">
        <short>Handler for a character entered by the user.
        </short>
        <descr>
          <p>This handler only receives characters, not control or other special keycodes.
            Control keys should be handled by an OnKeyDown handler instead.
          </p>
          <p>The handler can convert the character into a different one.
          </p>
          <p>While <link id="TWinControl.OnKeyPress">OnKeyPress</link>
            only receives Ansi characters,
            with possible loss of characters outside the Ansi codepage,
            the OnUTF8KeyPress handler receives the UTF-8 character code.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyDown"/>
          <link id="TWinControl.OnKeyPress"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.ParentWindow">
        <short>The Handle of the parent widget.</short>
        <descr/>
        <seealso/>
      <notes><note>Usage?</note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Showing">
        <short>Cached widget visibility, not necessarily in sync with the widget.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.TabOrder">
        <short>Determines the sequence of controls, reachable when the user presses the Tab key.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.TabStop"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.TabStop">
        <short>Allows the user to navigate to this control, by pressing the Tab key.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.TabOrder"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.UseDockManager">
        <short>Determines whether a DockManager is used for this DockSite.
        </short>
        <descr>
          <p>When this property becomes True, and DockSite also is True,
            a DockManager is created automatically.
          </p>
          <p>When False an eventually existing DockManager is ignored.
          </p>
          <p>If you want to use an special DockManager,
            install it before setting UseDockManager to True.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DockSite"/>
          <link id="TWinControl.DockManager"/>
          <link id="TWinControl.CreateDockManager"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.VisibleDockClientCount">
        <short>The number of visible docked controls.</short>
        <seealso>
          <link id="TWinControl.DockClientCount"/>
          <link id="TWinControl.DockClients"/>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TWinControl.WindowHandle">
        <short>For internal use: allows direct access to Handle, bypassing any getter/setter methods.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TGraphicControl">
        <short>
          <var>TGraphicControl</var> is the base class for all lightweight controls.</short>
        <descr>
          <p>
            <var>TGraphicControl</var> supports simple lightweight controls
            that do not need the ability to accept keyboard input or contain other controls.
          </p>
          <p>If you want to accept keyboard input, or need to support child controls,
            use a <var>TCustomControl</var> instead.
          </p>
          <p>Since lightweight controls do not wrap GUI widgets,
            they use fewer resources than controls based on
            <var>TWinControl</var>.
          </p>
          <p>
            <var>TGraphicControl</var> provides a
            
            
            <var>Canvas</var> property for access to the control's drawing surface
            and a virtual 
            
            <var>Paint</var> method and an 
            
            <var>OnPaint</var> handler,
            called in response to paint requests received by the parent control.
          </p>
          <p>Override the Paint method or supply your own OnPaint handler,
            to do the actual drawing of the control.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TCustomControl"/>
          <link id="TGraphicControl.Paint"/>
          <link id="TGraphicControl.OnPaint"/>
          <link id="#lcl.Graphics.TCanvas"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element link="TGraphicControl.Canvas" name="TGraphicControl.FCanvas"/>
      <element link="TGraphicControl.OnPaint" name="TGraphicControl.FOnPaint"/>
      <!-- procedure Visibility: private -->
      <element name="TGraphicControl.WMPaint">
        <short>Event handler for paint messages.</short>
      </element>
      <element name="TGraphicControl.WMPaint.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass" name="TGraphicControl.WSRegisterClass"/>
      <element link="#LCL.Controls.TControl.FontChanged" name="TGraphicControl.FontChanged"/>
      <element name="TGraphicControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphicControl.Paint">
        <short>Override this method with your own painting code.
        </short>
        <descr>The default implementation invokes the OnPaint handler.
        </descr>
        <seealso>
          <link id="TGraphicControl.OnPaint"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.DoOnChangeBounds" name="TGraphicControl.DoOnChangeBounds"/>
      <!-- procedure Visibility: protected -->
      <element name="TGraphicControl.DoOnParentHandleDestruction"/>
      <!-- procedure Visibility: public -->
      <element name="TGraphicControl.Update"/>
      <!-- constructor Visibility: public -->
      <element name="TGraphicControl.Create"/>
      <element name="TGraphicControl.Create.AOwner"/>
      <!-- destructor Visibility: public -->
      <element name="TGraphicControl.Destroy"/>
      <!-- property Visibility: public -->
      <element name="TGraphicControl.Canvas">
        <short>A clipped window into the parent Canvas.</short>
        <descr>
          <p>Don't paint on the entire Canvas!
            Instead use the dimensions of the <var>TGraphicControl</var>
            stored in the <var>ClientRect</var>.
          </p>
          <p>If you ask for the <var>Canvas.Width</var> or <var>Canvas.Height</var>,
            you are actually getting the Parent control's Canvas dimensions.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TControl.ClientWidth"/>
          <link id="TControl.ClientHeight"/>
          <link id="#lcl.Graphics.TCanvas">TCanvas</link>
          <link id="TControl.BoundsRect"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphicControl.OnPaint">
        <short>Supply your own OnPaint handler for painting the control.
        </short>
        <seealso>
          <link id="TGraphicControl.Paint"/>
        </seealso>
      </element>
      <!-- object Visibility: default -->
      <element name="TCustomControl">
        <short>The base class for windowed controls which paint themselves.
        </short>
        <descr>
          <p>In contrast to TGraphicControl,
            a TCustomControl can accept keyboard input (get the Focus)
            and can have child controls.
          </p>
          <p>Override the Paint method or supply your own OnPaint handler,
            to do the actual drawing of the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl"/>
          <link id="TGraphicControl"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element link="TCustomControl.Canvas" name="TCustomControl.FCanvas"/>
      <element link="TCustomControl.OnPaint" name="TCustomControl.FOnPaint"/>
      <element link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass" name="TCustomControl.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element name="TCustomControl.WMPaint">
        <short>Event handler for paint messages.</short>
      </element>
      <element name="TCustomControl.WMPaint.Message">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TWinControl.DestroyWnd" name="TCustomControl.DestroyWnd"/>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TWinControl.PaintWindow" name="TCustomControl.PaintWindow">
        <short>The Paint handler plug-in, intercepting paint requests.</short>
        <descr>PaintWindow prepares the Canvas for painting,
          and invokes the Paint method to do the actual painting.
        </descr>
        <seealso>
          <link id="TWinControl.PaintWindow"/>
        </seealso>
      </element>
      <element name="TCustomControl.PaintWindow.DC">
        <short>The Device Context in which to paint.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.FontChanged" name="TCustomControl.FontChanged"/>
      <element name="TCustomControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.SetColor" name="TCustomControl.SetColor"/>
      <element name="TCustomControl.SetColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomControl.Paint">
        <short>Override this method in your derived class with your own paint handler.
        </short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TCustomControl.Create"/>
      <element name="TCustomControl.Create.AOwner"/>
      <!-- destructor Visibility: public -->
      <element name="TCustomControl.Destroy"/>
      <!-- property Visibility: public -->
      <element link="#LCL.Controls.TWinControl.BorderStyle" name="TCustomControl.BorderStyle"/>
      <!-- property Visibility: public -->
      <element name="TCustomControl.Canvas">
        <short>The drawing surface for the control,
          see <link id="#lcl.Graphics.TCanvas">TCanvas</link> for details.
        </short>
        <descr/>
        <seealso>
          <link id="#lcl.Graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomControl.OnPaint">
        <short>Supply your own OnPaint handler for painting the control.
        </short>
        <seealso>
          <link id="TCustomControl.Paint"/>
        </seealso>
      </element>
      <!-- object Visibility: default -->
      <element link="TDragImageList" name="TImageList"/>
      <!-- property Visibility: published -->
      <element link="#lcl.ImgList.TCustomImageList.AllocBy" name="TImageList.AllocBy"/>
      <element link="#LCL.ImgList.TCustomImageList.BkColor" name="TImageList.BkColor"/>
      <element link="#lcl.ImgList.TCustomImageList.BlendColor" name="TImageList.BlendColor"/>
      <element link="#LCL.ImgList.TCustomImageList.DrawingStyle" name="TImageList.DrawingStyle"/>
      <element link="#LCL.ImgList.TCustomImageList.Height" name="TImageList.Height"/>
      <element link="#LCL.ImgList.TCustomImageList.ImageType" name="TImageList.ImageType"/>
      <element link="#LCL.ImgList.TCustomImageList.Masked" name="TImageList.Masked"/>
      <element link="#LCL.ImgList.TCustomImageList.OnChange" name="TImageList.OnChange"/>
      <element link="#LCL.ImgList.TCustomImageList.ShareImages" name="TImageList.ShareImages"/>
      <element link="#LCL.ImgList.TCustomImageList.Width" name="TImageList.Width"/>
      <!-- object Visibility: default -->
      <element name="TControlPropertyStorage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlPropertyStorage.GetPropertyList">
        <short>Parses the <link id="TControl.SessionProperties"/> string
          into the given list.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TControlPropertyStorage.GetPropertyList.List">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDockZone">
        <short>Represents an node in an <link id="#lcl.Controls.TDockTree">TDockTree</link>.</short>
        <descr>
          <p>It encapsulates a dock zone, containing either other zones or a single control.
          </p>
          <p>This implementation is specific to <link id="TDockTree"/>/LDockTree. Every DockManager can (should!) use its own class instead.
          </p>
        </descr>
      </element>
      <!-- variable Visibility: private -->
      <element link="TDockZone.Bounds" name="TDockZone.FBounds"/>
      <element link="TDockZone.ChildControl" name="TDockZone.FChildControl"/>
      <element link="TDockZone.ChildCount" name="TDockZone.FChildCount"/>
      <element link="TDockZone.FirstChild" name="TDockZone.FFirstChildZone"/>
      <element link="TDockZone.NextSibling" name="TDockZone.FNextSibling"/>
      <element link="TDockZone.Orientation" name="TDockZone.FOrientation"/>
      <element link="TDockZone.Parent" name="TDockZone.FParentZone"/>
      <element link="TDockZone.PrevSibling" name="TDockZone.FPrevSibling"/>
      <element link="TDockZone.Tree" name="TDockZone.FTree"/>
      <!-- function Visibility: private -->
      <element link="TDockZone.Height" name="TDockZone.GetHeight"/>
      <element name="TDockZone.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TDockZone.Left" name="TDockZone.GetLeft"/>
      <element name="TDockZone.GetLeft.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TDockZone.LimitBegin" name="TDockZone.GetLimitBegin"/>
      <element name="TDockZone.GetLimitBegin.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TDockZone.LimitSize" name="TDockZone.GetLimitSize"/>
      <element name="TDockZone.GetLimitSize.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TDockZone.Top" name="TDockZone.GetTop"/>
      <element name="TDockZone.GetTop.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TDockZone.Visible" name="TDockZone.GetVisible"/>
      <element name="TDockZone.GetVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetVisibleChildCount">
        <short>The number of visible children.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.GetVisibleChildCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TDockZone.Width" name="TDockZone.GetWidth"/>
      <element name="TDockZone.GetWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetNextVisibleZone">
        <short>The next visible zone.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.GetNextVisibleZone.Result">
        <short>The zone, or Nil if none found.</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDockZone.Create"/>
      <element name="TDockZone.Create.TheTree">
        <short>The dock tree to which this zone belongs.</short>
      </element>
      <element name="TDockZone.Create.TheChildControl">
        <short>The control in this zone (may be Nil).</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.FindZone">
        <short>Returns the Dockzone containing the given control.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.FindZone.Result">
        <short>The zone containing AControl as ChildControl.</short>
      </element>
      <element name="TDockZone.FindZone.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.AddAsFirstChild">
        <short>Adds the given zone as the first child.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.AddAsFirstChild.NewChildZone">
        <short>The zone to add.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.AddAsLastChild">
        <short>Adds the given zone as the last child.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.AddAsLastChild.NewChildZone">
        <short>The zone to add.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.ReplaceChild">
        <short>Replace the
          <var>OldChild</var> zone by
          <var>NewChild</var>.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.ReplaceChild.OldChild">
        <short>The zone to unlink.</short>
      </element>
      <element name="TDockZone.ReplaceChild.NewChild">
        <short>The zone to link in place of OldChild.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.GetLastChild">
        <short>The last child zone.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.GetLastChild.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.GetIndex">
        <short>Calculates the index of the zone within its parent zone.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.GetIndex.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.Remove">
        <short>Unlinks the given child zone.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockZone.Remove.ChildZone">
        <short/>
      </element>
      <element name="TDockZone.AddSibling">
        <short>Inserts NewZone as preceding or following sibling.</short>
        <descr/>
      </element>
      <element name="TDockZone.AddSibling.NewZone">
        <short>The zone to add.</short>
      </element>
      <element name="TDockZone.AddSibling.InsertAt">
        <short>How to add the zone.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.NextSibling">
        <short>The next sibling zone.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.PrevSibling">
        <short>The preceding sibling zone.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.FirstVisibleChild">
        <short>The first visible child zone.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.FirstVisibleChild.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.NextVisible">
        <short>The next visible zone.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.NextVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.PrevVisible">
        <short>The preceding visible zone.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.PrevVisible.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Tree">
        <short>The dock tree of which this dock zone is a part.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.ChildControl">
        <short>The control docked in this zone.</short>
        <descr>A zone can contain nothing, a control, or child zones.
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.ChildCount">
        <short>The number of child zones.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.FirstChild">
        <short>The first child zone.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Height">
        <short>The height of the zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element link="TDockZone.Height" name="TDockZone.SetHeight"/>
      <element name="TDockZone.SetHeight.AValue">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Left">
        <short>The left coordinate of the zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element link="TDockZone.Left" name="TDockZone.SetLeft"/>
      <element name="TDockZone.SetLeft.AValue">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.LimitBegin">
        <short>The free coordinate of the DockZone (Left or Top).</short>
        <descr/>
        <seealso/>
      </element>
      <element link="TDockZone.LimitBegin" name="TDockZone.SetLimitBegin"/>
      <element name="TDockZone.SetLimitBegin.AValue">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.LimitSize">
        <short>The free size of the DockZone (Width or Height).</short>
        <descr/>
        <seealso/>
      </element>
      <element link="TDockZone.LimitSize" name="TDockZone.SetLimitSize"/>
      <element name="TDockZone.SetLimitSize.AValue">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element link="TDockOrientation" name="TDockZone.Orientation">
        <short>Whether docking is oriented vertically, horizontally, in pages, or not at all</short>
        <descr>
          <ul>
            <li>doNoOrient: zone contains a TControl and no child zones.</li>
            <li>doHorizontal: zone's children are stacked top-to-bottom.</li>
            <li>doVertical: zone's children are arranged left-to-right.</li>
            <li>doPages: zone's children are pages arranged left-to-right.</li>
          </ul>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Parent">
        <short>The parent zone in the DockTree.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Top">
        <short>The top coordinate of this zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element link="TDockZone.Top" name="TDockZone.SetTop"/>
      <element name="TDockZone.SetTop.AValue">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Visible">
        <short>A zone is visible if it contains a visible control, or if any child zone is visible.
        </short>
        <descr/>
        <seealso>
          <link id="TDockZone.VisibleChildCount"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.VisibleChildCount">
        <short>The number of visible child zones.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Width">
        <short>The width of this zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element link="TDockZone.Width" name="TDockZone.SetWidth"/>
      <element name="TDockZone.SetWidth.AValue">
        <short/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TDockZoneClass">
        <short>Class of <link id="TDockZone"/>.</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TForEachZoneProc">
        <short>The type of an ForEachZone callback procedure, currently unused.
        </short>
        <descr/>
        <seealso/>
      <notes><note>unused?</note>
        </notes>
      </element>
      <element name="TForEachZoneProc.Zone">
        <short>The iterated zone.
        </short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDockTreeFlag">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDockTreeFlag.dtfUpdateAllNeeded">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- set type Visibility: default -->
      <element link="TDockTreeFlag" name="TDockTreeFlags"/>
      <!-- object Visibility: default -->
      <element name="TDockTree">
        <short>A docking manager for tree-style layouts.</short>
        <descr>
          <p>A tree-style layout is organized in layers of a specific (horizontal or vertical) orientation.
            Every node in the tree is either a container for other nodes,
            or represents a zone with a single docked control.
            All child zones of an node have the same DockOrientation.
          </p>
          <p>The following documentation is copied from the Controls unit.
            It is of historical interest only, since it effectively describes the AnchorDocking,
            implemented in TCustomAnchoredDockManager.
            AnchorDocking is not related to visual drag-dock procedures,
            it merely is an attempt to implement just an layout manager.
          <br/>[todo: make this description an topic]
          </p>
          <remark>The TLazDockTree implementation never was finished,
            due to problems with the anchor "docking" mechanism.
            Use the EasyDockManager (examples/dockmanager) instead.</remark>
          <pre>This is an abstract class. A real implementation is e.g. in ldocktree.pas.

    Docking means here: Combining several windows to one. A window can here be
    a TCustomForm or a floating control (undocked) or a TDockForm.
    A window can be docked to another to the left, right, top, bottom or "into".
    The docking source window will be resized, to fit to the docking target
    window.

    Example1: Docking "A" (source window) left to "B" (target window)
    
       +---+    +----+
       | A | -&gt; | B  |
       +---+    |    |
                +----+
      Result: A new docktree will be created. Height of "A" will be resized to
              the height of "B".
              A splitter will be inserted between "A" and "B".
              And all three are children of the newly created TLazDockForm of the
              newly created TDockTree.
      
       +------------+
       |+---+|+----+|
       || A ||| B  ||
       ||   |||    ||
       |+---+|+----+|
       +------------+

      If "A" or "B" were floating controls, the floating dock sites are freed.
      If "A" or "B" were forms, their decorations (title bars and borders) are
      replaced by docked decorations.
      If "A" had a TDockTree, it is freed and its child dockzones are merged to
      the docktree of "B". Analog for docking "C" left to "A":
      
       +------------------+
       |+---+|+---+|+----+|
       || C ||| A ||| B  ||
       ||   |||   |||    ||
       |+---+|+---+|+----+|
       +------------------+
       

      
    Example2: Docking A into B
                +-----+
       +---+    |     |
       | A | ---+-&gt; B |
       +---+    |     |
                +-----+

      Result: A new docktree will be created. "A" will be resized to the size
              of "B". Both will be put into a TLazDockPages control which is the
              child of the newly created TDockTree.
              
       +-------+
       |[B][A] |
       |+-----+|
       ||     ||
       || A   ||
       ||     ||
       |+-----+|
       +-------+

    Every DockZone has siblings and children. Siblings can either be
    - horizontally (left to right, splitter),
    - vertically (top to bottom, splitter)
    - or upon each other (as notebook pages).


    InsertControl - undock control and dock it into the dock site. For example
                    dock Form1 left to a Form2:
                    InsertControl(Form1,alLeft,Form2);
                    To dock "into", into a TDockPage, use Align=alCustom.
    PositionDockRect - calculates where a control would be placed, if it would
                       be docked via InsertControl.
    RemoveControl - removes a control from the dock site.

    GetControlBounds - TODO for Delphi compatibility
    ResetBounds - TODO for Delphi compatibility
    SetReplacingControl - TODO for Delphi compatibility
    PaintSite - TODO for Delphi compatibility

</pre>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TDockManager"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FBorderWidth">
        <short>The width of the border around a dock zone.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element link="TDockTree.DockSite" name="TDockTree.FDockSite"/>
      <element link="TDockTree.DockZoneClass" name="TDockTree.FDockZoneClass"/>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FFlags">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- variable Visibility: private -->
      <element link="TDockTree.RootZone" name="TDockTree.FRootZone"/>
      <element link="TDockTree.BeginUpdate" name="TDockTree.FUpdateCount"/>
      <!-- procedure Visibility: private -->
      <element link="TDockTree.DockSite" name="TDockTree.SetDockSite"/>
      <element name="TDockTree.SetDockSite.AValue">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockTree.RootZone">
        <short>The root zone of the DockTree.</short>
        <descr/>
        <seealso/>
      </element>
      <element link="#LCL.Controls.TDockManager.MouseMessage" name="TDockTree.MouseMessage"/>
      <!-- procedure Visibility: private -->
      <element name="TDockTree.DeleteZone">
        <short>Destroys the zone and its child zones.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockTree.DeleteZone.Zone">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.AdjustDockRect">
        <short>Adjusts the zone rectangle for AControl.</short>
        <descr>
          <p>ARect initially describes the dockzone into which the control is docked.
            From that area the zone decoration is excluded, so that ARect describes the area reserved for the docked control.</p>
          <p>AdjustDockRect is not part of the general docking model.
            It can implemented and used for any purpose in a dock tree manager.
            Most docking managers will replace it by a method with more arguments, that allow to identify the zone and its properties immediately.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockTree.AdjustDockRect.AControl">
        <short/>
      </element>
      <element name="TDockTree.AdjustDockRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.BeginUpdate" name="TDockTree.BeginUpdate"/>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.EndUpdate" name="TDockTree.EndUpdate"/>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.GetControlBounds" name="TDockTree.GetControlBounds"/>
      <element name="TDockTree.GetControlBounds.AControl">
        <short/>
      </element>
      <element name="TDockTree.GetControlBounds.ControlBounds">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDockTree.HitTest">
        <short>Returns the control and the part of the dockzone, at the given coordinates.
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockTree.HitTest.Result">
        <short>The docked control.</short>
      </element>
      <element name="TDockTree.HitTest.MousePos">
        <short>The client coordinates.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TDockTree.HitTest.HTFlag">
        <short>Returns the zone part at MousePos.</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.InsertControl">
        <short>Positions <var>DropCtl</var> relative <var>Control</var>, using the alignment specified by <var>InsertAt.</var>
        </short>
        <descr>
          <p>InsertControl determines the layout and appearance of the just docked control, forcing a repaint of the container control if necessary.</p>
          <p>When SetReplacingControl has been called with a non-Nil Control before, the dropped control only should replace that control.</p>
          <p>A tree docking manager organizes the docksite into layers of horizontol or vertical orientation.
            As long as no more than one control is docked into a docksite, the tree has no orientation at all.
            The second docked control determines the orientation of the docksite and the dock tree.
            All further drops are either isogonal (in direction of the zone orientation) or orthogonal (opposite to the zone orientation).
            On an isogonal drop a new leaf zone is created for the dropped control, as a sibling of the already existing child zones.
            On an orthogonal drop the zone containing the DropControl becomes the root of another subtree, whose initial members are the leaf zones for Control and DropCtl.</p>
          <p>One value of InsertAt (alCustom) is reserved for notebook docking, where DropCtl is replaced by a tabbed notebook, and Control and DropCtl are moved into pages of the notebook.
            The notebook is a docksite of its own, further drops into the notebook are handled by the notebook itself, the DockManager of the host docksite is not involved.</p>
        </descr>
        <errors/>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockTree.InsertControl.AControl">
        <short>The control beneath which to place DropControl.</short>
      </element>
      <element name="TDockTree.InsertControl.InsertAt">
        <short>How to insert DropControl.</short>
      </element>
      <element name="TDockTree.InsertControl.DropControl">
        <short>The control to add.</short>
      </element>
      <element name="TDockTree.DumpLayout">
        <short>Stores the layout in an file.</short>
      </element>
      <element name="TDockTree.DumpLayout.FileName">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TDockManager.LoadFromStream" name="TDockTree.LoadFromStream"/>
      <element name="TDockTree.LoadFromStream.SrcStream">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="TDockManager.MessageHandler" name="TDockTree.MessageHandler"/>
      <element name="TDockTree.MessageHandler.Sender">
        <short/>
      </element>
      <element name="TDockTree.MessageHandler.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.PaintDockFrame">
        <short>Paints the dock header of the zone containing AControl.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDockTree.PaintDockFrame.ACanvas">
        <short/>
      </element>
      <element name="TDockTree.PaintDockFrame.AControl">
        <short/>
      </element>
      <element name="TDockTree.PaintDockFrame.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TDockManager.PositionDockRect" name="TDockTree.PositionDockRect"/>
      <element name="TDockTree.PositionDockRect.AClient">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DropCtl">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DropAlign">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DockRect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TDockManager.RemoveControl" name="TDockTree.RemoveControl"/>
      <element name="TDockTree.RemoveControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TDockManager.SaveToStream" name="TDockTree.SaveToStream"/>
      <element name="TDockTree.SaveToStream.DestStream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TDockManager.SetReplacingControl" name="TDockTree.SetReplacingControl"/>
      <element name="TDockTree.SetReplacingControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TDockManager.ResetBounds" name="TDockTree.ResetBounds"/>
      <element name="TDockTree.ResetBounds.Force">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.UpdateAll">
        <short>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>to do what?</note>
        </notes>
      </element>
      <!-- property Visibility: protected -->
      <element name="TDockTree.DockSite">
        <short>The parent control whose docked clients are managed.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDockTree.Create"/>
      <element name="TDockTree.Create.TheDockSite">
        <short>The window control to be managed.</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TDockTree.Destroy"/>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TDockManager.PaintSite" name="TDockTree.PaintSite"/>
      <element name="TDockTree.PaintSite.DC">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockTree.DockZoneClass">
        <short>The class of all dock zones in this tree.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="TDockTree.DockZoneClass" name="TDockTree.SetDockZoneClass"/>
      <element name="TDockTree.SetDockZoneClass.AValue">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TMouse">
        <short>Some properties of the Mouse.</short>
        <descr>Contains information about current mouse position,
          whether messages are captured by a window,
          whether it is dragging an object,
          and how far the mouse must move before a control starts dragging.</descr>
      </element>
      <!-- variable Visibility: default -->
      <element link="TMouse.Capture" name="TMouse.FCapture"/>
      <element name="TMouse.FDragImmediate"/>
      <element name="TMouse.FDragThreshold"/>
      <element name="TMouse.FWheelScrollLines"/>
      <!-- procedure Visibility: default -->
      <element link="TMouse.Capture" name="TMouse.SetCapture"/>
      <element name="TMouse.SetCapture.Value">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element link="TMouse.Capture" name="TMouse.GetCapture"/>
      <element name="TMouse.GetCapture.Result">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element link="TMouse.CursorPos" name="TMouse.GetCursorPos"/>
      <element name="TMouse.GetCursorPos.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TMouse.CursorPos" name="TMouse.SetCursorPos"/>
      <element name="TMouse.SetCursorPos.AValue">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TMouse.WheelScrollLines" name="TMouse.GetWheelScrollLines"/>
      <element name="TMouse.GetWheelScrollLines.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TMouse.DragImmediate" name="TMouse.GetDragImmediate"/>
      <element name="TMouse.GetDragImmediate.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TMouse.DragImmediate" name="TMouse.SetDragImmediate"/>
      <element name="TMouse.SetDragImmediate.AValue">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="TMouse.DragThreshold" name="TMouse.GetDragThreshold"/>
      <element name="TMouse.GetDragThreshold.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element link="TMouse.DragThreshold" name="TMouse.SetDragThreshold"/>
      <element name="TMouse.SetDragThreshold.AValue">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element link="TMouse.IsDragging" name="TMouse.GetIsDragging"/>
      <element name="TMouse.GetIsDragging.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TMouse.Create"/>
      <!-- destructor Visibility: public -->
      <element name="TMouse.Destroy"/>
      <!-- property Visibility: public -->
      <element name="TMouse.Capture">
        <short>Handle of the capturing control.</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.CursorPos">
        <short>The screen position of the cursor.</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.DragImmediate">
        <short>Does dragging start immediately (True), or only after a mouse move?</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.DragThreshold">
        <short>The minimum distance the mouse must move before dragging starts (in delayed mode).</short>
        <descr>Default is 5 pixels</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.IsDragging">
        <short>True while dragging an object.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.WheelScrollLines">
        <short>The number of lines to scroll with every notch of the mouse wheel.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: default -->
      <element link="FindControlAtPosition" name="FindDragTarget">
        <short>Get control at screen position.</short>
        <descr>Disabled controls <b>should</b> be excluded, but are not due to an bug in FindControlAtPosition.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="FindDragTarget.Result">
        <short>The control at Position; Nil if none.</short>
      </element>
      <element name="FindDragTarget.Position">
        <short>The screen position.</short>
      </element>
      <element name="FindDragTarget.AllowDisabled">
        <short>Also find disabled controls, if True.</short>
      </element>
      <!-- function Visibility: default -->
      <element name="FindControlAtPosition">
        <short>Get control at screen position.</short>
        <descr>When AllowDisabled is True, also a disabled control will be found. In the current implementation AllowDisabled is ignored (assumed to be True).
          First a window at the given screen position is searched,
          then a control within it.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="FindControlAtPosition.Result">
        <short>The control at Position; Nil if none.</short>
      </element>
      <element name="FindControlAtPosition.Position">
        <short>The screen position.</short>
      </element>
      <element name="FindControlAtPosition.AllowDisabled">
        <short>Also find disabled controls, if True.</short>
      </element>
      <!-- function Visibility: default -->
      <element name="FindLCLWindow">
        <short>Find the window and its owning control at the given screen coordinates.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="FindLCLWindow.Result">
        <short>The control at the ScreenPos; Nil if none was found.</short>
      </element>
      <element name="FindLCLWindow.ScreenPos">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindControl">
        <short>Return the TWinControl of the given Handle.</short>
        <descr>
          <p>The result is very interface specific. Use FindOwnerControl when Handle may be a non-TWinControl handle.</p>
        </descr>
        <seealso>
          <link id="FindOwnerControl"/>
        </seealso>
      </element>
      <element name="FindControl.Result">
        <short/>
      </element>
      <element name="FindControl.Handle">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindOwnerControl">
        <short>Returns the TWinControl for the given Handle; the parent control for a non-TWinControl Handle.</short>
        <descr>
          <p>Handle can also be a child handle (of a TControl), in which case the returned control is the parent of the desired control. Parent, not Owner as suggested by the function name!</p>
          <p>[Remark] The function recursively tries GetParent(Handle), so the result depends on the implementation (meaning) of a parent handle.</p>
        </descr>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="FindOwnerControl.Result">
        <short/>
      </element>
      <element name="FindOwnerControl.Handle">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindLCLControl">
        <short>Returns the TControl that currently is visible at a screen position.
        </short>
        <descr>The result is not reliable during resizing.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="FindLCLControl.Result">
        <short/>
      </element>
      <element name="FindLCLControl.ScreenPos">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element link="#LCL.LCLProc.SendApplicationMessage" name="SendAppMessage"/>
      <element name="SendAppMessage.Result">
        <short/>
      </element>
      <element name="SendAppMessage.Msg">
        <short/>
      </element>
      <element name="SendAppMessage.WParam">
        <short/>
      </element>
      <element name="SendAppMessage.LParam">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="MoveWindowOrg">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="MoveWindowOrg.dc">
        <short/>
      </element>
      <element name="MoveWindowOrg.X">
        <short/>
      </element>
      <element name="MoveWindowOrg.Y">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="RecreateWnd">
        <short>Create the widget for a TWinControl</short>
        <descr>
          <p>This function was originally member of TWincontrol.
          </p>
          <p>From a VCL point of view that made perfectly sense
            since the VCL knows when a win32 widget has to be recreated when properties have changed.
          </p>
          <p>The LCL however doesn't know, the widgetset does.
            To avoid old VCL behaviour and to provide a central function to the widgetset, it is moved here.
          </p>
        </descr>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="RecreateWnd.AWinControl">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="SetCaptureControl">
        <short>Set the mouse capture to AWinControl or its child at the given coordinates</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="SetCaptureControl.Control">
        <short/>
      </element>
      <element name="SetCaptureControl.AWinControl">
        <short/>
      </element>
      <element name="SetCaptureControl.Position">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GetCaptureControl">
        <short>Returns the current capturing TControl.
        </short>
        <descr>Note: For the interface only a Handle = TWinControl can capture.
          The LCL extends this to allow TControl capture the mouse.
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="GetCaptureControl.Result">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="CancelDrag">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="DragDone">
        <short>[Delphi compatible, dropped!]</short>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>Delphi compatible, dropped!</note>
        </notes>
      </element>
      <element name="DragDone.Drop">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="CursorToString">
        <short>Returns a string for the name of the cursor as identified by an integer constant</short>
        <descr>Calls CursorToIdent to find correct entry in look-up table</descr>
        <errors/>
        <seealso>
          <link id="#lcl.Controls.CursorToIdent"/>
        </seealso>
      </element>
      <element name="CursorToString.Result">
        <short>Returns a string with the name of the cursor type corresponding to the integer constant</short>
      </element>
      <element name="CursorToString.Cursor">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="StringToCursor">
        <short>
          <var>StringToCursor</var> - returns the cursor value corresponding to the name supplied</short>
        <descr>
          <p>
            <var>StringToCursor</var> - returns the cursor value corresponding to the name supplied</p>
          <p>Finds the numeric cursor value corresponding to the name <var>S</var> in the cursor look-up table</p>
        </descr>
      </element>
      <element name="StringToCursor.Result">
        <short>The numeric cursor value from the look-up table</short>
      </element>
      <element name="StringToCursor.S">
        <short>The name of the cursor for which the numeric value is sought</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="GetCursorValues">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="GetCursorValues.Proc">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="CursorToIdent">
        <short>Uses look-up table to find cursor identifier corresponding to integer cursor constant</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="CursorToIdent.Result">
        <short>Returns true if a valid entry is found in the look-up table</short>
      </element>
      <element name="CursorToIdent.Cursor">
        <short/>
      </element>
      <element name="CursorToIdent.Ident">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="IdentToCursor">
        <short>Searches the Cursor name table for the given cursor name; returns True if found.</short>
        <descr>If found, the cursor value (handle) is returned in <var>Cursor</var>.</descr>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="IdentToCursor.Result">
        <short>Returns True if a valid entry was found in the look-up table.</short>
      </element>
      <element name="IdentToCursor.Ident">
        <short>The name of the cursor for which the numeric value is sought.</short>
      </element>
      <element name="IdentToCursor.Cursor">
        <short>The numeric value of the named cursor.</short>
      </element>
      <!-- function Visibility: default -->
      <element name="GetKeyShiftState">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="GetKeyShiftState.Result">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="AdjustBorderSpace">
        <short>Adjust space round border of this control</short>
        <descr>
          <p>RemainingClientRect: remaining clientrect without CurBorderSpace</p>
          <p>CurBorderSpace: current borderspace around RemainingClientRect</p>
          <p>Left, Top, Right, Bottom: apply these borderspaces to CurBorderSpace</p>
          <p>CurBorderSpace will be set to the maximum of CurBorderSpace and Left, Top, Right, Bottom.</p>
          <p>RemainingClientRect will shrink.</p>
          <p>RemainingClientRect will not shrink to negative size.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="AdjustBorderSpace.RemainingClientRect">
        <short/>
      </element>
      <element name="AdjustBorderSpace.CurBorderSpace">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Left">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Top">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Right">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Bottom">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Space">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="IsColorDefault">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="IsColorDefault.Result">
        <short/>
      </element>
      <element name="IsColorDefault.AControl">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="BidiFlipAlignment">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="BidiFlipAlignment.Result">
        <short/>
      </element>
      <element name="BidiFlipAlignment.Alignment">
        <short/>
      </element>
      <element name="BidiFlipAlignment.Flip">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="BidiFlipAnchors">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="BidiFlipAnchors.Result">
        <short/>
      </element>
      <element name="BidiFlipAnchors.Control">
        <short/>
      </element>
      <element name="BidiFlipAnchors.Flip">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="BidiFlipRect">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="BidiFlipRect.Result">
        <short/>
      </element>
      <element name="BidiFlipRect.Rect">
        <short/>
      </element>
      <element name="BidiFlipRect.ParentRect">
        <short/>
      </element>
      <element name="BidiFlipRect.Flip">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="ChangeBiDiModeAlignment">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="ChangeBiDiModeAlignment.Alignment">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="Register">
        <short>Register the components provided by this unit or package, so that they can be instantiated.</short>
        <descr>Also can be used to register the controls required by an application.</descr>
        <seealso>
          <link id="#rtl.classes.registercomponents"/>
        </seealso>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- constant Visibility: default -->
      <element name="fsSurface">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="fsBorder">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvNone">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvLowered">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvRaised">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvSpace">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TCaptureMouseButtons">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PHintInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="THintInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintWindowClass">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintMaxWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.CursorRect">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.CursorPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.ReshowTimeout">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HideTimeout">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintStr">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintData">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetDockCaptionEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TGetDockCaptionEvent.Sender">
        <short/>
      </element>
      <element name="TGetDockCaptionEvent.AControl">
        <short/>
      </element>
      <element name="TGetDockCaptionEvent.ACaption">
        <short/>
      </element>
      <element link="TDragManager" name="TDragManagerDefault">
        <short>Implementation of TDragManager.</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragManager">
        <short>The abstract base class for managing the dragging of controls (to be dropped or docked).</short>
        <descr>
          <p>This is the OO version of the Delphi drag manager, implemented in TDragManagerDefault.</p>
          <remark>The registered dock sites should be stored in a persistent list, not in a DragManager instance.</remark>
          <p>[entire review DoDi 2010-02-16]</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragManager.FDragImmediate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragManager.FDragThreshold">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.KeyUp">
        <short>Handler for keyboard key released.</short>
        <descr>When the Ctrl key is released, a drop is enabled again.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.KeyUp.Key">
        <short/>
      </element>
      <element name="TDragManager.KeyUp.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.KeyDown">
        <short>Handler for keyboard key pressed.</short>
        <descr>
          <p>When (and while) the Ctrl key is pressed, dropping is disabled.</p>
          <p>The Esc key aborts the current dragging operation immediately.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.KeyDown.Key">
        <short/>
      </element>
      <element name="TDragManager.KeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.CaptureChanged">
        <short>Aborts the dragging operation, when the capturing control really has changed.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.CaptureChanged.OldCaptureControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.MouseMove">
        <short>Generates the visual feedback when the mouse moves.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseMove.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseMove.X">
        <short/>
      </element>
      <element name="TDragManager.MouseMove.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.MouseUp">
        <short>Ends dragging.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseUp.Button">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.X">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.MouseDown">
        <short>Nop.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseDown.Button">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.X">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.Y">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDragManager.Create">
        <short>Initializes the Delphi default dragging parameters.</short>
        <descr>
          <p>The Delphi VCL sets DragImmediate=True and DragThreshold=5.</p>
          <remark>A docking operation never should start immediately.</remark>
        </descr>
        <errors/>
      </element>
      <element name="TDragManager.Create.TheOwner">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragManager.IsDragging">
        <short>Check if dragging is in progress.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.IsDragging.Result">
        <short>True if dragging.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragManager.Dragging">
        <short>True if the specified control is being dragged.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.Dragging.Result">
        <short/>
      </element>
      <element name="TDragManager.Dragging.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.RegisterDockSite">
        <short>Adds the control to the list of registered docking sites.</short>
        <descr>
          <remark>This should become a class method, maintaining the list of registered docking sites outside any DragManager instance.</remark>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.RegisterDockSite.Site">
        <short>The DockSite to register.</short>
      </element>
      <element name="TDragManager.RegisterDockSite.DoRegister">
        <short>True for adding, False for removing the site.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.DragStart">
        <short>Starts dragging a control.</short>
        <descr>A DragObject must be created, depending on the Control.DragKind.
          The mouse has to be captured, and visual feedback must be initialized.</descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.DragStart.AControl">
        <short>The control that initiates the drag operation.</short>
      </element>
      <element name="TDragManager.DragStart.AImmediate">
        <short>False when dragging should start only when the mouse is moved (delayed).</short>
      </element>
      <element name="TDragManager.DragStart.AThreshold">
        <short>How much the mouse must move before delayed dragging starts.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.DragMove">
        <short>Updates the visual dragging feedback.</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.DragMove.APosition">
        <short>Mouse position in <b>screen</b> coordinates.</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.DragStop">
        <short>Ends dragging.</short>
        <descr>
          <p>The visual feedback is reset.</p>
          <p>All related controls are notified of the outcome of the operation (drop, dock, abort).</p>
          <p>Finally all temporary objects are destroyed.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <element name="TDragManager.DragStop.ADrop">
        <short>False when dragging was aborted.</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragManager.DragImmediate">
        <short>Start dragging immediately, on MouseDown?</short>
        <descr>This is the default value for e.g. BeginDrag.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragManager.DragThreshold">
        <short>The threshold amount by which the mouse must move before delayed dragging starts. (default 5 pixels)</short>
        <seealso/>
      </element>
      <element name="TDragDockCommon.SendDragMessage">
        <short>sends to AControl a drag message at specified position for nominated object; returns an integer Result for success</short>
      </element>
      <element name="TDragDockCommon.SendCmDragMsg">
        <short>
          <var>SendCmDragMsg</var> - sends to DragTarget a drag message at specified position for nominated object; returns True for success</short>
        <descr>The Result is used to select the DragCursor (deny/accept drop).</descr>
      </element>
      <element name="TDockPerformer.DragMove.FindDockSiteAtPosition">
        <short>Find a DockSite under the current mouse position.</short>
        <descr>
          <p>The list of registered docksites is searched. Sites are excluded when they are invisible or disabled, or when the site is (a child of) the dragged control.</p>
          <p>The Z-order of the docksites should be taken into account. Currently the first site found is returned.</p>
        </descr>
      </element>
      <element name="TDockPerformer.DragMove.GetDropControl">
        <short>Determine the target control within the target DockSite.</short>
        <descr>
          <p>Do nothing (return Nil) unless a DockManager is installed in the target site and something has already been docked.</p>
          <p>When the dragged control is the only client of the docksite, Nil is returned.</p>
          <p>[ToDo: The check for an drop of a control onto itself should be done in every case, after the target control has been determined.]</p>
        </descr>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlCellAlign">
        <short>Modes for aligning a control in a table cell.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaFill">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaLeftTop">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaRightBottom">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaCenter">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- set type Visibility: default -->
      <element link="TControlCellAlign" name="TControlCellAligns"/>
      <!-- enumeration type Visibility: default -->
      <element name="TAnchorSideChangeOperation">
        <short>Operations in <link id="TControl.ForeignAnchorSideChanged"/>.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSideChangeOperation.ascoAdd">
        <short>AnchorSide added.</short>
      </element>
      <element name="TAnchorSideChangeOperation.ascoRemove">
        <short>AnchorSide removed.</short>
      </element>
      <element name="TAnchorSideChangeOperation.ascoChangeSide">
        <short>AnchorSide changed.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TChildControlResizeStyle">
        <short>Modes for resizing child controls.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TChildControlResizeStyle.crsAnchorAligning">
        <short>Using <link id="TControl.Anchors"/> (Delphi compatible).</short>
      </element>
      <element name="TChildControlResizeStyle.crsScaleChilds">
        <short>Scale children, keep space between children fixed.</short>
      </element>
      <element name="TChildControlResizeStyle.crsHomogenousChildResize">
        <short>Enlarge children equally, i.e. by the same amount of pixels.</short>
      </element>
      <element name="TChildControlResizeStyle.crsHomogenousSpaceResize">
        <short>Enlarge space between children equally.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlChildrenLayout">
        <short>Modes for wrapping controls.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlChildrenLayout.cclNone">
        <short>No wrapping</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlChildrenLayout.cclLeftToRightThenTopToBottom">
        <short>Arrange in rows If BiDiMode not bdLeftToRight then it becomes RightToLeft.</short>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="TControlChildrenLayout.cclTopToBottomThenLeftToRight">
        <short>Arrange in columns</short>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlAtPosFlag">
        <short>Flags for finding a control at given (client) position.</short>
        <descr>capfAllowDisabled: include disabled controls.
          capfAllowWinControls: do not find WinControls if False.
          capfOnlyClientAreas: hit client areas only.
          capfRecursive: search into child controls.
          capfHasScrollOffset: scroll offset is already included in the coordinates.
        </descr>
        <seealso>
          <link id="TWinControl.ControlAtPos"/>
        </seealso>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfAllowDisabled">
        <short>If set: include disabled controls.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfAllowWinControls">
        <short>If set: include TWinControls, in addition to TControls.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfOnlyClientAreas">
        <short>If set: hit client areas only.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfRecursive">
        <short>If set: recurse into grand children.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfHasScrollOffset">
        <short>If set: scroll offset is already included in the coordinates.</short>
      </element>
      <!-- set type Visibility: default -->
      <element link="TControlAtPosFlag" name="TControlAtPosFlags"/>
      <!-- function Visibility: default -->
      <element name="DbgS">
        <short>Converts items of several data types into strings, for debug output.</short>
        <descr/>
        <errors>[The parameters should have unique names, for every type]</errors>
        <seealso/>
      </element>
      <element name="DbgS.Result">
        <short>The string representing the given parameter(s).</short>
      </element>
      <element name="DbgS.a">
        <short/>
      </element>
      <element name="DbgS.Anchors">
        <short/>
      </element>
      <element name="DbgS.Side">
        <short/>
      </element>
      <element name="DbgS.p">
        <short/>
      </element>
      <element name="DbgS.Phases">
        <short>All elements in this set will be shown as a comma-separated list.</short>
      </element>
      <!-- function Visibility: default -->
      <element name="operator :=(Variant): TCaption">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="operator :=(Variant): TCaption.Result">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <element name="operator :=(Variant): TCaption.AVariant">
        <short/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- Variables go here -->
      <!-- variable Visibility: implementation -->
      <element name="CaptureControl">
        <short>Hidden reference to the currently capturing control.</short>
        <descr>The interface knows, which TWinControl has the capture.
          This stores what child control of this TWinControl has actually the capture.
        </descr>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="DefaultDockManagerClass">
        <short>The default DockManager to create for a DockSite.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="DockSplitterClass">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- variable Visibility: default -->
      <element link="TDragManager" name="DragManager">
        <short>The current DragManager (always TDragManagerDefault).</short>
        <descr>A DragManager can be implemented only in the Controls unit,
          because it must access private elements of the other classes,
          declared in this unit.
        </descr>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="Mouse">
        <short>The global Mouse object.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="NewStyleControls">
        <short/>
        <descr/>
        <seealso/>
      <notes><note>?</note>
        </notes>
      </element>
      <!-- Topics go here -->
      <topic name="AutoSize">
        <short>
          <var>AutoSize</var> - boolean property that permits the size of a control to be adjusted automatically</short>
        <descr>
          <p>[deverses an review!!!]
            <var>AutoSize</var> is a boolean property found in many classes; it permits the size of a control to be adjusted automatically to accommodate differences in the text or graphic contained therein, and allows most efficient use of available space</p>
          <p>Many controls call  <link id="#lcl.Controls.TControl.DoAutoSize">TControl.DoAutoSize</link> to perform the actual auto-sizing. </p>
          <p>IMPORTANT: Many Delphi controls override this method and many call this method directly after setting some properties.</p>
          <p>During handle creation not all interfaces can create complete Device Contexts which are needed to calculate things like text size.</p>
          <p>That's why you should always call <link id="#lcl.Controls.TControl.AdjustSize">AdjustSize</link> instead of <var>DoAutoSize</var>.</p>
          <p>
            <var>TControl.AdjustSize</var> calls 
            
            
            <var>DoAutoSize</var> in a smart fashion.</p>
          <p>During loading and handle creation the calls are delayed.</p>
          <p>This method initially does the same as <link id="#lcl.Controls.TWinControl.DoAutoSize">TWinControl.DoAutoSize</link>.  But since <var>DoAutoSize</var> is commonly overriden by descendant components,  it is not useful to perform all tests, which can result in too much overhead. To reduce this the LCL calls <var>AdjustSize</var> instead.</p>
          <p>When setting <var>AutoSize</var> = true the LCL autosizes the control in width and height. This is one of the most complex parts of the LCL, because the result depends on nearly a hundred properties. Let's start simple:</p>
          <p>The LCL will only autosize the Width or Height if it is free to resize. In other words - the width is not autosized if:</p>
          <ul>
            <li>the left and right side is anchored. You can anchor the sides with the <var>Anchors</var> property or by setting the <var>Align</var> property to <var>alTop</var>, <var>alBottom</var> or <var>alClient</var>
            </li>
            <li>the Width and Height are bound by the <var>Constraints</var> properties. The Contraints can also be overriden by the widgetset. For example the winapi does not allow resizing the height of a combobox. And the gtk widgetset does not allow resizing the width of a vertical scrollbar</li>
          </ul>
          <p>The new size is calculated by the protected method <link id="#lcl.Controls.TControl.CalculatePreferredSize">TControl.CalculatePreferredSize</link>.
            This method asks the widgetset for an appropriate Width and Height. For example a <var>TButton</var> has preferred Width and Height. A <var>TComboBox</var> has only a preferred Height. The preferred Width is returned as 0 and so the LCL does not autosize the Width - it keeps the width unaltered. Finally a <var>TMemo</var> has no preferred Width or Height. Therefore AutoSize has no effect on a TMemo.</p>
          <p>Some controls override this method. For example the <var>TGraphicControl</var> descendants like <var>TLabel</var> have no window handle and so cannot query the widgetset. They must calculate their preferred Width and Height themselves.</p>
          <p>The widgetsets must override the <var>GetPreferredSize</var> method for each widget class that has a preferred size (Width or Height or both).</p>
          <p>
            <b>Parent.AutoSize</b>
          </p>
          <p>The above described the simple explanation. The real algorithm provides far more possibilities and is therefore far more complex.</p>
          <p>
            <b>Properties / Methods</b>
          </p>
          <ul>
            <li>Left</li>
            <li>Top</li>
          </ul>
          <p>If <var>Parent</var> is not nil then <var>Left, Top</var> are the pixel distance to the top, left pixel of the parent's client area (not scrolled). Remember the client area is always without the frame and scrollbars of the parent. For Delphi users: Some VCL controls like TGroupbox define the client area as the whole control including the frame and some not - the LCL is more consistent, and therefore Delphi incompatible. Left and Top can be negative or bigger than the client area. Some widgetsets define a minimum/maximum somewhere around 10.000 or more.</p>
          <p>When the client area is scrolled the Left and Top are kept unchanged. </p>
          <p>During resizing/moving Left and Top are not always in sync with the coordinates of the Handle object.</p>
          <p>If Parent=nil then Left, Top depend on the widgetset and the window manager. Till Lazarus 0.9.25 this is typically the screen coordinate of the left,top of the client area of the form. This is Delphi incompatible. It is planned to change this to the Left, Top of the window.</p>
          <p>Hint:</p>
          <p>Each time you change Left and Top the LCL moves instantly. If you want to change both Left and Top use instead:</p>
          <code>with Button1 do
    SetBounds(NewLeft,NewTop,Width,Height);
          </code>
          <ul>
            <li>Width</li>
            <li>Height</li>
          </ul>
          <p>The Size in pixels must not be negative, and most widgetsets do not allow Width=0 and/or Height=0. Some controls on some platforms define a bigger minimum constraint. Instead of sizing a control to Width=0 and/or Height=0, set Visible=false. During resizing/moving Width and Height are not always in sync with the size of the Handle object.</p>
          <ul>
            <li>BoundsRect</li>
          </ul>
          <p>Same as Bounds(Left,Top,Width,Height).</p>
          <p>Common newbie mistake:</p>
          <code>BoundsRect.Left:=3; // WRONG: common newbie mistake
</code>
          <p>This has no effect, because reading BoundsRect is a function. It creates a temporary TRect on the stack.</p>
          <ul>
            <li>ClientRect</li>
          </ul>
          <p>Left and Top are always 0,0. Width and Height are the visible size in pixels of the client area. Remember the client area is without the frame and without scrollbars. In a scrollable client area the logical client area can be bigger than the visible.</p>
          <ul>
            <li>ClientOrigin</li>
          </ul>
          <p>Returns the screen coordinate of the top left coordinate 0,0 of the client area. Note that this value is the position as stored in the interface and is not always in sync with the LCL. When a control is moved, the LCL sets the bounds to the desired position and sends a move message to the interface. It is up to the interface to handle moves instantly or queued.</p>
          <ul>
            <li>LCLIntf.GetClientBounds</li>
          </ul>
          <p>Returns the client bounds of a control. Like ClientRect, but Left and Top are the pixel distances to the control's left, top. For example on a TGroupBox the Left, Top are the width and height of the left and top frame border. Scrolling has no effect on GetClientBounds.</p>
          <ul>
            <li>LCLIntf.GetWindowRect</li>
          </ul>
          <p>After the call, ARect will be the control area in screen coordinates. That means, Left and Top will be the screen coordinate of the TopLeft pixel of the Handle object and Right and Bottom will be the screen coordinate of the BottomRight pixel.</p>
          <ul>
            <li>FBaseBoundsLock: integer</li>
          </ul>
          <p>Increased/Decreased by LockBaseBounds/UnlockBaseBounds.
            Used to keep FBaseBounds during SetBounds calls.</p>
          <ul>
            <li>FBaseParentClientSize: TPoint</li>
          </ul>
          <p>The Parent.ClientRect size valid for the FBaseBounds.
            FBaseBounds and FBaseParentClientSize are used to calculate the distance for
            akRight (akBottom).
            When the parent is resized, the LCL knows what distance to keep.</p>
          <ul>
            <li>FBoundsRectForNewParent: TRect</li>
          </ul>
          <p>When changing the Parent of a control the Handle is recreated and many
            things can happen. Especially for docking forms the process is too
            unreliable. Therefore the BoundsRect is saved. The VCL uses a similar
            mechanism.</p>
          <ul>
            <li>FLastDoChangeBounds: TRect</li>
          </ul>
          <p>Used to avoid calling OnChangeBounds with the same coordinates. This reduces
            user defined autosizing.</p>
          <ul>
            <li>FLastResizeClientHeight: integer</li>
            <li>FLastResizeClientWidth: integer</li>
            <li>FLastResizeHeight: integer</li>
            <li>FLastResizeWidth: integer</li>
          </ul>
          <p>Used to avoid calling OnResize with the same coordinates. This reduces user
            defined autosizing.</p>
          <ul>
            <li>FLoadedClientSize: TPoint</li>
          </ul>
          <p>During loading many things are delayed and many things are set and worse: in
            the wrong order. That's why SetClientWidth/SetClientHeight calls are stored
            and set at end of loading again.
            This way the LCL can restore the distances (e.g. akRight) used during
            designing.</p>
          <ul>
            <li>FReadBounds: TRect</li>
          </ul>
          <p>Same as FLoadedClientSize, but for SetLeft, SetTop, SetWidth, SetHeight.</p>
          <ul>
            <li>procedure SetBoundsRectForNewParent(const AValue: TRect);</li>
          </ul>
          <p>Used to set FBoundsRectForNewParent. See above.</p>
          <ul>
            <li>procedure SetInitialBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;</li>
          </ul>
          <p>A smart version of SetBounds, reducing overhead during creation and loading.</p>
          <ul>
            <li>procedure UpdateBaseBounds(StoreBounds, StoreParentClientSize, UseLoadedValues: boolean); virtual;</li>
          </ul>
          <p>Commit current bounds to base bounds.</p>
          <ul>
            <li>procedure SetClientHeight(Value: Integer);</li>
            <li>procedure SetClientSize(Value: TPoint);</li>
            <li>procedure SetClientWidth(Value: Integer);  </li>
          </ul>
          <p>Exists for Delphi compatibility too. Resizes the control, to get the wanted ClientRect size.</p>
          <ul>
            <li>procedure ChangeBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</li>
          </ul>
          <p>This is the internal SetBounds.
            Applies constraints, updates base bounds, calls OnChangeBound, OnResize,
            locks bounds.</p>
          <ul>
            <li>procedure DoSetBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</li>
          </ul>
          <p>This really sets the FLeft, FTop, FWidth, FHeight private variables.</p>
          <ul>
            <li>procedure SetBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;</li>
          </ul>
          <p>This is the standard procedure overriden by many Delphi controls. TWinControl overrides it too. </p>
          <p>Ignores calls when bounds are locked; lock the FBoundsRealized to avoid overhead to the interface during auto sizing.</p>
          <p>ChangeBounds is not locked this way.</p>
          <ul>
            <li>Function GetClientOrigin: TPoint; virtual;</li>
          </ul>
          <p>Screen coordinate of Left, Top of client area.</p>
          <ul>
            <li>Function GetClientRect: TRect; virtual;</li>
          </ul>
          <p>Size of client area. (always Left=0, Top=0)</p>
          <ul>
            <li>Function GetScrolledClientRect: TRect; virtual;</li>
          </ul>
          <p>Visible client area in ClientRect.</p>
          <ul>
            <li>function GetChildsRect(Scrolled: boolean): TRect; virtual;</li>
          </ul>
          <p>Returns the Client rectangle relative to the control's Left, Top.
            If Scrolled is true, the rectangle is moved by the current scrolling values
            (for an example see TScrollingWincontrol).</p>
          <ul>
            <li>function GetClientScrollOffset: TPoint; virtual;</li>
          </ul>
          <p>Returns the scrolling offset of the client area.</p>
          <ul>
            <li>function GetControlOrigin: TPoint; virtual;</li>
          </ul>
          <p>Returns the screen coordinate of the topleft coordinate 0,0 of the control area. (The topleft pixel of the control on the screen)
            Note that this value is the position as stored in the interface and is not always in sync with the LCL.
            When a control is moved, the LCL sets the bounds to the wanted position
            and sends a move message to the interface.
            It is up to the interface to handle moves instantly or queued.</p>
        </descr>
      <notes><note>deverses an review!!!</note>
        </notes>
      </topic>
      <topic name="Control coordinates">
        <short>The coordinates of a control can be specified or retrieved in various ways.</short>
        <descr>
          <p>The following description applies to members of TControl and TWinControl.</p>
          <p>Every control has an origin (Top, Left) and extent (Width, Height). The origin is relative to its Parent control (client coordinates) or,
            for floating controls (forms) with Parent=Nil, relative to the screen.</p>
          <p>The BoundsRect describes the TopLeft and BottomRight coordinates of the control, relative to its Parent.</p>
          <p>The BoundsRectForNewParent holds the new coordinates, to be used when the Parent of the control is changed later.</p>
          <p>The ClientRect describes the internal (client) area of a container control (TWinControl), excluding borders. Its Top and Left are always zero.
            In a TScrollingWinControl...</p>
          <p>BaseBounds holds the designed Bounds, to be used e.g. when a scale factor is set later.</p>
          <p>GetControlOrigin returns the origin in screen coordinates. These values are not always in sync with the true screen position, managed by the widgetset.</p>
          <p>ScreenToClient returns the client coordinates of an point given in the screen coordinates, i.e. the coordinates relative to the control's client origin.</p>
          <p>ClientToScreen returns the screen coordinats for an point in client coordinates.</p>
        </descr>
      <notes><note>?</note><note>right?</note>
        </notes>
      </topic>
      <topic name="Anchoring Controls">
        <short>How multiple controls can be aligned and resized together, at runtime.</short>
        <descr>
          <p>The tree-style layout of a form allows to specify table-style areas,
            with a common width or height of all controls in the same area (using container controls like e.g. TPanel).
          </p>
          <p>Delphi introduced control anchoring to the sides of the Parent control.
            This means when a control in a form has Anchors[akRight]=True,
            its right side keeps its distance from the right side of its Parent,
            when its Parent is resized.
          </p>
          <p>The default anchors [akLeft,akTop] keep every control anchored to the origin (TopLeft) of their Parent control (of form).
            This will cause controls to disappear when the form is shrinked,
            or the user has to scroll through the form's client area.
          </p>
          <p>When a control shall e.g. use the available space, left over to its right,
            Anchors=[akLeft,akRight] will result in a variable-width control.
          </p>
          <p>The Align property allows to stack controls at their Parent's sides,
            e.g. all controls with Align=alTop are stacked at the top of their Parent.
            The remaining space in the Parent can be occupied by a single control,
            of Align=alClient.
          </p>
          <p>Both Anchors and Align are tightly coupled, changing one property will affect the other one.
            This is harmless in so far, as the IDE (form designer) keeps all adjustments in sync, free of conflicts.
          </p>
          <p>Some people found this approved layout method too restrictive, and too complicated to use,
            and now LCL controls <b>also</b> can be anchored <b>freely</b> to each other.
            This layout management is traditionally referred to as "Anchor Docking", even if it is not related to docking at all.
          </p>
          <remark>This freedom requires that the GUI designer is responsible for consistent anchor specifications,
            which do not result in unresolvable cyclic references or other contradictions.
          </remark>
          <p>Anchor docking allows to anchor every side of a control to an arbitrary side of another control,
            i.e. the left side of an Edit control can be anchored to the right side of its associated Label.
          </p>
          <code>Example1
    --------
      If you want to have the top of B the same as the top of C:
       +-----+  +-----+
       |  B  |  |  C  |
       |     |  +-----+
       +-----+
      use
        B.AnchorSide[akTop].Control:=C;
        B.AnchorSide[akTop].Side:=asrTop;
          </code>
          <p>When you want to have a gap between both controls,
            set e.g. B.Borderspacing.Right to the desired amount.
            Setting C.Borderspacing.Left will have the same effect, and both can be used together;
            the resulting gap then reflects the maximum value of both properties.
          </p>
          <p>BorderSpacing is in effect even for controls without special anchoring,
            when AutoSize is used.
          </p>
          <p>Anchor docking also allows to center a control relative to another control.
          </p>
          <code>Example2
    --------
      For centering A relative to B:
            +-------+
      +---+ |       |
      | A | |   B   |
      +---+ |       |
            +-------+
      use
        A.AnchorSide[akTop].Side:=asrCenter;
        A.AnchorSide[akTop].Control:=B;
      Or use this, it's equivalent:
        A.AnchorSide[akBottom].Side:=asrCenter;
        A.AnchorSide[akBottom].Control:=B;
          </code>
          <p>TControlChildSizing and TControlChildrenLayout offers additional means for aligning and separating controls.
          </p>
          <p/>
        </descr>
      <notes><note>?</note><note>todo!?</note>
        </notes>
      </topic>
      <element name="TWinControl.AutoSizeDelayedHandle">
        <short>Returns true if AutoSize should be skipped / delayed because of its handle.</short>
      </element>
    <element name="TLazAccessibleObject.GetEnumerator"><short>Default enumerator for the children</short>
      </element>
    </module>
    <!-- Controls -->
  </package>
</fpdoc-descriptions>
