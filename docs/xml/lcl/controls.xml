<?xml version="1.0"?>
<fpdoc-descriptions>
  <package name="LCL">
    <!--
  ====================================================================
    Controls
  ====================================================================
-->
    <module name="Controls">
      <short>This unit contains basic classes for visual controls.</short>
      <descr/>
      <!-- unresolved type reference Visibility: default -->
      <element name="Classes">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="SysUtils">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="TypInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="FPCAdds">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="DynHashArray">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLStrConsts">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLProc">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="GraphType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="Graphics">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LMessages">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLIntf">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="InterfaceBase">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="ImgList">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="UTrace">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="PropertyStorage">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="Menus">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="ActnList">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- unresolved type reference Visibility: default -->
      <element name="LCLClasses">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrNone">
        <short>mrNone</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrNone=0
</descr>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrOK">
        <short>mrOK</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrOK=1
</descr>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrCancel">
        <short>mrCancel</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrCancel=2</descr>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrAbort">
        <short>mrAbort</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrAbort=3
        
</descr>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrRetry">
        <short>mrRetry</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrRetry=4</descr>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrIgnore">
        <short>mrIgnore</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrIgnore=5</descr>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrYes">
        <short>mrYes</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrYes=6</descr>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrNo">
        <short>mrNo (not the same as mrNone)</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrNo=7</descr>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrAll">
        <short>mrAll</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrAll=8</descr>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrNoToAll">
        <short>mrNoToAll</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrNoToAll=9</descr>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrYesToAll">
        <short>mrYesToAll</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrYesToAll=10</descr>
      </element>
      <!-- constant Visibility: default -->
      <element name="mrLast">
        <short>mrLast</short>
        <descr>Series of constants to be used as respones in message boxes etc.
mrLast=mrYesToAll=10</descr>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TWinControlClass">
        <short>
          <var>TWinControlClass</var> - class of 
          <var>TWinControl</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TControlClass">
        <short>
          <var>TControlClass</var> - class of 
          <var>TControl</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- "type" alias type Visibility: default -->
      <element name="TDate">
        <short>Date expressed in the encoded date-time type</short>
      </element>
      <!-- "type" alias type Visibility: default -->
      <element name="TTime">
        <short>Time of day expressed in the encoded date-time type</short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMMouseWheel">
        <short>TCMMouseWheel - record holding data about the Mouse Wheel</short>
        <descr>
          <pre>Details held include:
          the Message associated with the wheel;
          the shift state (ie whether Shift, Alt, Control etc keys have been pressed);
          wheel data which can either be 
	  a position (X, Y coordinates) or 
	  a position plus an integer result.</pre>
        </descr>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.MSg">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.ShiftState">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.Unused">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.WheelData">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCMHitTest">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMControlChange">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlChange.Msg">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlChange.Control">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlChange.Inserting">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMControlChange.Result">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCMDialogChar">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCMDialogKey">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAlign">
        <short>TAlign - enumerated type listing the available options for aligning a Control</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alNone">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alTop">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alBottom">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alLeft">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alRight">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alClient">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAlign.alCustom">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TAlignSet">
        <short>Set of options of type TAlign defining possible ways of aligning</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAnchorKind">
        <short>Enumerated type listing the possible positions for alignment of a control</short>
        <descr>
          <p>Enumerated type listing the possible positions for alignment of a control</p>
          <pre>akTop, 
  akLeft, 
  akRight, 
  akBottom
</pre>
        </descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorKind.akTop">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorKind.akLeft">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorKind.akRight">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorKind.akBottom">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TAnchors">
        <short>Set of possible anchor positions</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAnchorSideReference">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideReference.asrTop">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideReference.asrBottom">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideReference.asrCenter">
        <short/>
      </element>
      <!-- constant Visibility: default -->
      <element name="asrLeft">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="asrRight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- "type" alias type Visibility: default -->
      <element name="TTranslateString">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TCaption">
        <short>A string type for the caption of a control: may be translated</short>
      </element>
      <!-- range type Visibility: default -->
      <element name="TCursor">
        <short>
          <var>TCursor</var> - integer type defining range of values for cursor</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFormStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormStyle.fsNormal">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormStyle.fsMDIChild">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormStyle.fsMDIForm">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormStyle.fsStayOnTop">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormStyle.fsSplash">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFormBorderStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsNone">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsSingle">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsSizeable">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsDialog">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsToolWindow">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFormBorderStyle.bsSizeToolWin">
        <short/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TBorderStyle">
        <short>A subset of TFormBorderStyle, listing only the styles available to a control that is not a form</short>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TControlBorderStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlRoleForForm">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlRoleForForm.crffDefault">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlRoleForForm.crffCancel">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlRolesForForm">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TBevelCut">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TMouseButton">
        <short>Type defining the three mouse buttons (left, middle, right)</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseButton.mbLeft">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseButton.mbRight">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseButton.mbMiddle">
        <short/>
      </element>
      <!-- constant Visibility: default -->
      <element name="fsAllStayOnTop">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crHigh">
        <short>crHigh - a cursor constant</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crDefault">
        <short>crDefault - cursor constant: use default cursor (0)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crNone">
        <short>crNone - a cursor constant: no cursor (-1)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crArrow">
        <short>crArrow - cursor constant: Arrow cursor (-2)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crCross">
        <short>cursor constant</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crIBeam">
        <short>crIbeam - cursor constant: shows I-beam cursor often used in text editors (-4) </short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeNESW">
        <short>crSizeNESW - cursor constant: runs diagonally from NorthEast to SouthWest (-6)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeNS">
        <short>crSizeNS - cursor constant: cursur runs from North to South (-7)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeNWSE">
        <short>crNWSE - cursor constant: cursor runs from NorthWest to SouthEast</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeWE">
        <short>crSizeWE - cursor constant: runs from West to East (-9)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeNW">
        <short>cursor constant</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeN">
        <short>crSizeN - cursor constant: cursor North (-24)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeNE">
        <short>crSizeNW - cursor constant: NorthWest (-23)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeW">
        <short>cursor constant</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeE">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeSW">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeS">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeSE">
        <short>cursor constant</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crUpArrow">
        <short>crUpArrow - cursor constant: cursor is Up-Arrow (-10)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crHourGlass">
        <short>crHourGlass - cursor constant: shows hour-glass (wait while action proceeds) (-11)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crDrag">
        <short>crDrag - cursor constant: shows dragging cursor (-12)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crNoDrop">
        <short>cursor constant</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crHSplit">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crVSplit">
        <short>cursor constant</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crMultiDrag">
        <short>cursor constant</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSQLWait">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crNo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crAppStart">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crHelp">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crHandPoint">
        <short>crHandPoint - cursor constant: Pointing Hand (-21)</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="crSizeAll">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="crLow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TWndMethod">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWndMethod.TheMessage">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlStyleType">
        <short>TControlStyleType - enumerated type describing features of the Control</short>
        <descr>
          <pre>Enumerated type comprising:
    csAcceptsControls, // can have children in the designer
    csCaptureMouse,
    csDesignInteractive, // wants mouse events in design mode
    csClickEvents,
    csFramed,
    csSetCaption,
    csOpaque,
    csDoubleClicks,// control understands mouse double clicks
    csTripleClicks,// control understands mouse triple clicks
    csQuadClicks,  // control understands mouse quad clicks
    csFixedWidth,
    csFixedHeight, // control cannot change its height (for example combobox)
    csNoDesignVisible,
    csReplicatable,
    csNoStdEvents,
    csDisplayDragImage,
    csReflector,
    csActionClient,
    csMenuEvents,
    csNoFocus,
    csNeedsBorderPaint, // not implemented
    csParentBackground, // not implemented
    csDesignNoSmoothResize, // no WYSIWYG resizing in designer
    csDesignFixedBounds, // control can not be moved nor resized in designer
    csHasDefaultAction, // control implements useful ExecuteDefaultAction
    csHasCancelAction,   // control implements useful ExecuteCancelAction
    csNoDesignSelectable, // control can not be selected at design time
    csOwnedChildsSelectable // child controls owned by this control are selectable in the designer</pre>
        </descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csAcceptsControls">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csCaptureMouse">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csDesignInteractive">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csClickEvents">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csFramed">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csSetCaption">
        <short>As long as Name=Text, changing the Name will set the Caption</short>
        <descr>When for example a button's Name and Caption have the value 'Button1' and the Name is changed to 'Button2' then the Caption is changed as well. When Name and Caption differs this flag has no effect. This flag has no effect during loading.</descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csOpaque">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csDoubleClicks">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csTripleClicks">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csQuadClicks">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csFixedWidth">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csFixedHeight">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csNoDesignVisible">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csReplicatable">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csNoStdEvents">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csDisplayDragImage">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csReflector">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csActionClient">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csMenuEvents">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csNoFocus">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csNeedsBorderPaint">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csParentBackground">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csDesignNoSmoothResize">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csDesignFixedBounds">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csHasDefaultAction">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csHasCancelAction">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlStyle">
        <short>Set of permissible control styles</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="csMultiClicks">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlStateType">
        <short>TControlStateType -  an enumerated type listing the possible states (status) of Control</short>
        <descr>
          <p>Enumerated type comprising</p>
          <pre>csLButtonDown,
    csClicked,
    csPalette,
    csReadingState,
    csAlignmentNeeded,
    csFocusing,
    csCreating,
    csPaintCopy,
    csCustomPaint,
    csDestroyingHandle,
    csDocking,
    csVisibleSetInLoading
</pre>
        </descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csLButtonDown">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csClicked">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csPalette">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csReadingState">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csAlignmentNeeded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csFocusing">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csCreating">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csPaintCopy">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csCustomPaint">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csDestroyingHandle">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csDocking">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStateType.csVisibleSetInLoading">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlState">
        <short>Set of permissible Control States</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlCanvas">
        <short>The base class for the canvas property of several graphic controls, such as TGraphicControl and TCustomControl</short>
        <seealso>
          <link id="#lcl.Controls.TGraphicControl">TGraphicControl</link>
          <link id="#lcl.Controls.TCustomControl">TCustomControl</link>
          <link id="#lcl.Graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlCanvas.FControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlCanvas.FDeviceContext">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlCanvas.FWindowHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlCanvas.SetControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlCanvas.SetControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlCanvas.CreateFont">
        <short>
          <var>CreateFont</var> - creates font by calling inherited 
          <var>CreateFont</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.CreateFont">TFPCustomCanvas.CreateFont</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Graphics.TCanvas.CreateHandle" name="TControlCanvas.CreateHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControlCanvas.Create">
        <short>
          <var>Create</var> - constructor for TControlCanvas: calls inherited 
          <var>Create</var> then initialises local variables to show an empty control</short>
        <seealso>
          <link id="#fcl.FPCanvas.TFPCustomCanvas.create">TFPCustomCanvas.create</link>
        </seealso>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TControlCanvas.Destroy">
        <short>
          <var>Destroy</var> - destructor for 
          <var>TControlCanvas</var>: frees handle and calls inherited 
          <var>Destroy</var>
        </short>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Destroy">TPersistent.Destroy</link>
          <link id="#LCL.Graphics.TCanvas.Destroy">TCanvas.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Graphics.TCanvas.FreeHandle" name="TControlCanvas.FreeHandle">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlCanvas.Control">
        <short>The Control object for which this is the Canvas</short>
        <descr>Reads or writes a flag to determine the identity of the Control object</descr>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragImageList">
        <short>
          <var>TDragImageList</var> - a list of Images to be dragged</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TKeyEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TKeyEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TKeyEvent.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TKeyEvent.Shift">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TKeyPressEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TKeyPressEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TKeyPressEvent.Key">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TUTF8KeyPressEvent">
        <short>cursor constant</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TUTF8KeyPressEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TUTF8KeyPressEvent.UTF8Key">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseEvent.Button">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseEvent.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseEvent.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseEvent.Y">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseMoveEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseMoveEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseMoveEvent.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseMoveEvent.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseMoveEvent.Y">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseWheelEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseWheelEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseWheelEvent.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseWheelEvent.WheelDelta">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseWheelEvent.MousePos">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseWheelEvent.Handled">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TMouseWheelUpDownEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseWheelUpDownEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseWheelUpDownEvent.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseWheelUpDownEvent.MousePos">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouseWheelUpDownEvent.Handled">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragState">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragState.dsDragEnter">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragState.dsDragLeave">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragState.dsDragMove"/>
      <!-- enumeration type Visibility: default -->
      <element name="TDragMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMode.dmManual">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMode.dmAutomatic">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragKind">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragKind.dkDrag">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragKind.dkDock">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragOperation">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragOperation.dopNone">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragOperation.dopDrag">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragOperation.dopDock">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDragMessage">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmDragEnter">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmDragLeave">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmDragMove">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmDragDrop">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmDragCancel">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDragMessage.dmFindTarget">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDragOverEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragOverEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragOverEvent.Source">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragOverEvent.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragOverEvent.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragOverEvent.State">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragOverEvent.Accept">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDragDropEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDropEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDropEvent.Source">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDropEvent.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDropEvent.Y">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TStartDragEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TStartDragEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TStartDragEvent.DragObject">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TEndDragEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TEndDragEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TEndDragEvent.Target">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TEndDragEvent.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TEndDragEvent.Y">
        <short/>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PDragRec">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TDragRec">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TDragRec.Pos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TDragRec.Source">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TDragRec.Target">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TDragRec.Docking">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMDrag">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMDrag.Msg">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMDrag.DragMessage">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMDrag.Reserved1">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMDrag.Reserved2">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMDrag.DragRec">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMDrag.Result">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragObject">
        <short>
          <var>TDragObject</var> - the base class for many objects that are designed to be dragged and dropped</short>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FDragTarget">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FDragHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FDragPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FDragTargetPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FDropped">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FMouseDeltaX">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FMouseDeltaY">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FCancelling"/>
      <!-- function Visibility: private -->
      <element name="TDragObject.Capture">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragObject.Capture.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.Finished">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.Finished.Target">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.Finished.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.Finished.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.Finished.Accepted">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragObject.GetDragCursor">
        <short>
          <var>GetDragCursor</var> - returns the cursor for use during dragging</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragObject.GetDragCursor.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.GetDragCursor.Accepted">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.GetDragCursor.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.GetDragCursor.Y">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragObject.GetDragImages">
        <short>
          <var>GetDragImages</var> - returns a list of images for dragging</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragObject.GetDragImages.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.MouseMove">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.MouseMove.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.MouseMove.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.MouseMove.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.MouseDown">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.MouseDown.Button">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.MouseDown.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.MouseDown.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.MouseDown.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.MouseUp">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.MouseUp.Button">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.MouseUp.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.MouseUp.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.MouseUp.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.CaptureChanged">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.CaptureChanged.OldCaptureControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.KeyDown">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.KeyDown.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.KeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragObject.KeyUp">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.KeyUp.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.KeyUp.Shift">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TDragObject.Destroy">
        <short>Destroy this instance of TDragObject</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragObject.Assign">
        <short>Assigns a particular source to this drag object</short>
        <descr>Finds out a lot of information about the source object, such as its operating-system handle, size, position, how much the mouse is allowed to move before the object is moved, and whether the object is to be kept visible during the drag process.</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.Assign.Source">
        <short>The object, with all its properties, that is to be dragged</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragObject.GetName">
        <short>Find name of the object for dragging</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragObject.GetName.Result">
        <short>The object's name returned as a string</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragObject.HideDragImage">
        <short>Procedure for hiding the drag image during movement</short>
        <seealso>
          <link id="#lcl.Controls.TDragObject.ShowDragImage">ShowDragImage</link>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragObject.Instance">
        <short>// exist only for compatibility</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragObject.Instance.Result">
        <short>zero</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragObject.ShowDragImage">
        <short>Procedure for keeping the image visible during movement</short>
        <seealso>
          <link id="#lcl.Controls.TDragObject.HideDragImage">HideDragImage</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.Cancelling">
        <short>Is this drag object being cancelled?</short>
        <descr>Reads or sets flag to determine whether this drag image is being cancelled. Property has a boolean value, true if cancelling</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragHandle">
        <short>Finds Operating-System handle for this object</short>
        <descr>Reads or writes flag for operating-system handle</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragPos">
        <short>Find position for this object</short>
        <descr>Reads or writes flag with position (as X, Y co-ordinates)</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragTargetPos">
        <short>The position of the taget control object to which the currect object is to be dragged</short>
        <descr>Reads or writes flag with position (X, Y co-ordinates) of control object to which the current object is to be dragged</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.DragTarget">
        <short>The control object to which the current object is to be dragged (target)</short>
        <descr>Reads or writes flag with identity of the target control object to which the currect object is to be dragged</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.Dropped">
        <short>Has the drag object been dropped yet?</short>
        <descr>Boolean property, true if the object has been dropped; reads or writes a flag with this information</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.MouseDeltaX">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.MouseDeltaY">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TDragObjectClass">
        <short>
          <var>TDragObjectClass</var> - class of 
          <var>TDragObject</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TBaseDragControlObject">
        <short>An ancestor class for many drag control objects</short>
        <seealso>
          <link id="#lcl.Controls.TDragObject"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TBaseDragControlObject.FControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBaseDragControlObject.EndDrag">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBaseDragControlObject.EndDrag.Target">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBaseDragControlObject.EndDrag.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBaseDragControlObject.EndDrag.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TBaseDragControlObject.Finished">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBaseDragControlObject.Finished.Target">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBaseDragControlObject.Finished.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBaseDragControlObject.Finished.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBaseDragControlObject.Finished.Accepted">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TBaseDragControlObject.Create">
        <short>Creates an instance of this object</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBaseDragControlObject.Create.AControl">
        <short>The control object that is to be dragged</short>
        <descr>Reads or writes flag with identity of object for dragging</descr>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TBaseDragControlObject.Assign">
        <short>Assigns source object</short>
        <descr>Overrides definition in parent class</descr>
        <seealso>
          <link id="#lcl.Controls.TDragObject"/>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TBaseDragControlObject.Assign.Source">
        <short>The object that is to be dragged</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TBaseDragControlObject.Control">
        <short>The identity of the control to be dragged</short>
        <descr>Reads or writes flag with identity of control object</descr>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragControlObject">
        <short>
          <var>TDragControlObject</var> - a drag object that is a control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TDragObject.GetDragCursor" name="TDragControlObject.GetDragCursor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragControlObject.GetDragCursor.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragControlObject.GetDragCursor.Accepted">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragControlObject.GetDragCursor.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragControlObject.GetDragCursor.Y">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TDragObject.GetDragImages" name="TDragControlObject.GetDragImages">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragControlObject.GetDragImages.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragControlObject.HideDragImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragControlObject.ShowDragImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragDockObject">
        <descr/>
        <errors/>
        <seealso/>
        <short>
          <var>TDragDockObject</var> - a drag object that is destined for docking</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDockOrientation">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDockOrientation.doNoOrient">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDockOrientation.doHorizontal">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDockOrientation.doVertical">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDockDropEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockDropEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockDropEvent.Source">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockDropEvent.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockDropEvent.Y">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDockOverEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockOverEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockOverEvent.Source">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockOverEvent.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockOverEvent.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockOverEvent.State">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockOverEvent.Accept">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TUnDockEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TUnDockEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TUnDockEvent.Client">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TUnDockEvent.NewTarget">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TUnDockEvent.Allow">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TStartDockEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TStartDockEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TStartDockEvent.DragObject">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetSiteInfoEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGetSiteInfoEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGetSiteInfoEvent.DockClient">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGetSiteInfoEvent.InfluenceRect">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGetSiteInfoEvent.MousePos">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGetSiteInfoEvent.CanDock">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragDockObject">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FBrush">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FDockRect">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FDropAlign">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FDropOnControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FFloating">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TDragDockObject.SetBrush">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDockObject.SetBrush.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragDockObject.AdjustDockRect">
        <short>
          <var>AdjustDockRect</var> - adjust the position into which docking is to be performed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDockObject.AdjustDockRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragDockObject.DrawDragDockImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDragObject.EndDrag" name="TDragDockObject.EndDrag">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDockObject.EndDrag.Target">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDockObject.EndDrag.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDockObject.EndDrag.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragDockObject.EraseDragDockImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TDragObject.GetDragCursor" name="TDragDockObject.GetDragCursor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragDockObject.GetDragCursor.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDockObject.GetDragCursor.Accepted">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDockObject.GetDragCursor.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDockObject.GetDragCursor.Y">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDragDockObject.GetFrameWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragDockObject.GetFrameWidth.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDragDockObject.Create">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDockObject.Create.AControl">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TDragDockObject.Destroy">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragDockObject.Assign">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragDockObject.Assign.Source">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.Brush">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.DockRect">
        <short>
          <var>DockRect</var> - the rectangle within which docking is to occur</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.DropAlign">
        <short>
          <var>DropAlign</var> - the way in which the dropped object is to be aligned (top, left etc)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.DropOnControl">
        <short>
          <var>DropOnControl</var> - the control on which the dragged object is to be dropped</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.Floating">
        <short>Determines whether object is <var>Floating</var> or free (not attached to anything)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.FrameWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDockManager">
        <short>A base class for managing the docking process</short>
        <descr>
          <p>TDockManager is an abstract class for managing a dock site's docked controls. </p>
          <p>The declaration contains a number of procedure definitions that are 'virtual' and 'abstract'. This means that there is no implementation specified: these essentially represent 'place-holders',  and it is the responsibility of the developer of descendant classes to override these methods and implement them as desired.</p>
        </descr>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.BeginUpdate">
        <short>
          <var>BeginUpdate</var> - start updating the dock process</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.EndUpdate">
        <short>
          <var>EndUpdate</var> - finish updating the dock process</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.GetControlBounds">
        <short>
          <var>GetControlBounds</var> - finds the bounds of the control for docking</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.GetControlBounds.Control">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.GetControlBounds.AControlBounds">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.InsertControl">
        <short>
          <var>InsertControl</var> - insert the specified 
          <var>DropCtl</var> into the nominated 
          <var>Control</var>, using the alignment specified by 
          <var>InsertAt</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.InsertControl.Control">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.InsertControl.InsertAt">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.InsertControl.DropCtl">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.LoadFromStream">
        <short>
          <var>LoadFromStream</var> - loads object for docking from a stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.LoadFromStream.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.PaintSite">
        <short>
          <var>PaintSite</var> - a handle for the site to be painted</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.PaintSite.DC">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.PositionDockRect">
        <short>
          <var>PositionDockRect</var> method for determining the position (
          <var>DockRect</var>) where the 
          <var>DropCtl</var> is to be placed on the Client, aligned according to 
          <var>DropAlign</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.PositionDockRect.Client">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.PositionDockRect.DropCtl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.PositionDockRect.DropAlign">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.PositionDockRect.DockRect">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.RemoveControl">
        <short>
          <var>RemoveControl</var> - delete the specified control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.RemoveControl.Control">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.ResetBounds">
        <short>
          <var>ResetBounds</var> to their default values</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.ResetBounds.Force">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.SaveToStream">
        <short>
          <var>SaveToStream</var> - saves the docking object to a stream</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.SaveToStream.Stream">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TDockManager.SetReplacingControl">
        <short>
          <var>SetReplacingControl</var> - specify the control for replacing</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockManager.SetReplacingControl.Control">
        <short/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TConstraintSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TSizeConstraintsOption">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TSizeConstraintsOption.scoAdviceWidthAsMin">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TSizeConstraintsOption.scoAdviceWidthAsMax">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TSizeConstraintsOption.scoAdviceHeightAsMin">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TSizeConstraintsOption.scoAdviceHeightAsMax">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TSizeConstraintsOptions">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TSizeConstraints">
        <short>
          <var>TSizeConstraints</var> - limits that are set to determine the maximum and minimum values that can be used in sizing objects</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FMaxHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FMaxInterfaceHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FMaxInterfaceWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FMaxWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FMinHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FMinInterfaceHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FMinInterfaceWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FMinWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FOnChange">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TSizeConstraints.FOptions">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TSizeConstraints.SetOptions">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.SetOptions.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.Change">
        <short>Method for achieving a <var>Change</var> in the constraints</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.AssignTo">
        <short>
          <var>AssignTo</var> - copies constraints to destination if it is of the same type and has different values, else calls inherited 
          <var>AssignTo</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.AssignTo">TPersistent.AssignTo</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.AssignTo.Dest">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.SetMaxHeight">
        <short>
          <var>SetMaxHeight</var> - specifies a maximum value for height</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.SetMaxHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.SetMaxWidth">
        <short>
          <var>SetMaxWidth</var> - specifies a maximum value for width</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.SetMaxWidth.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.SetMinHeight">
        <short>
          <var>SetMinHeight</var> - specifies a minimum value for height</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.SetMinHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TSizeConstraints.SetMinWidth">
        <short>
          <var>SetMinWidth</var> - specifies a minimum value for width</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.SetMinWidth.Value">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TSizeConstraints.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TSizeConstraints</var>: calls inherited 
          <var>Create</var> and sets some default (zero) constraints</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.Create.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TSizeConstraints.UpdateInterfaceConstraints">
        <short>
          <var>UpdateInterfaceConstraints</var> - updates the constraints on size for the Interface</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TSizeConstraints.SetInterfaceConstraints">
        <short>
          <var>SetInterfaceConstraints</var> - specifies the constraints for the interface</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.SetInterfaceConstraints.MinW">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.SetInterfaceConstraints.MinH">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.SetInterfaceConstraints.MaxW">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.SetInterfaceConstraints.MaxH">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMinWidth">
        <short>
          <var>EffectiveMinWidth</var> - returns the effective value for minimum width, given the local and interface constraints</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSizeConstraints.EffectiveMinWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMinHeight">
        <short>
          <var>EffectiveMinHeight</var> - returns the effective value for minimum height, given the local and interface constraints</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSizeConstraints.EffectiveMinHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMaxWidth">
        <short>
          <var>EffectiveMaxWidth</var> - returns the effective value for maximum width, given the local and interface constraints</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSizeConstraints.EffectiveMaxWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.EffectiveMaxHeight">
        <short>
          <var>EffectiveMaxHeight</var> - returns the effective value for maximum height, given the local and interface constraints</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSizeConstraints.EffectiveMaxHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.MinMaxWidth">
        <short>
          <var>MinMaxWidth</var> the difference between Minimum and Maximum width</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSizeConstraints.MinMaxWidth.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.MinMaxWidth.Width">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TSizeConstraints.MinMaxHeight">
        <short>
          <var>MinMaxHeight</var> the difference between Minimum and Maximum height</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TSizeConstraints.MinMaxHeight.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TSizeConstraints.MinMaxHeight.Height">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MaxInterfaceHeight">
        <short>
          <var>MaxInterfaceHeight</var> - the maximum height allowed by the interace</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MaxInterfaceWidth">
        <short>
          <var>MaxInterfaceWidth</var> - the maximum width allowed by the interace</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MinInterfaceHeight">
        <short>
          <var>MinInterfaceHeight</var> - the minimum height allowed by the interface</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.MinInterfaceWidth">
        <short>
          <var>MinInterfaceWidth</var> - the minimum width allowed by the interface</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.Control">
        <short>The <var>Control</var> to which these constraints apply</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TSizeConstraints.Options">
        <short>
          <var>Options</var> for determining constraints</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.OnChange">
        <short>
          <var>OnChange</var> - event handler for a change in contraints</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MaxHeight">
        <short>
          <var>MaxHeight</var> - the maximum height</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MaxWidth">
        <short>
          <var>MaxWidth</var> - the maximum width</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MinHeight">
        <short>
          <var>MinHeight</var> - the minimum height</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TSizeConstraints.MinWidth">
        <short>
          <var>MinWidth</var> - the minimum width</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TConstrainedResizeEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TConstrainedResizeEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TConstrainedResizeEvent.MinWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TConstrainedResizeEvent.MinHeight">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TConstrainedResizeEvent.MaxWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TConstrainedResizeEvent.MaxHeight">
        <short/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TSpacingSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlBorderSpacing">
        <short>
          <var>TControlBorderSpacing </var>- the spacing around a Control</short>
        <descr>
          <code>{ TControlBorderSpacing defines the spacing around a control.

    The spacing around its children and between its children is defined in
    TWinControl.ChildSizing.

    Left, Top, Right, Bottom: integer;
        minimum space left to the autosized control.
        For example: Control A lies left of control B.
        A has borderspacing Right=10 and B has borderspacing Left=5.
        Then A and B will have a minimum space of 10 between.

    Around: integer;
        same as Left, Top, Right and Bottom all at once. This will be added to
        the effective Left, Top, Right and Bottom.
        Example: Left=3 and Around=5 results in a minimum spacing to the left
        of 8.

    InnerBorder: integer;
        This is added to the preferred size.
        For example: A buttons widget returns 75x25 on GetPreferredSize.
        CalculatePreferredSize adds 2 times the InnerBorder to the width and
        height.
        
    CellAlignHorizontal, CellAlignVertical: TControlCellAlign;
        Used for example when the Parents.ChildSizing.Layout defines a table
        layout.

  }</code>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlBorderSpacing.FAround">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlBorderSpacing.FBottom">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlBorderSpacing.FControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlBorderSpacing.FLeft">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlBorderSpacing.FOnChange">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlBorderSpacing.FRight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlBorderSpacing.FTop">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetAround">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.SetAround.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetBottom">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.SetBottom.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetLeft">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.SetLeft.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetRight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.SetRight.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetSpace">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.SetSpace.Kind">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.SetSpace.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetTop">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.SetTop.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlBorderSpacing.Change">
        <short>
          <var>Change</var> - software emulation of the 
          <var>OnChange</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControlBorderSpacing.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TControlBorderSpacing</var>: sets some default positions, dimensions and alignments, then performs inherited 
          <var>Create</var>
        </short>
        <descr>
          <p>
            <var>Create</var> - constructor for TControlBorderSpacing: sets some default positions, dimensions and alignments, then performs inherited 
            <var>Create</var>
          </p>
          <p>Overrides ancestor constructors, and may be overridden</p>
        </descr>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.Create.OwnerControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlBorderSpacing.Assign">
        <short>
          <var>Assign</var> the contents of 
          <var>Source</var> to the current control. If it is of the same type, copies selected spacing properties, otherwise calls inherited 
          <var>Assign</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.Assign.Source">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlBorderSpacing.AssignTo">
        <short>
          <var>AssignTo</var> - calls the 
          <var>Assign</var> procedure for the Destination control</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.AssignTo">TPersistent.AssignTo</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.AssignTo.Dest">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlBorderSpacing.IsEqual">
        <short>
          <var>IsEqual</var> - returns True if the specified spacing equals the current value</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlBorderSpacing.IsEqual.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.IsEqual.Spacing">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlBorderSpacing.GetSpaceAround">
        <short>
          <var>GetSpaceAround</var> - finds the space around the edge</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.GetSpaceAround.SpaceAround">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlBorderSpacing.GetSpace">
        <short>
          <var>GetSpace</var> - finds the space required by the specified Anchor kind</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlBorderSpacing.GetSpace.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.GetSpace.Kind">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlBorderSpacing.Control">
        <short>The control for which border spacing is defined</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlBorderSpacing.Space">
        <short>The kind of anchor to used in calculating spacing</short>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.Space.Kind">
        <short/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.OnChange">
        <short>Event handler for a change in border spacing</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Left">
        <short>The size of the space at the left border</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Top">
        <short>The size of the space at the top border</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Right">
        <short>The size of the space at the right border</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Bottom">
        <short>The size of the space at the bottom border</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.Around">
        <short>The size of the space all around the control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TAnchorSide">
        <short>
          <var>TAnchorSide</var> - the side on which anchoring is to be performed for the current control</short>
        <descr>
          <pre>TAnchorSide

    Class holding the reference sides of the anchors of a TControl.
    Every TControl has four AnchorSides:
    AnchorSide[akLeft], AnchorSide[akRight], AnchorSide[akTop] and
    AnchorSide[akBottom].
    Normally if Anchors contain akLeft, and the Parent is resized, the LCL
    tries to keep the distance between the left side of the control and the
    right side of its parent client area.
    With AnchorSide[akLeft] you can define a different reference side. The
    kept distance is defined by the BorderSpacing.
    
    Example1:
       +-----+  +-----+
       |  B  |  |  C  |
       |     |  +-----+
       +-----+

      If you want to have the top of B the same as the top of C use
        B.AnchorSide[akTop].Side:=asrTop;
        B.AnchorSide[akTop].Control:=C;
      If you want to keep a distance of 10 pixels between B and C use
        B.BorderSpacing.Right:=10;
        B.AnchorSide[akRight].Side:=asrLeft;
        B.AnchorSide[akRight].Control:=C;

      Do not setup in both directions, because this will create a circle, and
      circles are not allowed.
      
    Example2:
            +-------+
      +---+ |       |
      | A | |   B   |
      +---+ |       |
            +-------+
            
      Centering A relative to B:
        A.AnchorSide[akTop].Side:=arsCenter;
        A.AnchorSide[akTop].Control:=B;
      Or use this. It's equivalent:
        A.AnchorSide[akBottom].Side:=arsCenter;
        A.AnchorSide[akBottom].Control:=B;


</pre>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TAnchorSide.FControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TAnchorSide.FKind">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TAnchorSide.FOwner">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TAnchorSide.FSide">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TAnchorSide.IsSideStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TAnchorSide.IsSideStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TAnchorSide.SetControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TAnchorSide.SetControl.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TAnchorSide.SetSide">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TAnchorSide.SetSide.AValue">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TAnchorSide.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TAnchorSide</var>: calls inherited 
          <var>Create</var>, copies arguments to local variables and sets default anchor to Top</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TAnchorSide.Create.TheOwner">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TAnchorSide.Create.TheKind">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TAnchorSide.GetSidePosition">
        <short>
          <var>GetSidePosition</var> - returns the position of the side used for anchoring</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TAnchorSide.GetSidePosition.ReferenceControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TAnchorSide.GetSidePosition.ReferenceSide">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TAnchorSide.GetSidePosition.Position">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TAnchorSide.Assign">
        <short>
          <var>Assign</var> - copies anchoring information from 
          <var>Source</var> if it is of the same type as the current control, otherwise calls inherited 
          <var>Assign</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TAnchorSide.Assign.Source">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TAnchorSide.Owner">
        <short>
          <var>Owner</var> - the Control that owns the current control that is to be anchored</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TAnchorSide.Kind">
        <short>The <var>Kind</var> of anchoring to be used</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TAnchorSide.Control">
        <short>The control whose anchoring properties are being determined</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TAnchorSide.Side">
        <short>The side on which anchoring is to be performed</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlActionLink">
        <short>
          <var>TControlActionLink</var> - links the current control to an action</short>
        <descr>
          <p>
            <var>TControlActionLink</var> - links the current control to an action</p>
          <p>Defines a number of protected methods (inherited from <link id="#lcl.ActnList.TActionLink">TActionLink</link>) for checking which parts of the control are linked to the action</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: protected -->
      <element name="TControlActionLink.FClient">
        <short>Local variable that identifies the client control that is to be linked to the action</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#rtl.Classes.TBasicActionLink.AssignClient" name="TControlActionLink.AssignClient">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlActionLink.AssignClient.AClient">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.ActnList.TActionLink.IsCaptionLinked" name="TControlActionLink.IsCaptionLinked">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlActionLink.IsCaptionLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.ActnList.TActionLink.IsEnabledLinked" name="TControlActionLink.IsEnabledLinked">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlActionLink.IsEnabledLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.ActnList.TActionLink.IsHelpLinked" name="TControlActionLink.IsHelpLinked">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlActionLink.IsHelpLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.ActnList.TActionLink.IsHintLinked" name="TControlActionLink.IsHintLinked">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlActionLink.IsHintLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.ActnList.TActionLink.IsVisibleLinked" name="TControlActionLink.IsVisibleLinked">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlActionLink.IsVisibleLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlActionLink.IsOnExecuteLinked">
        <short>
          <var>IsOnExecuteLinked</var> - returns True if the OnExecute event is linked</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlActionLink.IsOnExecuteLinked.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlActionLink.DoShowHint">
        <short>
          <var>DoShowHint</var> - method to display hint; returns True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlActionLink.DoShowHint.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlActionLink.DoShowHint.HintStr">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetCaption">
        <short>
          <var>SetCaption</var> - specifies the caption for the control</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.ActnList.TActionLink.SetCaption">TActionLink.SetCaption</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlActionLink.SetCaption.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetEnabled">
        <short>
          <var>SetEnabled</var> - specifies whether or not the link is enabled</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlActionLink.SetEnabled.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHint">
        <short>
          <var>SetHint</var> - specifies the string to use for the hint</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlActionLink.SetHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHelpContext">
        <short>
          <var>SetHelpContext</var> - specifies the context-based help variable to use</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlActionLink.SetHelpContext.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHelpKeyword">
        <short>
          <var>SetHelpKeyword</var> - specifies the help keyword</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlActionLink.SetHelpKeyword.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetHelpType">
        <short>
          <var>SetHelpType</var> - specifies the type of help to use</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlActionLink.SetHelpType.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetVisible">
        <short>
          <var>SetVisible</var> - specifies the visiblity</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlActionLink.SetVisible.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlActionLink.SetOnExecute">
        <short>
          <var>SetOnExecute</var> - specifies the Execute event handler</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlActionLink.SetOnExecute.Value">
        <short/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TControlActionLinkClass">
        <short>
          <var>TControlActionLinkClass</var> - class of 
          <var>TControlActionLink</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TTabOrder">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TControlShowHintEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlShowHintEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlShowHintEvent.HintInfo">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TContextPopupEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TContextPopupEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TContextPopupEvent.MousePos">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TContextPopupEvent.Handled">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlFlag">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfRequestAlignNeeded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfClientWidthLoaded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfClientHeightLoaded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfLastAlignedBoundsValid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfBoundsRectForNewParentValid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfPreferredSizeValid">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlFlags">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlHandlerType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlHandlerType.chtOnResize">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlHandlerType.chtOnChangeBounds">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TControl">
        <short>
          <var>TControl</var> - the main ancestor class for visual controls.</short>
        <descr>
          <p>
            <var>TControl</var>

 is the main ancestor class for all visual controls.</p>
          <p>The definition includes a large number of constants, types and methods that are inherited by derived classes and types.</p>
          <p>These include devices for defining and controlling: </p>
          <ul>
            <li>the state and position of the object (including alignment and anchoring),</li>
            <li>the state of the mouse, </li>
            <li>whether dragging or docked, </li>
            <li>the size and type of border,</li>
            <li>the way child components should behave, </li>
            <li>the actions to be taken in response to various events, </li>
            <li>and the way the Control should be drawn.</li>
          </ul>
          <p>Properties defined here can be overridden by descendant classes.</p>
        </descr>
        <seealso>
          <link id="#lcl.lclClasses.TLCLComponent">TLCLComponent</link>
          <link id="#rtl.Classes.TComponent">TComponent</link>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FActionLink">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FAlign">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FAnchors">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FAnchorSides">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FAutoSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FBaseBounds">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FBaseBoundsLock">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FBaseParentClientSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FBorderSpacing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FBoundsRectForNewParent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FCaption">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FConstraints">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FControlFlags">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FControlHandlers">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FControlStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FCtl3D">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FCursor">
        <short>Flag showing position of cursor</short>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FDockOrientation">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FDragCursor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FDragKind">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FDragMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FEnabled">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FFloatingDockSiteClass">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FFont">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FHelpContext">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FHelpKeyword">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FHelpType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FHint">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FHostDockSite">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FIsControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.fLastAlignedBounds">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FLastChangebounds">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FLastDoChangeBounds">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FLastResizeClientHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FLastResizeClientWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FLastResizeHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FLastResizeWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FLeft">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FLoadedClientSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FLRDockWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FMouseEntered">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnChangeBounds">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnClick">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnConstrainedResize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnContextPopup">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnDblClick">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnDragDrop">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnDragOver">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnEditingDone">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnEndDock">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnEndDrag">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnMouseDown">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnMouseEnter">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnMouseLeave">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnMouseMove">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnMouseUp">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnQuadClick">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnResize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnShowHint">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnStartDock">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnStartDrag">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FOnTripleClick">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FParent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FParentColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FParentFont">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FParentShowHint">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FPopupMenu">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FPreferredWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FPreferredHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FSessionProperties">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FShowHint">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FSizeLock">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FTBDockHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FTop">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FUndockHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FUndockWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FVisible">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FWindowProc">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoActionChange">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoActionChange.Sender">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetAnchorSide">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetAnchorSide.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetAnchorSide.Kind">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetAnchorSideIndex">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetAnchorSideIndex.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetAnchorSideIndex.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetBoundsRect">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetBoundsRect.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetClientHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetClientHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetClientWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetClientWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetLRDockWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetLRDockWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetMouseCapture">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetMouseCapture.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetTBDockHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetTBDockHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetText">
        <short>Function to get text-string associated with control</short>
        <descr>Uses RealGetText rather than GetTextBuf to avoid unnecessary read-writes to PChar buffers</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.GetTextBuf">GetTextBuf</link>
          <link id="#lcl.Controls.TControl.RealGetText"/>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetText.Result">
        <short>The function returns the required text as a string</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetUndockHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetUndockHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetUndockWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetUndockWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsAnchorsStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsAnchorsStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsCaptionStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsCaptionStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsColorStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsColorStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsEnabledStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsEnabledStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsFontStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsFontStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsHintStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsHintStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsHelpContextStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsHelpContextStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsHelpKeyWordStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsHelpKeyWordStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsOnClickStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsOnClickStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsShowHintStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsShowHintStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsVisibleStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsVisibleStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.CheckMenuPopup">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.CheckMenuPopup.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CheckMenuPopup.P">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoBeforeMouseMessage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoConstrainedResize">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoConstrainedResize.NewLeft">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoConstrainedResize.NewTop">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoConstrainedResize.NewWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoConstrainedResize.NewHeight">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoMouseDown">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoMouseDown.Message">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoMouseDown.Button">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoMouseDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.DoMouseUp">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoMouseUp.Message">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoMouseUp.Button">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetAnchorSideIndex">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetAnchorSideIndex.Index">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetAnchorSideIndex.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetBorderSpacing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBorderSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetBoundsRect">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBoundsRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetBoundsRectForNewParent">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBoundsRectForNewParent.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetClientHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetClientHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetClientSize">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetClientSize.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetClientWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetClientWidth.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetConstraints">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetConstraints.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetCursor">
        <short>Procedure to set the position of the cursor</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetCursor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetDragCursor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetDragCursor.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetFont">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetFont.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetHeight">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetHeight.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetHelpContext">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetHelpContext.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetHelpKeyword">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetHelpKeyword.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetHostDockSite">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetHostDockSite.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetLeft">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetLeft.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetMouseCapture">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetMouseCapture.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetParentShowHint">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetParentShowHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetParentColor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetParentColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetPopupMenu">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetPopupMenu.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetShowHint">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetShowHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetText">
        <short>Stores text in buffer</short>
        <descr>Uses RealSetText rather than SetTextBuf to avoid unnecessary read-writes to PChar buffer</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.RealSetText">RealSetText</link>
          <link id="#lcl.Controls.TControl.SetTextBuf">SetTextBuf</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetText.Value">
        <short>The text string to be stored in the buffer</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetTop">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetTop.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetVisible">
        <short>Procedure to set Visible flag and ensure the control can be seen</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetVisible.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetWidth.Value">
        <short/>
      </element>
      <!-- variable Visibility: protected -->
      <element name="TControl.FControlState">
        <short>Flag showing the set of states for this control</short>
        <seealso>
          <link id="#lcl.Controls.TControlState"/>
        </seealso>
      </element>
      <!-- variable Visibility: protected -->
      <element name="TControl.AutoSizing">
        <short>Is autosizing proceeding?</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoAutoSize">
        <short>
          <var>DoAutoSize </var>- method for actually performing the AutoSize</short>
        <descr>
          <p>
            <var>TControl.DoAutoSize</var>
          </p>
          <p>IMPORTANT: Many Delphi controls override this method and many call this method directly after setting some properties.</p>
          <p>During handle creation not all interfaces can create complete Device Contexts which are needed to calculate things like text size.</p>
          <p>That's why you should always call <link id="#lcl.Controls.TControl.AdjustSize">AdjustSize</link> instead of <var>DoAutoSize</var>.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.AutoSize">AutoSize topic</link>
          <link id="#lcl.Controls.TControl.AdjustSize">TControl.AdjustSize</link>
        </seealso>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.AutoSizeCanStart">
        <short>
          <var>AutoSizeCanStart</var> - checks whether  <var>DoAutoSize</var> is permitted to start</short>
        <descr>
          <p>
            <printshort id="TControl.AutoSizeCanStart"/>
          </p>
          <pre>function TControl.AutoSizeCanStart: boolean;
  
  Returns true if DoAutoSize can start. That means, it tests the minimum
  requirements to start. Some controls need even more.

  It returns false if
  - AutoSize=false
  - or the control is currently autosizing
  - or the control is not visible
  - or the control is destroying

</pre>
        </descr>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.AutoSizeCanStart.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.AnchorSideChanged">
        <short>Procedure invoked when the anchor side is changed</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorSideChanged.TheAnchorSide">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetAlign">
        <short>Set up the Align rules for this control</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetAlign.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetAnchors">
        <short>Set the rules for anchoring this control</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetAnchors.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetAutoSize">
        <short>Set the boolean variable that determines whether autosize can function</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetAutoSize.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.BoundsChanged">
        <short>Procedure invoked when bounds of the control are changed</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoConstraintsChange">
        <short>Procedure to execute a change in the control's constraints</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoConstraintsChange.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoBorderSpacingChange">
        <short>Procedure to execute a change in the control's border spacing</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoBorderSpacingChange.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SendMoveSizeMessages">
        <short>Send a message to the system if the size and/or position of the control change</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SendMoveSizeMessages.SizeChanged">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SendMoveSizeMessages.PosChanged">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ConstrainedResize">
        <short>Procedure for performing a resize within defined boundaries (constraints)</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ConstrainedResize.MinWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ConstrainedResize.MinHeight">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ConstrainedResize.MaxWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ConstrainedResize.MaxHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CalculatePreferredSize">
        <short>
          <var>CalculatePreferredSize</var>
   - find default/preferred height and width</short>
        <descr>
          <p>
            <var>CalculatePreferredSize</var>
  - find default/preferred height and width</p>
          <p>procedure TControl.CalculatePreferredSize </p>
          <p>(var PreferredWidth, PreferredHeight: integer; WithThemeSpace: Boolean);</p>
          <p>Calculates the default/preferred width and height for a control, which is used
  by the LCL autosizing algorithms as default size. Only positive values are
  valid. Negative or 0 are treated as undefined and the LCL uses other sizes
  instead.</p>
          <p>
            <var>TWinControl</var>
 overrides this and asks the interface for theme dependent values.
  See 
            
            <link id="#lcl.Controls.TWinControl.CalculatePreferredSize">TWinControl.CalculatePreferredSize</link> for more information.</p>
          <p>WithThemeSpace: If true, adds space for stacking.</p>
          <p>For example: <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be
  some space around. This space is theme dependent, so the parameter is passed to the widgetset.</p>
        </descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CalculatePreferredSize.PreferredWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CalculatePreferredSize.PreferredHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoOnResize">
        <short>Calls <var>OnResize</var>
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoOnChangeBounds">
        <short>Calls the <var>OnChangeBounds</var> event handler</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Resize">
        <short>Checks for changes and calls <var>DoOnResize</var>
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.RequestAlign">
        <short>Smart calling <var>Parent.AlignControls</var>
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UpdateBaseBounds">
        <short>Update the basic boundaries of the control - essential if there has been a lot of re-sizing</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.UpdateBaseBounds.StoreBounds">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.UpdateBaseBounds.StoreParentClientSize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.UpdateBaseBounds.UseLoadedValues">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.LockBaseBounds">
        <short>Lock the base bounds, so that they do not change even if surrounding controls are changed</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UnlockBaseBounds">
        <short>Unlock the base bounds so that they are free to change as surrounding controls are changed</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UpdateAnchorRules">
        <short>Update the rules for anchoring the control</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ChangeBounds">
        <short>Procedure for altering the bounds of the control</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ChangeBounds.ALeft">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ChangeBounds.ATop">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ChangeBounds.AWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ChangeBounds.AHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoSetBounds">
        <short>Perform the actual setting of the boundary rectangle</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoSetBounds.ALeft">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoSetBounds.ATop">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoSetBounds.AWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoSetBounds.AHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ChangeScale">
        <short>Change the scale factor (multiplier or divider) for drawing the control</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ChangeScale.Multiplier">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ChangeScale.Divider">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.CanAutoSize">
        <short>Function to determine if autosizing is possible, and if so, gets the new width and height</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.CanAutoSize.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CanAutoSize.NewWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CanAutoSize.NewHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetAlignedBounds">
        <short>Try to set the automatic changed bounds</short>
        <descr>
          <pre>{ try to set the automatic changed bounds
  If the interface does not like our bounds, it sends a message with the real
  bounds, which invokes the automatic realigning of the control, .. a circle.
  To break the circle, only bounds that are different from the last try will
  be sent.
}</pre>
        </descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetAlignedBounds.aLeft">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetAlignedBounds.aTop">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetAlignedBounds.aWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetAlignedBounds.aHeight">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetClientOrigin">
        <short>Find the origin (top left pixel) of the client control</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetClientOrigin.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetClientRect">
        <short>Visual size of client area</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetClientRect.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetScrolledClientRect">
        <short>Visual client area scrolled</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetScrolledClientRect.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetChildsRect">
        <short>Gets the rectangular co-ordinates for a child control</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetChildsRect.Result">
        <short>The function returns the coordinates of the child rectangle</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetChildsRect.Scrolled">
        <short>True if the rectangle is scrolled</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetClientScrollOffset">
        <short>Find the offset for scrolling of the client</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetClientScrollOffset.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetControlOrigin">
        <short>Find the origin (top left pixel) of this control</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetControlOrigin.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonDown">
        <short>Protected messages to system - when left mouse button is down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMLButtonDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonDown">
        <short>Protected messages to system - when right mouse button is down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMRButtonDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonDown">
        <short>Protected messages to system - when middle button is down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMMButtonDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonDBLCLK">
        <short>Protected messages to system - when left button is double-clicked</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMLButtonDBLCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonDBLCLK">
        <short>Protected messages to system - when right button is double-clicked</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMRButtonDBLCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonDBLCLK">
        <short>Protected messages to system - when middle button is double-clicked</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMMButtonDBLCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonTripleCLK">
        <short>Protected messages to system - when left button is triple-clicked</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMLButtonTripleCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonTripleCLK">
        <short>Protected messages to system - when right button is triple-clicked</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMRButtonTripleCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonTripleCLK">
        <short>Protected messages to system - when middle button is triple-clicked</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMMButtonTripleCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonQuadCLK">
        <short>Protected messages to system - when left button is quadruple-clicked</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMLButtonQuadCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonQuadCLK">
        <short>Protected messages to system - when right button is quadruple-clicked</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMRButtonQuadCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonQuadCLK">
        <short>Protected messages to system - when middle button is quadruple-clicked</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMMButtonQuadCLK.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMouseMove">
        <short>Protected messages to system - when mouse cursor has moved</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMMouseMove.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMLButtonUp">
        <short>Protected messages to system - when left button is up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMLButtonUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMRButtonUp">
        <short>Protected messages to system - when right button is up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMRButtonUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMButtonUp">
        <short>Protected messages to system - when middle button is up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMMButtonUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMDragStart">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMDragStart.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMMove">
        <short>Protected messages to system - when the control is moved</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMMove.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMSize">
        <short>Protected messages to system - when control is sized</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMSize.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMWindowPosChanged">
        <short>Protected messages to system - when window position is changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMWindowPosChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.LMCaptureChanged">
        <short>LCL Message when capture method is changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.LMCaptureChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMEnabledChanged">
        <short>Control Message when Enabled status is changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CMEnabledChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMHitTest">
        <short>Control Message for Hit Test</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CMHitTest.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMMouseEnter">
        <short>Control Message for entry of mouse</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CMMouseEnter.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMMouseLeave">
        <short>Control Message for exit of mouse</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CMMouseLeave.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMHintShow">
        <short>Control message for showing a hint</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CMHintShow.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMParentColorChanged">
        <short>Control Message for a change in parent colour</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CMParentColorChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMParentShowHintChanged">
        <short>Control Message for a change in parent hinting status</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CMParentShowHintChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMVisibleChanged">
        <short>Control Message for a change in visibility</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CMVisibleChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CalculateDockSizes">
        <short>Calculate the sizes required for docking</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.CreateFloatingDockSite">
        <short>Create a floating dock site within the Bounds specified as an argument</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.CreateFloatingDockSite.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CreateFloatingDockSite.Bounds">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDockEdge">
        <short>Find out which edge is used for docking (returned in Result)</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetDockEdge.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetDockEdge.MousePos">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetFloating">
        <short>Find out (true or false) whether the control is floating (as opposed to fixed)</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetFloating.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetFloatingDockSiteClass">
        <short>Returns the class of the floating dock site</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetFloatingDockSiteClass.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.BeginAutoDrag">
        <short>Start the AutoDrag process</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DefaultDockImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DefaultDockImage.DragDockObject">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DefaultDockImage.Erase">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DockTrackNoTarget">
        <short>Track the docking process when no target has been specified</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DockTrackNoTarget.Source">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DockTrackNoTarget.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DockTrackNoTarget.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoDock">
        <short>Perform the docking manoeuvre to the new dock site at the position specified by ARect</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoDock.NewDockSite">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoDock.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoDragMsg">
        <short>
          <var>DoDragMsg</var> - sends a drag message at specified position for nominated object and target; returns an integer Result for success</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoDragMsg.DragMsg">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoEndDock">
        <short>End the docking process</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoEndDock.Target">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoEndDock.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoEndDock.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoEndDrag">
        <short>End the dragging process</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoEndDrag.Target">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoEndDrag.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoEndDrag.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoStartDock">
        <short>Start the docking process</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoStartDock.DragObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoStartDrag">
        <short>
          <var>DoStartDrag</var> - start performing the drag</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoStartDrag.DragObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DragCanceled">
        <short>
          <var>DragCanceled</var> - method for signalling that a drag is cancelled</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DragOver">
        <short>Drag the control over the source; <var>Accept</var> determines if the dragged object will be accepted</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DragOver.Source">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DragOver.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DragOver.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DragOver.State">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DragOver.Accept">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DrawDragDockImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DrawDragDockImage.DragDockObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.EraseDragDockImage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.EraseDragDockImage.DragDockObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.PositionDockRect">
        <short>
          <var>PositionDockRect</var> - place the nominated Drag-Dock object in the Rectangle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.PositionDockRect.DragDockObject">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetDragMode">
        <short>
          <var>SetDragMode</var> - specify the mode for dragging</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetDragMode.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Click">
        <short>
          <var>Click</var> - a procedure that allows the programmer to simulate a mouse click over the control, and initiates the same           
          <var>Action</var> as that associated with the           
          <link id="#lcl.Controls.TControl.OnClick">OnClick</link> event</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DblClick">
        <short>
          <var>DblClick</var>   - a procedure that allows the programmer to simulate a mouse double-click over the control, and initiates the same           
          <var>Action</var>  as that associated with the 	  
          <link id="#lcl.Controls.TControl.OnDblClick">OnDblClick</link>  event</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.TripleClick">
        <short>
          <var>TripleClick</var>   - a procedure that allows the programmer to simulate a mouse triple-click over the control, and initiates the same           
          <var>Action</var>  as that associated with the 	  
          <link id="#lcl.Controls.TControl.OnTripleClick">OnTripleClick</link> event</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.QuadClick">
        <short>
          <var>QuadClick</var>   - a procedure that allows the programmer to simulate a mouse quadruple-click over the control, and initiates the same           
          <var>Action</var>  as that associated with the 	  
          <link id="#lcl.Controls.TControl.OnQuadClick">OnQuadClick</link>  event</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseDown">
        <short>
          <var>MouseDown</var>   - a procedure that allows the programmer to simulate a mouse button being down over the control, and initiates the same           
          <var>Action</var>  as that associated with the 	  
          <link id="#lcl.Controls.TControl.OnMouseDown">OnMouseDown</link>  event</short>
        <descr>
          <p>
            <var>MouseDown</var>   - a procedure that allows the programmer to simulate a mouse button being down over the control, and initiates the same 
            
            <var>Action</var>  as that associated with the 
	    
            <link id="#lcl.Controls.TControl.OnMouseDown"/>  event</p>
          <p>
            <var>Button</var> specifies which mouse button; 
            
            <var>Shift</var> signifies whether Ctrl, Shift or Alt keys are also pressed; 
            
            <var>X, Y</var> show mouse position</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.MouseDown.Button">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.MouseDown.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.MouseDown.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.MouseDown.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseMove">
        <short>
          <var>MouseMove</var>   - a procedure that allows the programmer to simulate a mouse being moved over the control, and initiates the same           
          <var>Action</var>  as that associated with the 	  
          <link id="#lcl.Controls.TControl.OnMouseMove">OnMouseMove</link>  event</short>
        <descr>
          <p>
            <var>MouseMove</var>   - a procedure that allows the programmer to simulate a mouse being moved over the control, and initiates the same 
            
            <var>Action</var>  as that associated with the 
	    
            <link id="#lcl.Controls.TControl.OnMouseMove"/>  event</p>
          <p>
            <var>Shift</var> signifies whether Ctrl, Shift or Alt keys are also pressed; 
            
            <var>X, Y</var> show mouse position</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.MouseMove.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.MouseMove.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.MouseMove.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseUp">
        <short>
          <var>MouseUp</var>   - a procedure that allows the programmer to simulate a mouse button being Up over the control, and initiates the same           
          <var>Action</var>  as that associated with the 	  
          <link id="#lcl.Controls.TControl.OnMouseUp">OnMouseUp</link>  event</short>
        <descr>
          <p>
            <var>MouseUp</var>   - a procedure that allows the programmer to simulate a mouse button being Up over the control, and initiates the same 
            
            <var>Action</var>  as that associated with the 
	    
            <link id="#lcl.Controls.TControl.OnMouseUp"/>  event</p>
          <p>
            <var>Button</var> specifies which mouse button; 
            
            <var>Shift</var> signifies whether Ctrl, Shift or Alt keys are also pressed; 
            
            <var>X, Y</var> show mouse position</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.MouseUp.Button">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.MouseUp.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.MouseUp.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.MouseUp.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseEnter">
        <short>
          <var>MouseEnter</var> - a procedure that allows the programmer to simulate a mouse entering the control, and initiates the same           
          <var>Action</var> as that associated with the 	  
          <link id="#lcl.Controls.TControl.OnMouseEnter">OnMouseEnter</link> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.MouseLeave">
        <short>
          <var>MouseLeave</var> - a procedure that allows the programmer to simulate a mouse leaving the control, and initiates the same           
          <var>Action</var> as that associated with the 	  
          <link id="#lcl.Controls.TControl.OnMouseLeave">OnMouseLeave</link> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.DialogChar">
        <short>
          <var>DialogChar</var> - a LCL Key Message; returns True if a Dialog character has an associated message</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.DialogChar.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DialogChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Changed">
        <short>
          <var>Changed</var> - method to signal that a change has occured</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetPalette">
        <short>
          <var>GetPalette</var> - returns a handle to the palette for this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetPalette.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.ChildClassAllowed">
        <short>
          <var>ChildClassAllowed</var> - returns True if the specified class is allowed to be a child of this class</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.ChildClassAllowed.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ChildClassAllowed.ChildClass">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Loaded">
        <short>
          <var>Loaded</var> - called when the component has finished loading. Calls inherited 
          <var>Loaded</var> then copies various properties from client and parent</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TComponent.Loaded">TComponent.Loaded</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DefineProperties">
        <short>
          <var>DefineProperties</var> - declare any properties not specified elsewhere</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TComponent.DefineProperties">TComponent.DefineProperties</link>
          <link id="#rtl.Classes.TPersistent.DefineProperties">TPersistent.DefineProperties</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DefineProperties.Filer">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.AssignTo">
        <short>
          <var>AssignTo</var> - if the Destination is a CustomAction, copies some specified properties to the Destination, otherwise calls inherited 
          <var>AssignTo</var>
        </short>
        <descr>
          <p>
            <var>AssignTo</var> - if the Destination is a CustomAction, copies some specified properties to the Destination, otherwise calls inherited 
            <var>AssignTo</var>
          </p>
          <p>The copied properties are:</p>
          <ul>
            <li>Enabled</li>
            <li>Hint</li>
            <li>Caption</li>
            <li>Visible</li>
            <li>OnExecute (copied to OnClick)</li>
            <li>HelpContext</li>
            <li>HelpKeyword</li>
            <li>HelpType</li>
          </ul>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TPersistent.AssignTo">TPersistent.AssignTo</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AssignTo.Dest">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.InvalidateControl">
        <short>
          <var>InvalidateControl</var> - method to render the Control non-valid; visibility and opacity are specified</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.InvalidateControl.CtrlIsVisible">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.InvalidateControl.CtrlIsOpaque">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.InvalidateControl">
        <short>
          <var>InvalidateControl</var> - method to render the Control non-valid; visibility and opacity are specified and instructions can be given to ignore Window Controls</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.InvalidateControl.CtrlIsVisible">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.InvalidateControl.CtrlIsOpaque">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.InvalidateControl.IgnoreWinControls">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.FontChanged">
        <short>
          <var>FontChanged</var> - method for dealing with a changed font</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetAction">
        <short>Find the action needed for operation of this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetAction.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.RealGetText">
        <short>Function to get a text-string associated with the control</short>
        <descr>This is the function that is actually used by <var>GetTextBuf</var>, and loads a string rather than performing read-write to a <var>PChar</var> buffer
</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.GetTextBuf">GetTextBuf</link>
          <link id="#lcl.Controls.TControl.RealSetText">RealSetText</link>
          <link id="#lcl.Controls.TControl.SetTextBuf">SetTextBuf</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.RealGetText.Result">
        <short>The Function returns the required text as a string</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.RealSetText">
        <short>Procedure to store text associated with the control in a string</short>
        <descr>This is the procedure that is actually used by <var>SetTextBuf,</var> and stores text as a string rather than performing read-write to a <var>PChar</var> buffer
</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.SetTextBuf">SetTextBuf</link>
          <link id="#lcl.Controls.TControl.RealGetText">RealGetText</link>
          <link id="#lcl.Controls.TControl.GetTextBuf">GetTextBuf</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.RealSetText.Value">
        <short>The text-string that is to be stored</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetAction">
        <short>Set up the action to be associated with this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetAction.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetColor">
        <short>Set up the colour to be used by the control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetEnabled">
        <short>Set up the flag to determine whether the control is to be enabled</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetEnabled.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetHint">
        <short>Set up the hinting pop-up for this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetHint.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetName">
        <short>Set the name of the control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetName.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetParent">
        <short>Find who the parents are and store the information</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetParent.NewParent">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.SetParentComponent">
        <short>
          <var>SetParentComponent</var> - specify a new component to be the parent</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetParentComponent.NewParentComponent">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WndProc">
        <short>
          <var>WndProc</var> - message handler for the procedure of this window</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WndProc.TheMessage">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ParentFormHandleInitialized">
        <short>
          <var>ParentFormHandleInitialized </var>
- called by 
          
          <var>ChildHandlesCreated</var> of parent form</short>
        <descr>
          <p>The form is a real connection to the target screen.</p>
          <p>For example, the gtk under X gathers some screen information, but not before form creation. </p>
          <p>But this information is needed to create DeviceContexts, which are needed to calculate Text Size and such stuff needed for AutoSizing. </p>
          <p>That's why AdjustSize delays AutoSizing till this moment. </p>
          <p>Now do the AutoSize.</p>
        </descr>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CaptureChanged">
        <short>
          <var>CaptureChanged</var> - the method for data capture has changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.Notification">
        <short>
          <var>Notification</var> - calls inherited 
          <var>Notification</var>, then takes action depending on Operation</short>
        <descr>
          <p>
            <var>Notification</var> - calls inherited 
            <var>Notification</var>, then takes action depending on Operation</p>
          <p>If Operation is removal, then nullifies any popupmenus or actions.</p>
          <p>Disconnects all anchors.</p>
        </descr>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TComponent.Notification">TComponent.Notification</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.Notification.AComponent">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.Notification.Operation">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.CanTab">
        <short>
          <var>CanTab</var> - if True, the Tab key can be used to navigate to this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.CanTab.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDeviceContext">
        <short>
          <var>GetDeviceContext</var> - returns a device handle to correspond with the nominated 
          <var>WindowHandle</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetDeviceContext.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetDeviceContext.WindowHandle">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetEnabled">
        <short>
          <var>GetEnabled</var> - returns the 
          <var>Enabled</var> status</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetEnabled.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetPopupMenu">
        <short>
          <var>GetPopupMenu</var> - returns a popup menu for use with this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetPopupMenu.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoOnShowHint">
        <short>
          <var>DoOnShowHint</var> - perform the code for the 
          <var>OnShowHint</var> event handler</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoOnShowHint.HintInfo">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.VisibleChanging">
        <short>
          <var>VisibleChanging</var> - method to use when the 
          <var>Visible</var> property is changing</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.AddHandler">
        <short>
          <var>AddHandler</var> - add a control handler of the nominated type, using the specified method</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AddHandler.HandlerType">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AddHandler.AMethod">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AddHandler.AsLast">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.RemoveHandler">
        <short>
          <var>RemoveHandler</var> - remove a control handler of the nominated type, using the specified method</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.RemoveHandler.HandlerType">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.RemoveHandler.AMethod">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoContextPopup">
        <short>
          <var>DoContextPopup</var> - perform the action to display a context-sensitive popup window, at the specified mouse position</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoContextPopup.MousePos">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoContextPopup.Handled">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetActionLinkClass">
        <short>
          <var>GetActionLinkClass</var> - returns the class of the action link</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetActionLinkClass.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ActionChange">
        <short>
          <var>ActionChange</var> - method for changing an action</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ActionChange.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ActionChange.CheckDefaults">
        <short/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ActionLink">
        <short>Link to the default action associated with this control</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.AutoSize">
        <short>Whether auto-size is to be used</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>AutoSize permits the size of a control to be adjusted automatically, for example a button can become bigger or smaller to accommodate a longer or shorter caption.</p>
          <p>Reads logical (boolean) flag to see whether auto-sizing is to be operated, or writes the flag to say it should be done. Default is false, ie no auto-sizing</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.Autosize">Autosize topic</link>
        </seealso>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.Ctl3D">
        <short>
          <var>Ctl3D</var> - retained for Delphi compatibility; even there it is deprecated</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.DragCursor">
        <short>
          <var>DragCursor </var>
- the style of cursor to be used during the Drag process</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.DragKind">
        <short>
          <var>DragKind</var> - what sort of dragging? Drag or Dock</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.DragMode">
        <short>
          <var>DragMode </var>
- whether manual or automatic</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.MouseCapture">
        <short>Is the mouse position captured?</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ParentFont">
        <short>
          <var>ParentFont </var>
- should the control use the same font as the parent? Default is true</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ParentColor">
        <short>
          <var>ParentColor</var>
 - should the control have the same colour as the parent? Default is true</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.ParentShowHint">
        <short>
          <var>ParentShowHint </var>
- does the control adopt the same hinting behaviour as its parent? Default is true</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.SessionProperties">
        <short>The stored (saved) properties of the current session, expressed as a string</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.Text">
        <short>
          <var>Text </var>
- the character string in the name or caption of the control</short>
        <descr>
          <p>
            <var>Text </var>
- the character string in the name or caption of the control</p>
          <p>But BEWARE: <var>Text</var> is used in another context in editing controls such as <link id="#lcl.StdCtrls.TEdit">TEdit</link> and <link id="#lcl.StdCtrls.TCustomEdit">TCustomEdit</link>, <link id="#lcl.ExtCtrls.TLabeledEdit">TLabeledEdit</link> and <link id="#lcl.ExtCtrls.TCustomLabeledEdit">TCustomLabeledEdit</link>, where it contains the character string that is being edited in the Edit Box.</p>
        </descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnConstrainedResize">
        <short>Event Handler for constrained resize</short>
        <descr>
          <p>Event handler needs to be supplied to cover the need to resize a control within the given constraints of maximum and minimum width and height</p>
        </descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnContextPopup">
        <short>Event handler to supply information when a context-sensitive pop-up menu is required</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnDblClick">
        <short>Event Handle for mouse double-click</short>
        <descr>
          <p>Double-clicking is much more common in a Windows environment than in Unix or Linux, where single-clicking is the default method for selecting an object. However, in all environments there could be valid use for a double-click, and a method should be supplied if appropriate.</p>
        </descr>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnTripleClick">
        <short>Event handler for mouse triple-click</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnQuadClick">
        <short>Event handler for quadruple click</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnDragDrop">
        <short>Event handler for the Drag-Drop manoeuvre</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnDragOver">
        <short>Event handler for the case when a control is dragged over another control</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnEndDock">
        <short>Event handler for the end of a docking manoeuvre</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnEndDrag">
        <short>Event handler for the end of a dragging process</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseDown">
        <short>Event handler for when a mouse button is pressed down</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseMove">
        <short>Event handler for mouse movement within the current control</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseUp">
        <short>Event handler for when the mouse button is released, ie "up"</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseEnter">
        <short>Event handler for when the mouse enters the area of the current control</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnMouseLeave">
        <short>Event handler for when the mouse leaves the area of the current control</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnStartDock">
        <short>Event handler for the start of a docking manoeuvre</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnStartDrag">
        <short>Event handler for start of dragging process</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TControl.OnEditingDone">
        <short>Event handler when editing is done</short>
      </element>
      <!-- variable Visibility: public -->
      <element name="TControl.FCompStyle">
        <short>
          <var>FCompStyle</var>
 - deprecated</short>
        <descr>
          <pre>// DEPRECATED. Enables (valid) use of 'IN' operator (this
      // is a hack for speed. It will be replaced by the use of the widgetset
      // classes.
      // So, don't use it anymore.        
</pre>
        </descr>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.DragDrop">
        <short>
          <var>DragDrop</var> - Procedure to govern Dragging/Dropping of control</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DragDrop.Source">
        <short>The object to be dragged and dropped</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DragDrop.X">
        <short>The X co-ordinate to which the object is to be dropped (target)</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DragDrop.Y">
        <short>The Y co-ordinate to which the object is to be dropped (target)</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Dock">
        <short>
          <var>Dock</var>
 - Procedure governing Docking of Control</short>
        <descr>
          <p>
            <var>Dock</var>
 - Procedure governing Docking of Control</p>
          <p>Performs checks that there is already a valid host control to which the present control is to be docked, removes old controls from the list of docked controls and adds the new control to the list, then calls <link id="#lcl.Controls.TControl.DoDock">DoDock</link> to perform the actual docking process</p>
        </descr>
        <errors>An exception is raised if there is already a docking process in progress for this control</errors>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.Dock.NewDockSite">
        <short>The host control to which which the current control is to be docked</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.Dock.ARect">
        <short>The position at which the control is to be docked</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ManualDock">
        <short>
          <var>ManualDock</var>
 - permits operator-defined docking</short>
        <descr>
          <p>Docks this control to DropControl or on NewDockSite.</p>
          <p>If DropControl is not <b>nil</b>, ControlSide defines on which side of DropControl this control is docked. (alNone,alClient for stacked in pages). DropControl will become part of a TDockManager.</p>
          <p>If DropControl is <b>nil</b>, then DropControl becomes a normal child of NewDockSite and ControlSide is ignored.</p>
        </descr>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.ManualDock.Result">
        <short>The function returns True if a manual dock has been successfully performed</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ManualDock.NewDockSite">
        <short>The new site to which the control is docked, if DropControl has been found to be <b>nil</b>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ManualDock.DropControl">
        <short>If <b>nil</b> (default) then ignored else used as the control for docking, on side specified by ControlSide</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ManualDock.ControlSide">
        <short>The side on which the control is to be docked, if DropControl is not <b>nil</b>
        </short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ManualFloat">
        <short>
          <var>ManualFloat</var>
 - the opposite of 
          
          <var>ManualDock</var>, allows operator to Float a control</short>
        <descr>
          <pre>function TControl.ManualFloat(TheScreenRect: TRect;
    KeepDockSiteSize: Boolean = true): Boolean;

  Undock and float.
  Float means here: create the floating dock site and dock this control into it.
  Exception: Forms do not need float dock sites and float on their own.

</pre>
        </descr>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.ManualFloat.Result">
        <short>The function returns True if a manual float has been succesfully performed</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ManualFloat.TheScreenRect">
        <short>The rectangle within which the floating control is located</short>
        <descr>The rectangle within which the floating control is located <br/>(ie the location of the floating dock site to which the control is docked)</descr>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ReplaceDockedControl">
        <short>Remove a previously docked control and put a new control in its place</short>
        <descr>Checks to see whether there is a previously docked control, <br/>and removes it, then puts the new control in its place</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.ManualDock">ManualDock</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.ReplaceDockedControl.Result">
        <short>Returns True if a docked control has been successfully replaced with a new one</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ReplaceDockedControl.Control">
        <short>The old control that was previously docked at this site</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ReplaceDockedControl.NewDockSite">
        <short>The new site for docking; used if DropControl is <b>nil</b>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ReplaceDockedControl.DropControl">
        <short>The control site to be used for docking, unless it is <b>nil</b> when it is igored. Passed straight through as an argument to ManualDock</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ReplaceDockedControl.ControlSide">
        <short>The side to which the new control is to be aligned; passed straight through as an argument to ManualDock</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.Dragging">
        <short>Returns True if the control is being dragged</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.Dragging.Result">
        <short>Returns True if the control is being dragged</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AdjustSize">
        <short>
          <var>AdjustSize</var> - Smart way to  <var>DoAutoSize</var>
        </short>
        <descr>
          <p>
            <var>TControl.AdjustSize</var>
 calls 
            
            <var>DoAutoSize</var> in a smart fashion.</p>
          <p>During loading and handle creation the calls are delayed.</p>
          <p>This method initially does the same as <var>TWinControl.DoAutoSize</var>.  But since <var>DoAutoSize</var> is commonly overriden by descendant components,  it is not useful to perform all tests, which can result in too much overhead. To reduce this the LCL calls <var>AdjustSize</var> instead.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.AutoSize">AutoSize topic</link>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.AutoSizeDelayed">
        <short>Auto-sizing has been delayed until some other process is complete</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.AutoSizeDelayed.Result">
        <short>Returns True if auto-sizing has been delayed</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorToNeighbour">
        <short>
          <var>AnchorToNeighbour</var>
 - anchoring instructions</short>
        <descr>
          <pre>{------------------------------------------------------------------------------
  procedure TControl.AnchorToNeighbour(Side: TAnchorKind; Space: integer;
    Sibling: TControl);

  Setup AnchorSide to anchor one side to the side of a neighbour sibling.
  For example Right side to Left side, or Top side to Bottom.
 ------------------------------------------------------------------------------}</pre>
        </descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorToNeighbour.Side">
        <short>The side on which we should anchor</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorToNeighbour.Space">
        <short>The size of the space to be left around the control when anchoring</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorToNeighbour.Sibling">
        <short>The sibling control to which we should anchor</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorParallel">
        <short>
          <var>AnchorParallel </var>
- instructions for anchoring beside another control</short>
        <descr>
          <p>
            <var>AnchorParallel </var>
- instructions for anchoring beside another control</p>
          <p>Sibling - another control beside which the current control is to be anchored</p>
        </descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorParallel.Side">
        <short>The side on which we should anchor to the sibling</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorParallel.Space">
        <short>The size of the space to be left around the control when anchoring</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorParallel.Sibling">
        <short>The sibling control to which we should anchor in a parallel manner</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorHorizontalCenterTo">
        <short>
          <var>AnchorHorizontal </var>
- instructions for anchoring</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorHorizontalCenterTo.Sibling">
        <short>Another control to which the current control is to be anchored, centred horizontally</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorVerticalCenterTo">
        <short>
          <var>AnchorVertical </var>
- instructions for anchoring</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorVerticalCenterTo.Sibling">
        <short>Another control to which the current control is to be anchored, centred vertically</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetBounds">
        <short>
          <var>SetBounds</var> - set the bounds (top. left, height, width) for the window</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBounds.aLeft">
        <short>The X co-ordinate of the top left pixel of the control</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBounds.aTop">
        <short>The Y co-ordinate of the top left pixel of the control</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBounds.aWidth">
        <short>The width of the control</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBounds.aHeight">
        <short>The height of the control</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetInitialBounds">
        <short>Sets the bounds of the control initially, when it is created</short>
        <descr>Checks that this is a new control, then calls SetBounds to set up coordinates defining its position
</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.SetBounds">SetBounds</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetInitialBounds.aLeft">
        <short>X co-ordinate of top left pixel</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetInitialBounds.aTop">
        <short>Y co-ordinate of top left pixel</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetInitialBounds.aWidth">
        <short>Width of control</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetInitialBounds.aHeight">
        <short>Height of control</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetBoundsKeepBase">
        <short>Set the bounds, keeping the base values</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBoundsKeepBase.aLeft">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBoundsKeepBase.aTop">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBoundsKeepBase.aWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBoundsKeepBase.aHeight">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBoundsKeepBase.Lock">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.GetPreferredSize">
        <short>Returns default/preferred height and width, to be used in autosizing algorithms</short>
        <descr>
          <p>
            <var>GetPreferredSize</var>
  - find default/preferred height and width</p>
          <pre>procedure TControl.GetPreferredSize 
        (var PreferredWidth, PreferredHeight: integer; 
          WithThemeSpace: Boolean);</pre>
          <p>Returns the default/preferred width and height for a control, which are used
  by the LCL autosizing algorithms as default size. Only positive values are
  valid. Negative or 0 are treated as undefined and the LCL uses other sizes
  instead.</p>
          <p>WithThemeSpace: If true, adds space for stacking.</p>
          <p>For example: <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be
  some space around. This space is theme dependent, so the parameter is passes to the widgetset</p>
          <p>
            <var>TWinControl</var>
 overrides this and asks the interface for theme dependent values.
  See 
            
            <link id="#lcl.Controls.TWinControl.CalculatePreferredSize">TWinControl.CalculatePreferredSize</link> for more information.</p>
        </descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetPreferredSize.PreferredWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetPreferredSize.PreferredHeight">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetPreferredSize.Raw">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.InvalidatePreferredSize">
        <short>Render the preferred size no longer valid (implies that we will look for another)</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControl.Create">
        <descr>
          <p>
            <var>Create</var>
 a new Control - Constructor. Overrides constructors of ancestor classes and sets a number of defaults. Often overridden by descendant classes.</p>
          <p>Defaults set by the Constructor include ControlStyle, Constraints, BorderSpacing, Anchoring, alignment, CaptureMouseBottons, Color, Visibility, Hinting, Cursor, Font, The WindowProcedure to be used, the Help type, the FloatingDockSite and Enabled properties</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.Create">TComponent.Create</link>
          <link id="#LCL.LCLClasses.TLCLComponent.Create">TLCLComponent.Create</link>
        </seealso>
        <short>
          <var>Create</var> - constructor for 
          <var>TControl </var>and derived classes: calls inherited 
          <var>Create</var> and sets a number of defaults</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.Create.TheOwner">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TControl.Destroy">
        <descr>
          <p>
            <var>Destructor</var>
 for Control. Detaches control from parents, removes graphics, frees memory and Operating System handles, pointers etc.</p>
          <p>Overrides destructors of ancestor classes, and in turn may be overridden by descendant classes.</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.Destroy">TComponent.Destroy</link>
          <link id="#LCL.LCLClasses.TLCLComponent.Destroy">TLCLComponent.Destroy</link>
        </seealso>
        <short>
          <var>Destroy</var> - Destructor for 
          <var>TControl</var>. Detaches control from parents, removes graphics, frees memory and Operating System handles, pointers etc</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.EditingDone">
        <short>
          <var>EditingDone</var> - what to do when you have finished editing; calls the 
          <var>OnEditingDone</var> event handler if assigned</short>
        <descr>
          <p>
            <var>TControl.EditingDone</var>
          </p>
          <p>Called when user has finished editing. This procedure can be used by data links to commit the changes.</p>
          <p>For example:</p>
          <ul>
            <li>When focus switches to another control (default)</li>
            <li>When user selected another item</li>
          </ul>
          <p>It's totally up to the control, what events will commit.</p>
        </descr>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ExecuteDefaultAction">
        <short>What to do when the RETURN button is pressed, signifying default action</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ExecuteCancelAction">
        <short>What to do when ESCAPE is hit (or the CANCEL button is selected) - signifying CANCEL</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.BeginDrag">
        <short>
          <var>BeginDrag</var> - starts the dragging of a control</short>
        <descr>
          <pre>{------------------------------------------------------------------------------
  Method: TControl.BeginDrag
  Params: Immediate: Drag behaviour
          Threshold: distance to move before dragging starts
                     -1 uses the default value of Mouse.DragThreshold
  Returns: Nothing

  Starts the dragging of a control. If the Immediate flag is set, dragging
  starts immediately.
 ------------------------------------------------------------------------------}
</pre>
        </descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.BeginDrag.Immediate">
        <short>If True, start drag as soon as cursor starts to move</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.BeginDrag.Threshold">
        <short>Least value for movement of cursor before drag starts</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.BeginDrag">
        <short>
          <var>BeginDrag</var> - starts the dragging of a control. In this version BringToFront applies</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.BeginDrag.Immediate">
        <short>If True, start drag as soon as cursor starts to move</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.BringToFront">
        <short>Bring the control to the front of the viewed screen</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ColorIsStored">
        <short>Returns True if Colour is stored</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.ColorIsStored.Result">
        <short>Function returns True if colour has been stored</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.HasParent">
        <short>
          <var>HasParent</var> - returns True if there is a parent component responsible for streaming</short>
        <descr>
          <p>
            <var>HasParent</var> - returns True if there is a parent component responsible for streaming</p>
          <p>This function will be called during streaming to decide if a component has to be streamed by its owner or parent</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.HasParent">TComponent.HasParent</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.HasParent.Result">
        <short>Function returns True if there is a parent</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsParentOf">
        <short>This control is the parent of another (specified) control</short>
        <descr>
          <p>This control is the parent of another control.</p>
          <p>AControl: the control of which this is a parent.</p>
          <p>Result: true if this is a parent</p>
        </descr>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsParentOf.Result">
        <short>Function returns True if this control is a parent, ie there is a child control</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.IsParentOf.AControl">
        <short>The control of which this control is a parent (ie the Child control)</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsVisible">
        <short>Returns True if the control is visible on the current desktop</short>
        <descr>
          <p>The control is visible on the current desktop</p>
          <p>Checks parents too</p>
        </descr>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsVisible.Result">
        <short>Function returns True is control is visible</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Hide">
        <short>
          <var>Hide </var>this control</short>
        <seealso>
          <link id="#lcl.Controls.TControl.Visible"/>
          <link id="#lcl.Controls.TControl.Show"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Refresh">
        <short>
          <var>Refresh</var> the data on this control</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Repaint">
        <short>
          <var>Repaint</var> the control, ie refill its canvas</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Invalidate">
        <short>Render this control non-valid</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.CheckChildClassAllowed">
        <short>Function checks whether a particular child class is allowed</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.CheckChildClassAllowed.Result">
        <short>Function returns True if child class has been checked and is allowed</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CheckChildClassAllowed.ChildClass">
        <short>The child class which is being checked to see whether it is allowed</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CheckChildClassAllowed.ExceptionOnInvalid">
        <short>Boolean set to True if a non-valid class is found and an exception has been raised</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.CheckNewParent">
        <short>Checks a new parent for this control</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CheckNewParent.AParent">
        <short>The new parent associated with this control</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SendToBack">
        <short>Send to back, ie place this control behind all other controls in the current screen; it will not be visible unless the controls in front are transparent</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetTempCursor">
        <short>
          <var>SetTempCursor</var> - set a temporary cursor</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetTempCursor.Value">
        <short>The temporary cursor which has been set</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.UpdateRolesForForm">
        <short>Update the roles for this form; see whether there have been any changes in its role</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetTextBuf">
        <short>Gets text associated with the control from a buffer</short>
        <descr>
          <pre>* The VCL implementation relies on the virtual Get/SetTextBuf to 
 * exchange text between widgets and VCL. This means a lot of 
 * (unnecesary) text copies.
 * The LCL uses strings for exchanging text (more efficient).
 * To maintain VCL compatibility, the virtual RealGet/SetText is
 * introduced. These functions interface with the LCLInterface. The
 * default Get/SetTextbuf implementation calls the RealGet/SetText.
 * As long as the Get/SetTextBuf isn't overridden Get/SetText 
 * calls RealGet/SetText to avoid PChar copying.
 * To keep things optimal, LCL implementations should always 
 * override RealGet/SetText. Get/SetTextBuf is only kept for
 * compatibility.
</pre>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.RealGetText">RealGetText</link>
          <link id="#lcl.Controls.TControl.GetText">GetText</link>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetTextBuf.Result">
        <short>Pointer to the buffer containing the text</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetTextBuf.Buffer">
        <short>Pointer to the buffer containing the string</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetTextBuf.BufSize">
        <short>Length of the buffer</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetTextLen">
        <short>Get the length of the specified text</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetTextLen.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetTextBuf">
        <short>Stores text associated with the control in a buffer</short>
        <descr>
          <pre>* The VCL implementation relies on the virtual Get/SetTextBuf to 
 * exchange text between widgets and VCL. This means a lot of 
 * (unnecesary) text copies.
 * The LCL uses strings for exchanging text (more efficient).
 * To maintain VCL compatibility, the virtual RealGet/SetText is
 * introduced. These functions interface with the LCLInterface. The
 * default Get/SetTextbuf implementation calls the RealGet/SetText.
 * As long as the Get/SetTextBuf isn't overridden Get/SetText 
 * calls RealGet/SetText to avoid PChar copying.
 * To keep things optimal, LCL implementations should always 
 * override RealGet/SetText. Get/SetTextBuf is only kept for
 * compatibility.
</pre>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.RealSetText">RealSetText</link>
          <link id="#lcl.Controls.TControl.SetText">SetText</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetTextBuf.Buffer">
        <short>Pointer to the buffer where the text is to be stored</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.Perform">
        <short>
          <var>Perform</var> an Action specified by the message and parameters</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.Perform.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.Perform.Msg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.Perform.WParam">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.Perform.LParam">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ScreenToClient">
        <short>Adjust from Screen co-ordinates to Client-relative co-ordinates</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.ScreenToClient.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ScreenToClient.APoint">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ClientToScreen">
        <short>Convert from Client co-ordinates to Screen co-ordinates</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.ClientToScreen.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ClientToScreen.APoint">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ScreenToControl">
        <short>Adjust from Screen co-ordinates to Control-relative co-ordinates</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.ScreenToControl.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ScreenToControl.APoint">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ControlToScreen">
        <short>Convert from control-relative co-ordinates to absolute screen co-ordinates</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.ControlToScreen.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ControlToScreen.APoint">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Show">
        <short>Makes the control visible.</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#lcl.Controls.TControl.Visible"/>
          <link id="#lcl.Controls.TControl.Hide"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.Update">
        <short>Perform the <var>Update</var> method specified by the parent control (if there is one)</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetZOrderPosition">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetZOrderPosition.NewPosition">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.SetZOrder">
        <short>
          <var>SetZOrder</var> - specify this control's place in the Z-order (ie front-to-back) of controls</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetZOrder.TopMost">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.HandleObjectShouldBeVisible">
        <short>
          <var>HandleObjectShouldBeVisible</var> - returns True if the Handle Object is required to be visible</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.HandleObjectShouldBeVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ParentHandlesAllocated">
        <short>
          <var>ParentHandlesAllocated</var> - returns True if the parent handles have been allocated</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.ParentHandlesAllocated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.InitiateAction">
        <short>
          <var>InitiateAction</var> - method to start the action associated with this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.LCLClasses.TLCLComponent.RemoveAllHandlersOfObject" name="TControl.RemoveAllHandlersOfObject">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.RemoveAllHandlersOfObject.AnObject">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnResize">
        <short>
          <var>AddHandlerOnResize</var> - method for adding a handler for the 
          <var>OnResize</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AddHandlerOnResize.OnResizeEvent">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AddHandlerOnResize.AsLast">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnResize">
        <short>
          <var>RemoveHandlerOnResize</var> - method for removing a handler for the 
          <var>OnResize</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.RemoveHandlerOnResize.OnResizeEvent">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnChangeBounds">
        <short>
          <var>AddHandlerOnChangeBounds</var> - method for adding a handler for the 
          <var>OnChangeBounds</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AddHandlerOnChangeBounds.OnChangeBoundsEvent">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AddHandlerOnChangeBounds.AsLast">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnChangeBounds">
        <short>
          <var>RemoveHandlerOnChangeBounds</var> - method to remove a handler for the 
          <var>OnChangeBounds</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.RemoveHandlerOnChangeBounds.OnChangeBoundsEvent">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Action">
        <short>The action to be associated with this control</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>The (default) action to be associated with this control</p>
          <p>Can either read the action already associated with the control (GetAction), or write an action to be associated (SetAction)</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TBasicAction"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Align">
        <short>Used to align the control to the top, bottom, left or right of its client.</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Either reads a flag containing alignment instructions (<var>FAlign</var>) or writes alignment instructions (<var>SetAlign</var>)</p>
          <p>May have no alignment, may have custom or client alignment, or can be aligned to top, bottom, left or right</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TAlign">TAlign</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Anchors">
        <short>The set of anchor definitions for this control</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Determines how the control is to be anchored to its client or parent conrol</p>
          <p>Either reads a flag containing the set of anchors to be used, or writes a set of anchors. If they have been written, this is indicated in <var>IsAnchorsStored</var>
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TAnchors"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.AnchorSide">
        <short>Finds which side to use for anchor</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Finds which side is to be used to anchor this control, and what relationships it has to other controls nearby. </p>
          <p>For complex relationships, use the <var>Side</var> property of the parent class <link id="#lcl.Controls.TAnchorSide">TAnchorSide</link>, and make a reference eg using <var>asrCenter</var>
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TAnchorSide"/>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorSide.Kind">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BorderSpacing">
        <short>Determines the border spacing for this control</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Determines the border spacing for this control</p>
          <p>Reads flag to find stored spacing values required for the border of the control, or writes the flag to set the spacing.</p>
          <p>The properties are defined in the parent class <link id="#lcl.Controls.TControlBorderSpacing">TControlBorderSpacing</link>
          </p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BoundsRect">
        <short>Determines the rectangle bounding this control</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Finds the values for the bounding rectangle, or sets the values.</p>
          <p>Bounding rectangle (top-left, bottom-right) is defined in <link id="#rtl.Classes.TRect">TRect</link>
          </p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BoundsRectForNewParent">
        <short>
          <var>BoundsRectForNewParent</var> - finds (or sometimes specifies) the bounding rectangle for a new parent control</short>
        <descr>// standard properties, which should be supported by all descendants
</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Caption">
        <short>
          <var>Caption</var>
 - the text-string appearing on the Control, usually used to identify its function</short>
        <descr>
          <p>Gets caption as a text-string (<var>GetText</var>), or stores the new caption (<var>SetText</var>). Shows flag if caption is stored (<var>IsCaptionStored</var>).</p>
          <p>By default, the <var>Caption</var> appears the same as the control <var>Name</var> in the Object Inspector, 
and the developer needs to set it explicitly to some new text.</p>
          <p>The VCL implementation relies on the virtual <var>Get/SetTextBuf</var> to exchange text between widgets and VCL. This means a lot of (unnecesary) text copies. </p>
          <p>The LCL uses strings for exchanging text (more efficient). To maintain VCL compatibility, the virtual <var>RealGet/SetText</var> is
introduced. These functions interface with the LCLInterface. </p>
          <p>The default <var>Get/SetTextBuf</var> implementation calls the <var>RealGet/SetText</var>. As long as the <var>Get/SetTextBuf</var> isn't overridden <var>Get/SetText</var> calls <var>RealGet/SetText</var> to avoid PChar copying.</p>
          <p>To keep things optimal, LCL implementations should always override RealGet/SetText. Get/SetTextBuf is only kept for compatibility.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.RealGetText"/>
          <link id="#lcl.Controls.TControl.RealSetText"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientHeight">
        <short>
          <var>ClientHeight</var>
 - determines the height of the client within which the control exists</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Finds or sets the client height, and sets a flag if it has been stored</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientOrigin">
        <short>
          <var>ClientOrigin </var>
- Top left pixel of the client within which the control exists</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Finds origin of client (read-only)</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientRect">
        <short>
          <var>ClientRect </var>
- finds the position of the rectangle for the client within which the control exists</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>
            <var>ClientRect </var>
- finds the coordinates of the rectangle for the client within which the control exists (read-only)</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TRect"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ClientWidth">
        <short>
          <var>ClientWidth</var>
 - determines the width of the client within which the control exists</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>
            <var>ClientWidth</var>
 - determines the width of the client within which the control exists; reads the width of the client control or sets the value. Sets flag if value is stored</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Color">
        <short>Determine the colour for the current control</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Reads the value for colour, or stores the value, and sets a flag if the colour is stored.</p>
          <p>The default colour is the same as the window in which the control is located.</p>
        </descr>
        <seealso>
          <link id="#lcl.Graphics.TColor"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Constraints">
        <short>Determine <var>Constraints</var> (max and min height and width) for this control</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Determine <var>Constraints</var> (max and min height and width) for this control; reads the size constraints or stores new ones.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TSizeConstraints"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ControlOrigin">
        <short>
          <var>ControlOrigin</var>
 - top left pixel of this control</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Reads value for the Origin (top left pixel) of this control. (read-only)</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TPoint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ControlState">
        <short>
          <var>ControlState</var>
 - whether mouse has been clicked, data being read, control being re-drawn, etc</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>
            <var>ControlState</var>
 - whether mouse has been clicked, data being read, control being re-drawn, etc. Reads or stores the state of the control.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControlState"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ControlStyle">
        <short>
          <var>ControlStyle</var>
 - whether the control responds to mouse clicks, can be re-sized, has particular actions, etc</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>
            <var>ControlStyle</var>
 - whether the control responds to mouse clicks, can be re-sized, has particular actions, etc. Reads the stored style, or saves the new style</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControlStyle"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Enabled">
        <short>Whether the control is <var>Enabled</var>. If not, it usually appears 'greyed-out'</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Whether the control is <var>Enabled</var>. If not, it usually appears 'greyed-out'</p>
          <p>Reads a flag to see whether the control is enabled, or stores a new value. If stored, sets a flag to say so.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Font">
        <short>The <var>Font</var> to be used for text in this control</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Reads a flag to see what font should be used, or sets a flag to store it. If stored, sets a flag to say so</p>
          <p>The properties of <var>Font</var> are defined in the parent class <link id="#lcl.Graphics.TFont">TFont</link>
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Graphics.TFont"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.IsControl">
        <short>Reads or writes a flag to deterine whether this object is actually a control</short>
        <descr>// standard properties, which should be supported by all descendants<br/>
Reads a logical (boolean) flag or sets it to determine whether this object is a control.</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.MouseEntered">
        <short>Reads a flag to determine whether the mouse entered the control</short>
        <descr>// standard properties, which should be supported by all descendants<br/>Reads logical (boolean) flag to see whether mouse has entered the control</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnChangeBounds">
        <short>Event handler for a change in bounds of the control</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>Reads or Writes flag if bounds are changed</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TNotifyEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnClick">
        <short>Event Handler for mouse click</short>
        <descr>
          <p>// standard properties, which should be supported by all descendants</p>
          <p>This is often the default action for many controls, and is often the ONLY action specified by the programmer. The action can be spcified by the user, either by typing explicit code into the implementation section for this control, or by selecting an action from a pre-supplied <var>ActionList</var>
          </p>
          <p>Reads or writes a flag if  a mouse click is detected, and sets a flag if a value is stored.</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TNotifyEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnResize">
        <short>Event Handler for resize of control</short>
        <descr>This event is triggered whenever the Width, Height, ClientWidth or ClientHeight of the control has changed.
During autosize the size can change multiple times and only the last change triggers the OnResize.
Use OnResize to react to resizes or to put your custom aligning, positioning code into this.
To react to moves use the OnChangeBounds event.

Common mistake:
Keep in mind that ClientWidth and ClientHeight can change even when Width, Height stays the same. For example when the theme or the font changes the Width, Height of a TForm, TGroupBox, TPageControl stays, but the frame changes and thus the ClientWidth, ClientHeight too. This does not happen that often under windows, but it happens quite often on other platforms.
Especially it is not sufficient to write only a TForm.OnResize handler to resize all controls on the form. This is a common bug in Delphi applications.
</descr>
        <seealso>
          <link id="#rtl.Classes.TNotifyEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.OnShowHint">
        <short>Event Handler when a hint needs to be shown</short>
        <descr>// standard properties, which should be supported by all descendants<br/>Reads or Writes a flag when a hint (a small pop-up box, appearing when the mouse hovers over an object) is to be shown</descr>
        <seealso>
          <link id="#lcl.Controls.THintInfo"/>
          <link id="#lcl.Controls.TControlShowHintEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Parent">
        <short>Determine what is the parent for this control</short>
        <descr>// standard properties, which should be supported by all descendants<br/>
Reads or writes a flag to find or store the identity of the parent for this control. The parent is of type TWincontrol</descr>
        <seealso>
          <link id="#lcl.Controls.TWinControl"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.PopupMenu">
        <short>
          <var>PopupMenu</var> - a context-sensitive menu that pops up when the right mouse button is clicked over this control</short>
        <descr>// standard properties, which should be supported by all descendants<br/>
 Reads the details of the pop-up menu, or stores them.<br/>
Properties are defined in the parent class <link id="#lcl.Menus.TPopupMenu">TPopupMenu</link>
        </descr>
        <seealso>
          <link id="#lcl.Menus.TPopupMenu"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ShowHint">
        <short>Flag to determine: Is hint to be displayed for this control?</short>
        <descr>// standard properties, which should be supported by all descendants<br/>Reads flag or writes one to determine if a hint is to be shown when mouse hovers over this control. If value is stored, a storage flag is set. Display of the actual hint is controlled by OnShowHint</descr>
        <seealso>
          <link id="#lcl.Controls.TControl.OnShowHint">OnShowHint</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Visible">
        <short>
          <var>Visible</var>
 - can the control be seen?</short>
        <descr>
          <pre>The Visible property represents the ability to see a visual control. 
          If Visible is True the control is shown, otherwise it is hidden.
          Calling Show sets, among others, Visible to True.
          Setting Visible to False is equivalent to calling Hide method.</pre>
          <remark>The Visible property does not depend on control's parent visibility. Use IsVisible method to consider this and get real visibility.</remark>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl.IsVisible"/>
          <link id="#lcl.Controls.TControl.Show"/>
          <link id="#lcl.Controls.TControl.Hide"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.WindowProc">
        <short>Reads or writes a message associated with this window</short>
        <descr>// standard properties, which should be supported by all descendants<br/>
Reads message from flag area, or stores a message
</descr>
        <seealso>
          <link id="#lcl.Controls.TWndMethod">TWndMethod</link>
          <link id="#lcl.LMessages.TLMessage">TLMessage</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.DockOrientation">
        <short>
          <var>DockOrientation</var> - whether docking is oriented horizontally, vertically, according to pages or not at all</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.Floating">
        <short>Whether the control is <var>Floating</var> (as opposed to Docked)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.FloatingDockSiteClass">
        <short>
          <var>FloatingDockSiteClass</var> - reads or writes the class of the floating dock site</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.HostDockSite">
        <short>
          <var>HostDockSite</var> - the host site to which this control is docked</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.LRDockWidth">
        <short>
          <var>LRDockWidth</var> - the docked width from left to right</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.TBDockHeight">
        <short>
          <var>TBDockHeight </var>- the docked height from top to bottom</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.UndockHeight">
        <short>
          <var>UndockHeight</var> - the height of the undocked control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.UndockWidth">
        <short>
          <var>UnDockWidth</var> - the undocked width of the control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.AnchorSideLeft">
        <short>Anchor to the left side</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.AnchorSideTop">
        <short>Anchor to the Top</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.AnchorSideRight">
        <short>Anchor to the right side</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.AnchorSideBottom">
        <short>Anchors to the bottom</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Cursor">
        <short>The type of cursor to be used with this control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Left">
        <short>
          <var>Left</var>
 - the coordinate of the left edge of the control</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Height">
        <short>
          <var>Height</var>
 - the vertical dimension of the control</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Hint">
        <short>
          <var>Hint</var>
 - a small informative pop-up box that appears when the mouse 'hovers' over a control</short>
        <descr>
          <p>
            <var>Hint</var>
 - a small informative pop-up box that appears when the mouse 'hovers' over a control</p>
          <p>Requires <var>ShowHint</var> to be True</p>
        </descr>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Top">
        <short>
          <var>Top</var>
 - the coordinates of the top edge of the control</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.Width">
        <short>
          <var>Width </var>
- the horizontal dimension of the control</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.HelpType">
        <short>The type of help to be used with this control - keyword or context</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.HelpKeyword">
        <short>The keyword to be used for Help in this control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControl.HelpContext">
        <short>The context-sensitive help message to be used with this control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TBorderWidth">
        <short>Integer type defining width of the border of a control</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetChildProc">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGetChildProc.Child">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TChildControlEnlargeStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlEnlargeStyle.cesAnchorAligning">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlEnlargeStyle.cesScaleChilds">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlEnlargeStyle.cesHomogenousChildGrowth">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlEnlargeStyle.cesHomogenousSpaceGrowth">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TChildControlShrinkStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlShrinkStyle.cssAnchorAligning">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlShrinkStyle.cssScaleChilds">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlShrinkStyle.cssHomogenousChildDecrease">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlChildSizing">
        <short>How Child controls are to be sized relative to parent</short>
        <descr>
          <code>{ TControlChildSizing }


  { LeftRightSpacing, TopBottomSpacing: integer;
        minimum space between left client border and left most children.
        For example: ClientLeftRight=5 means child's Left position is at least 5.

    HorizontalSpacing, VerticalSpacing: integer;
        minimum space between each child horizontally
  }

  {   Defines how child controls are resized/aligned.

      cesAnchorAligning, cssAnchorAligning
        Anchors and Align work like Delphi. For example if Anchors property of
        the control is [akLeft], it means fixed distance between left border of
        parent's client area. [akRight] means fixed distance between right
        border of the control and the right border of the parent's client area.
        When the parent is resized the child is moved to keep the distance.
        [akLeft,akRight] means fixed distance to left border and fixed distance
        to right border. When the parent is resized, the controls width is
        changed (resized) to keep the left and right distance.
        Same for akTop,akBottom.

        Align=alLeft for a control means set Left leftmost, Top topmost and
        maximize Height. The width is kept, if akRight is not set. If akRight
        is set in the Anchors property, then the right distance is kept and
        the control's width is resized.
        If there several controls with Align=alLeft, they will not overlapp and
        be put side by side.
        Same for alRight, alTop, alBottom. (Always expand 3 sides).

        Align=alClient. The control will fill the whole remaining space.
        Setting two children to Align=alClient does only make sense, if you set
        maximum Constraints.

        Order: First all alTop children are resized, then alBottom, then alLeft,
        then alRight and finally alClient.

      cesScaleChilds, cssScaleChilds
        Scale children, keep space between them fixed.
        Children are resized to their normal/advised size. If there is some space
        left in the client area of the parent, then the children are scaled to
        fill the space. You can set maximum Constraints. Then the other children
        are scaled more.
        For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and
        C.Width=30 (total=60). If the Parent's client area has a ClientWidth of
        120, then the children are scaled with Factor 2.
        If B has a maximum constraint width of 30, then first the children will be
        scaled with 1.5 (A.Width=15, B.Width=30, C.Width=45). Then A and C
        (15+45=60 and 30 pixel space left) will be scaled by 1.5 again, to a
        final result of: A.Width=23, B.Width=30, C.Width=67 (23+30+67=120).

      cesHomogenousChildGrowth, cssHomogenousChildDecrease
        Enlarge children equally.
        Children are resized to their normal/advised size. If there is some space
        left in the client area of the parent, then the remaining space is
        distributed equally to each child.
        For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and
        C.Width=30 (total=60). If the Parent's client area has a ClientWidth of
        120, then 60/3=20 is added to each Child.
        If B has a maximum constraint width of 30, then first 10 is added to
        all childs (A.Width=20, B.Width=30, C.Width=40). Then A and C
        (20+40=60 and 30 pixel space left) will get 30/2=15 additional,
        resulting in: A.Width=35, B.Width=30, C.Width=55 (35+30+55=120).

      cesHomogenousSpaceGrowth
        Enlarge space between children equally.
        Children are resized to their normal/advised size. If there is some space
        left in the client area of the parent, then the space between the children
        is expanded.
        For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and
        C.Width=30 (total=60). If the Parent's client area has a ClientWidth of
        120, then there will be 60/2=30 space between A and B and between
        B and C.
  }

</code>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FEnlargeHorizontal">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FEnlargeVertical">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FHorizontalSpacing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FLeftRightSpacing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FOnChange">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FShrinkHorizontal">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FShrinkVertical">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FTopBottomSpacing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FVerticalSpacing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetEnlargeHorizontal">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.SetEnlargeHorizontal.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetEnlargeVertical">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.SetEnlargeVertical.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetHorizontalSpacing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.SetHorizontalSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetLeftRightSpacing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.SetLeftRightSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetShrinkHorizontal">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.SetShrinkHorizontal.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetShrinkVertical">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.SetShrinkVertical.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetTopBottomSpacing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.SetTopBottomSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetVerticalSpacing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.SetVerticalSpacing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlChildSizing.Change">
        <short>
          <var>Change</var> - software emulation of the 
          <var>OnChange</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControlChildSizing.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TControlChildSizing</var>: performs inherited 
          <var>Create</var> then sets some default alignments and sizes</short>
        <descr>
          <p>
            <var>Create</var> - constructor for 
            <var>TControlChildSizing</var>: performs inherited 
            <var>Create</var> then sets some default alignments and sizes</p>
          <p>Overrides ancestors, may be overridden</p>
        </descr>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.Create.OwnerControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlChildSizing.Assign">
        <short>
          <var>Assign</var> - if source is the same type as current control, copies a large number of explicit properties from source, else calls inherited 
          <var>Assign</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.Assign.Source">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlChildSizing.AssignTo">
        <short>
          <var>AssignTo</var> - calls the 
          <var>Assign</var> method for the destination control</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.AssignTo">TPersistent.AssignTo</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.AssignTo.Dest">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlChildSizing.IsEqual">
        <short>
          <var>IsEqual</var> - returns True if the specified sizing is the same as the current value</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlChildSizing.IsEqual.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.IsEqual.Sizing">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.Control">
        <short>The <var>Control</var> to which childsizing is to be applied</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.OnChange">
        <short>
          <var>OnChange</var> - event handler for a chaange in sizing</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.EnlargeHorizontal">
        <short>
          <var>EnlargeHorizontal</var> - make larger in the horizontal plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.EnlargeVertical">
        <short>
          <var>EnlargeVertical</var> - make larger in the vertical plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.ShrinkHorizontal">
        <short>
          <var>ShrinkHorizontal</var> - make smaller in the horizontal plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlChildSizing.ShrinkVertical">
        <short>
          <var>ShrinkVertical</var> - make smaller in the vertical plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.LeftRightSpacing">
        <short>
          <var>LeftRightSpacing</var> - spacing from left to right</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.TopBottomSpacing">
        <short>
          <var>TopBottomSpacing</var> - spacing from top to bottom</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.HorizontalSpacing">
        <short>
          <var>HorizontalSpacing</var> - spacing in the horizontal plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.VerticalSpacing">
        <short>
          <var>VerticalSpacing</var> - spacing in the vertical plane</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TWinControlActionLink">
        <short>
          <var>TWinControlActionLink</var> - same as 
          <var>TControlActionLink</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControlActionLink.AssignClient">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControlActionLink.AssignClient.AClient">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControlActionLink.IsHelpContextLinked">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControlActionLink.IsHelpContextLinked.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControlActionLink.SetHelpContext">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControlActionLink.SetHelpContext.Value">
        <short/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TWinControlActionLinkClass">
        <short>
          <var>TWinControlActionLinkClass</var> - class of 
          <var>TWinControlActionLink</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TWinControlFlag">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWinControlFlag.wcfClientRectNeedsUpdate">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWinControlFlag.wcfColorChanged">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWinControlFlag.wcfFontChanged">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWinControlFlag.wcfReAlignNeeded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWinControlFlag.wcfAligningControls">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWinControlFlag.wcfEraseBackground">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWinControlFlag.wcfAutoSizeNeeded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWinControlFlag.wcfCreatingHandle">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWinControlFlag.wcfInitializing">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWinControlFlag.wcfCreatingChildHandles">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TWinControlFlags">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TWinControl">
        <short>
          <var>TWinControl</var> - the base class for all windowed controls</short>
        <descr>
          <p>Defines many of the properties inherited by child classes, particularly those related to size, position, bounds, docking, the responses to mouse movements and key presses. </p>
          <p>Defines procedures and functions related to windowed controls, some of which override virtual methods defined in ancestor classes.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TControl">TControl</link>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FAlignLevel">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FBorderWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FBoundsLockCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FBoundsRealized">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FBorderStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FBrush">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FAdjustClientRectRealized">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FChildSizing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FControls">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FDefWndProc">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FDockClients">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FDoubleBuffered">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FClientWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FClientHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FDockManager">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FDockSite">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FWinControlFlags">
        <short>
          <var>FWinControlFlags</var> - local variable to hold status flags</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnDockDrop">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnDockOver">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnGetSiteInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnKeyDown">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnKeyPress">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnKeyUp">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnMouseWheel">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnMouseWheelDown">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnMouseWheelUp">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnEnter">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnExit">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnUnDock">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnUTF8KeyPress">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FParentWindow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FParentCtl3D">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FRealizeBoundsLockCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FHandle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FShowing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FTabOrder">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FTabStop">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FTabList">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FUseDockManager">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FWinControls">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.AlignControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.AlignControl.AControl">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetBrush">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetBrush.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetControl.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetControl.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetControlCount">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetControlCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetDockClientCount">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetDockClientCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetDockClients">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetDockClients.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetDockClients.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetHandle.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetIsResizing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetIsResizing.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetTabOrder">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetTabOrder.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.GetVisibleDockClientCount">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetVisibleDockClientCount.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetChildSizing">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetChildSizing.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetDockSite">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetDockSite.NewDockSite">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetHandle">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetHandle.NewHandle">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetBorderWidth">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetBorderWidth.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetParentCtl3D">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetParentCtl3D.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetTabOrder">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetTabOrder.NewTabOrder">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetTabStop">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetTabStop.NewTabStop">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.SetUseDockManager">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetUseDockManager.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.UpdateTabOrder">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.UpdateTabOrder.NewTabOrder">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TWinControl.WantsKeyBeforeInterface">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.WantsKeyBeforeInterface.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WantsKeyBeforeInterface.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WantsKeyBeforeInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.AssignTo">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.AssignTo.Dest">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ActionChange">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ActionChange.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ActionChange.CheckDefaults">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.GetActionLinkClass">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetActionLinkClass.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.AdjustClientRect">
        <short>
          <var>AdjustClientRect</var> - method for adjusting the size and position of the client control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.AdjustClientRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.AlignControls">
        <short>
          <var>AlignControls</var> - align the specified control with a given client rectangle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.AlignControls.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.AlignControls.RemainingClientRect">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoAlignChildControls">
        <short>
          <var>DoAlignChildControls</var> - method for aligning child controls from a list; returns True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoAlignChildControls.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoAlignChildControls.TheAlign">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoAlignChildControls.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoAlignChildControls.AControlList">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoAlignChildControls.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoChildSizingChange">
        <short>
          <var>DoChildSizingChange</var> - method for changing size of a child component</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoChildSizingChange.Sender">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.CanTab" name="TWinControl.CanTab">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.CanTab.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoDragMsg">
        <short>
          <var>DoDragMsg</var> - issues a Drag message for a nominated drag object at a specified position, to a specific target with 
          <var>ADocking</var> set True or False; returns an integer result</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDragMsg.DragMsg">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMDrag">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CMDrag.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMShowingChanged">
        <short>
          <var>CMShowingChanged</var> - control message when Showing property is changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CMShowingChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMVisibleChanged">
        <short>
          <var>CMVisibleChanged</var> - control message when Visible property is changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CMVisibleChanged.TheMessage">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.ContainsControl">
        <short>This component contains a specified control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.ContainsControl.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ContainsControl.Control">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ControlsAligned">
        <short>
          <var>ControlsAligned</var> - called by AlignControls after aligning controls</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoSendBoundsToInterface">
        <short>
          <var>DoSendBoundsToInterface</var> - sends information about the control's bounds to the interface</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.RealizeBounds">
        <short>
          <var>RealizeBounds</var> - checks for changes and calls DoSendBoundsToInterface</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateSubClass">
        <short>
          <var>CreateSubClass</var> - creates a sub-class using the supplied parameters</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CreateSubClass.Params">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CreateSubClass.ControlClassName">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DestroyComponent">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.DoConstraintsChange" name="TWinControl.DoConstraintsChange">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoConstraintsChange.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoSetBounds">
        <short>
          <var>DoSetBounds</var> - anticipate the new clientwidth/height and call inherited method</short>
        <descr>
          <p>TWinControl DoSetBounds</p>
          <p>Params: ALeft, ATop, AWidth, AHeight : integer</p>
          <p>Anticipate the new clientwidth/height and call inherited method</p>
          <p>Normally the clientwidth/clientheight is adjusted automatically by the interface. But it is up to interface when this will be done. The gtk for example just puts resize requests into a queue. The LCL would resize the child components just after this procedure due to the clientrect. On complex forms with lots of nested controls, this would result in thousands of resizes.</p>
          <p>Changing the clientrect in the LCL to the most probable size reduces
  unneccessary resizes.</p>
        </descr>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.DoSetBounds">Control.DoSetBounds</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoSetBounds.ALeft">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoSetBounds.ATop">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoSetBounds.AWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoSetBounds.AHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoAutoSize">
        <short>
          <var>DoAutoSize</var> - performs a lot of calculations and adjustments of child components in the window before automatically adjusting the size of the window itself</short>
        <descr>
          <p>
            <printshort id="TWinControl.DoAutoSize"/>
          </p>
          <ul>
            <li>Checks whether Autosize is in fact permitted</li>
            <li>Checks for unaligned child components and fits them in as best it can</li>
            <li>Moves the constrained (aligned) child components to the correct position</li>
            <li>Adjusts the size of the client rectangle</li>
            <li>Adjusts the bounds of the whole control</li>
          </ul>
          <p>Because this method involves so much overhead, the simpler <link id="#lcl.Controls.TControl.AdjustSize">TControl.AdjustSize</link> is often called instead.</p>
        </descr>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.DoAutoSize">TControl.DoAutoSize</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CalculatePreferredSize">
        <short>
          <var>CalculatePreferredSize</var> - calculates the default/preferred width and height for a TWinControl, which is used by the LCL autosizing algorithms as default size</short>
        <descr>
          <p>procedure <var>TWinControl.CalculatePreferredSize</var>(var <var>PreferredWidth</var>,
    <var>PreferredHeight</var>: integer; <var>WithThemeSpace</var>: Boolean);</p>
          <p>Calls the inherited method to calculate the default/preferred width and height for a <var>TWinControl</var>, which is used by the LCL autosizing algorithms as default size. Only positive values are valid. Negative or 0 are treated as undefined and the LCL uses other sizes instead.</p>
          <p>
            <var>TWinControl</var> overrides this:</p>
          <ul>
            <li>If there are child components, their total preferred size is calculated</li>
            <li>If this value can not be computed (e.g. the children depend too much on their
  parent clientrect), then the interface is asked for the preferred size</li>
          </ul>
          <p>For example the preferred size of a <var>TButton</var> is the size, where the label fits
  exactly. This depends heavily on the current theme and widgetset.</p>
          <p>This value is independent of constraints and siblings, only the inner parts
  are relevant.</p>
          <p>
            <var>WithThemeSpace</var>: If true, adds space for stacking. For example: <var>TRadioButton</var>
  has a minimum size. But for stacking multiple TRadioButtons there should be
  some space around. This space is theme dependent, so it is passed as a parameter to
  the widgetset. </p>
        </descr>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.CalculatePreferredSize">TControl.CalculatePreferredSize</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CalculatePreferredSize.PreferredWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CalculatePreferredSize.PreferredHeight">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.GetChildBounds">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetChildBounds.ChildBounds">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetChildBounds.WithBorderSpace">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.GetChildren">
        <short>
          <var>GetChildren</var> - makes a list of all the child components for this control</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TComponent.GetChildren">TComponent.GetChildren</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetChildren.Proc">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetChildren.Root">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.ChildClassAllowed">
        <short>
          <var>ChildClassAllowed</var> - returns True if the given child class is permitted</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.ChildClassAllowed.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ChildClassAllowed.ChildClass">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.PaintControls">
        <short>
          <var>PaintControls</var> - method for painting a series of controls</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.PaintControls.DC">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.PaintControls.First">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.PaintHandler">
        <short>
          <var>PaintHandler</var> - message handler for painting</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.PaintHandler.TheMessage">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.PaintWindow">
        <short>
          <var>PaintWindow</var> - method for painting a window</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.PaintWindow.DC">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateBrush">
        <short>
          <var>CreateBrush</var> - method to create a brush for painting</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMEnabledChanged">
        <short>
          <var>CMEnabledChanged</var> - control message for a change in the 
          <var>Enabled</var> property</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CMEnabledChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMShowHintChanged">
        <short>
          <var>CMShowHintChanged</var> - control message for a change in the 
          <var>ShowHint</var> property</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CMShowHintChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMEraseBkgnd">
        <short>
          <var>WMEraseBkgnd</var> - LCL message for erasing background</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMEraseBkgnd.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMNotify">
        <short>
          <var>WMNotify</var> - LCL Notify message</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMNotify.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSetFocus">
        <short>
          <var>WMSetFocus</var> - LCL Message to set focus</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMSetFocus.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMKillFocus">
        <short>
          <var>WMKillFocus</var> - LCL Message to kill focus</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMKillFocus.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMShowWindow">
        <short>
          <var>WMShowWindow</var> - LCL Message to show window</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMShowWindow.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMEnter">
        <short>
          <var>WMEnter</var> - LCL Message for entry to the control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMEnter.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMExit">
        <short>
          <var>WMExit</var> - LCL Message for exit from control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMExit.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMMouseWheel">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMMouseWheel.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMKeyDown">
        <short>
          <var>WMKeyDown</var> - LCL Message for a key down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSysKeyDown">
        <short>
          <var>WMSysKeyDown</var> - LCL Message for a system key down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMSysKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMKeyUp">
        <short>
          <var>WMKeyUp</var> - LCL Message for a key up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSysKeyUp">
        <short>
          <var>WMSysKeyUp</var> - LCL Message for a system key up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMSysKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMChar">
        <short>
          <var>WMChar</var> - LCL Message signifying a character</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSysChar">
        <short>
          <var>WMSysChar</var> - LCL Message signifying a system character</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMSysChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMPaint">
        <short>
          <var>WMPaint</var> - LCL Message for Paint</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMPaint.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMDestroy">
        <short>
          <var>WMDestroy</var> - LCL Message for control destruction</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMDestroy.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMMove">
        <short>
          <var>WMMove</var> - LCL Message for movement</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMMove.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WMSize">
        <short>
          <var>WMSize</var> - LCL Message for sizing control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WMSize.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNKeyDown">
        <short>
          <var>CNKeyDown</var> - control message for key down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CNKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNSysKeyDown">
        <short>
          <var>CNSysKeyDown</var> - control message for system key down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CNSysKeyDown.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNKeyUp">
        <short>
          <var>CNKeyUp</var> - control message for key up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CNKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNSysKeyUp">
        <short>
          <var>CNSysKeyUp</var> - control message for system key up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CNSysKeyUp.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNChar">
        <short>
          <var>CNChar</var> - control message specifying a character</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CNChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CNSysChar">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CNSysChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoAddDockClient">
        <short>
          <var>DoAddDockClient</var> - add the specified control as a client for docking in the specified location (Arect)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoAddDockClient.Client">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoAddDockClient.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DockOver">
        <short>
          <var>DockOver</var> - software emulation of the OnDockOver event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DockOver.Source">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DockOver.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DockOver.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DockOver.State">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DockOver.Accept">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoDockOver">
        <short>
          <var>DoDockOver</var> - perform the DockOver method</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDockOver.Source">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDockOver.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDockOver.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDockOver.State">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDockOver.Accept">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoRemoveDockClient">
        <short>
          <var>DoRemoveDockClient</var> - method for removing a docking client </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoRemoveDockClient.Client">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoUnDock">
        <short>
          <var>DoUnDock</var> - software emulation of the 
          <var>OnUnDock</var> evnet</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoUnDock.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoUnDock.NewTarget">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoUnDock.Client">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.GetSiteInfo">
        <short>
          <var>GetSiteInfo</var> - software emulation of the 
          <var>OnGetSiteInfo </var>event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetSiteInfo.Client">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetSiteInfo.InfluenceRect">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetSiteInfo.MousePos">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetSiteInfo.CanDock">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ReloadDockedControl">
        <short>
          <var>ReloadDockedControl</var> - load the docked control again (it may have become misaligned during other processes)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ReloadDockedControl.AControlName">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ReloadDockedControl.AControl">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.CreateDockManager">
        <short>
          <var>CreateDockManager</var> - returns a new Dock Manager</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.CreateDockManager.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoEnter">
        <short>
          <var>DoEnter</var> - perform the action for the 
          <var>OnEnter</var> event handleer</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoExit">
        <short>
          <var>DoExit</var> - perform the action for the 
          <var>OnExit</var> event handler</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoMouseWheel">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoMouseWheel.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoMouseWheel.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoMouseWheel.WheelDelta">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoMouseWheel.MousePos">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoMouseWheelDown">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoMouseWheelDown.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoMouseWheelDown.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoMouseWheelDown.MousePos">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoMouseWheelUp">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoMouseWheelUp.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoMouseWheelUp.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoMouseWheelUp.MousePos">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoKeyDownBeforeInterface">
        <short>
          <var>DoKeyDownBeforeInterface</var> - issues a message to the interface and returns True if a key was already down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoKeyDownBeforeInterface.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoKeyDownBeforeInterface.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoRemainingKeyDown">
        <short>
          <var>DoRemainingKeyDown</var> - issues a LCL message and returns True if a key remains down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoRemainingKeyDown.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoRemainingKeyDown.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoRemainingKeyPress">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoRemainingKeyPress.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoRemainingKeyPress.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoRemainingKeyUp">
        <short>
          <var>DoRemainingKeyUp</var> - issues a LCL message and returns True if a key remains up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoRemainingKeyUp.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoRemainingKeyUp.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoKeyPress">
        <short>
          <var>DoKeyPress</var> - issues a LCL message and returns True if a key is pressed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoKeyPress.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoKeyPress.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoUTF8KeyPress">
        <short>
          <var>DoUTF8KeyPress</var> - issues a LCL message and returns True if there has been a UTF8 key press</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoUTF8KeyPress.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoUTF8KeyPress.UTF8Key">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoKeyUpBeforeInterface">
        <short>
          <var>DoKeyUpBeforeInterface</var> - issues an interface message and returns True if a key was already up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoKeyUpBeforeInterface.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoKeyUpBeforeInterface.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.ChildKey">
        <short>
          <var>ChildKey</var> - LCL message: returns True if this is a child key</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.ChildKey.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ChildKey.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.DialogChar" name="TWinControl.DialogChar">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DialogChar.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DialogChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ControlKeyDown">
        <short>
          <var>ControlKeyDown</var> - contains the set of special keys (shift, control, alt, meta) that are pressed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlKeyDown.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlKeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ControlKeyUp">
        <short>
          <var>ControlKeyUp</var> - contains the set of special keys (shift, control, alt, meta) that are not pressed ('up')</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlKeyUp.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlKeyUp.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyDown">
        <short>
          <var>KeyDown</var> - emulate the action of pressing the specified key (makes 
          
          <var>OnKeyDown</var> respond)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyDown.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyDownBeforeInterface">
        <short>
          <var>KeyDownBeforeInterface</var> - informs interface that the specified key (with defined shift state) was already pressed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyDownBeforeInterface.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyDownBeforeInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyDownAfterInterface">
        <short>
          <var>KeyDownAfterInterface</var> - informs interface that the specified key (with defined shift state) was pressed after an event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyDownAfterInterface.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyDownAfterInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyPress">
        <short>
          <var>KeyPress</var> - simulates the action of pressing the specified key</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyPress.Key">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyUp">
        <short>
          <var>KeyUp</var> - emulates the action of a key being released (makes 
          
          <var>OnKeyUp</var> respond)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyUp.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyUp.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyUpBeforeInterface">
        <short>
          <var>KeyUpBeforeInterface</var> - informs interface that the specified key (with defined shift state) was already up</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyUpBeforeInterface.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyUpBeforeInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.KeyUpAfterInterface">
        <short>
          <var>KeyUpAfterInterface</var> - informs interface that the specified key (with defined shift state) was released (up) after an event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyUpAfterInterface.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.KeyUpAfterInterface.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.UTF8KeyPress">
        <short>
          <var>UTF8KeyPress</var> - simulates the action of pressing the specified (UTF8) key</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.UTF8KeyPress.UTF8Key">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.FindNextControl">
        <short>
          <var>FindNextControl</var> - returns the next control on the list; optionally checks if it is a TabStop or a parent control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.FindNextControl.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.FindNextControl.CurrentControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.FindNextControl.GoForward">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.FindNextControl.CheckTabStop">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.FindNextControl.CheckParent">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.RealGetText" name="TWinControl.RealGetText">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.RealGetText.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.GetBorderStyle">
        <short>
          <var>GetBorderStyle</var> - returns the style of the border</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetBorderStyle.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.GetChildsRect" name="TWinControl.GetChildsRect">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetChildsRect.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetChildsRect.Scrolled">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.GetClientOrigin" name="TWinControl.GetClientOrigin">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetClientOrigin.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.GetClientRect" name="TWinControl.GetClientRect">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetClientRect.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.GetControlOrigin" name="TWinControl.GetControlOrigin">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetControlOrigin.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.GetDeviceContext" name="TWinControl.GetDeviceContext">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetDeviceContext.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetDeviceContext.WindowHandle">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.IsControlMouseMsg">
        <short>
          <var>IsControlMouseMsg</var> - returns True if the specified message is a control mouse message</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.IsControlMouseMsg.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.IsControlMouseMsg.TheMessage">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element link="#LCL.Controls.TControl.ParentHandlesAllocated" name="TWinControl.ParentHandlesAllocated">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.ParentHandlesAllocated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateHandle">
        <short>
          <var>CreateHandle</var> - generates an operating system handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateParams">
        <short>
          <var>CreateParams</var> - create parameters for this windowed class</short>
        <descr>
          <p>
            <var>CreateParams</var> - create parameters for this windowed class</p>
          <p>Definition of parameters:</p>
          <pre>TCreateParams = record
    Caption: PChar;
    Style: Cardinal;
    ExStyle: Cardinal;
    X, Y: Integer;
    Width, Height: Integer;
    WndParent: HWnd;
    Param: Pointer;
    WindowClass: TWndClass;
    WinClassName: array[0..63] of Char; 
End;
</pre>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CreateParams.Params">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateWnd">
        <short>
          <var>CreateWnd</var> - Creates the Window</short>
        <descr>
          <p>
            <printshort id="TWinControl.CreateWnd"/>
          </p>
          <p>Creates the interface object, sets parameters and assigns the handle</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DestroyHandle">
        <short>
          <var>DestroyHandle</var> - removes the handle for this window</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DestroyWnd">
        <short>
          <var>DestroyWnd</var> - destroy the window for this control</short>
        <descr>
          <p>
            <printshort id="TWinControl.DestroyWnd"/>
          </p>
          <p>Removes handles and restores colour and font flags</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoFlipChildren">
        <short>
          <var>DoFlipChildren</var> - reverses the order of the children</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.FixupTabList">
        <short>
          <var>FixupTabList</var> - renders the Tab list into a suitable state</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.FontChanged" name="TWinControl.FontChanged">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.InitializeWnd">
        <short>
          <var>InitializeWnd</var> - initialise the window for this control</short>
        <descr>
          <p>
            <var>InitializeWnd</var> - initialise the window for this control</p>
          <p>Gets called after the Handle is created and before the child handles are created</p>
          <p>Works out the correct bounds, sets style, fonts and colours, performs any pending resize operations</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.Loaded">
        <short>
          <var>Loaded</var> makes a number of checks, using client size if specified, and copying appropriate flags, fonts, text etc, makes list of child controls to notify them of any changes, then calls inherited 
          <var>Loaded</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.Loaded">TControl.Loaded</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.MainWndProc">
        <short>
          <var>MainWndProc</var> - issus a LCL message that this is the main window procedure</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.MainWndProc.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ParentFormHandleInitialized">
        <short>Called after all childs handles of the ParentForm are created. Tells all wincontrols about the final end of the handle creation phase</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.ParentFormHandleInitialized">TControl.ParentFormHandleInitialized</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ChildHandlesCreated">
        <short>
          <var>ChildHandlesCreated</var> - called after a child's handles are created</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ReAlign">
        <short>
          <var>ReAlign</var> - realign all children</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.RealSetText" name="TWinControl.RealSetText">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.RealSetText.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.RemoveFocus">
        <short>
          <var>RemoveFocus</var> from this WinContro</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.RemoveFocus.Removing">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.SendMoveSizeMessages" name="TWinControl.SendMoveSizeMessages">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SendMoveSizeMessages.SizeChanged">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SendMoveSizeMessages.PosChanged">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SetBorderStyle">
        <short>
          <var>SetBorderStyle</var> - specify the style for the border</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetBorderStyle.NewStyle">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.SetColor" name="TWinControl.SetColor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SetZOrder">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetZOrder.Topmost">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SetZOrderPosition">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetZOrderPosition.NewPosition">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ShowControl">
        <short>
          <var>ShowControl</var> - method for showing the specified control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ShowControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.Update" name="TWinControl.Update">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.UpdateControlState">
        <short>
          <var>UpdateControlState</var> - update the state of the control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.UpdateShowing">
        <short>
          <var>UpdateShowing</var> - update the value of the 
          <var>Showing</var> property</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WndProc">
        <short>
          <var>WndProc</var> - makes specific reactions according to the message passed, then calls inherited 
          <var>WndProc</var>
        </short>
        <descr>
          <p>LM_SETFOCUS: gets parent form and show this control as focused</p>
          <p>LM_KILLFOCUS: removes focus fromthis control</p>
          <p>LM_NCHITTEST: check transparency etc</p>
          <p>Mouse and Button messages: process any docking instructions</p>
        </descr>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.WndProc">TControl.WndProc</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WndProc.Message">
        <short/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TWinControl.BorderStyle">
        <short>
          <var>BorderStyle</var>
 - none, or single</short>
      </element>
      <!-- property Visibility: protected -->
      <element name="TWinControl.OnGetSiteInfo">
        <short>
          <var>OnGetSiteInfo</var> - event handler for finding out information about the (docking) site</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.BorderWidth">
        <short>Property to determine width of the window's border</short>
        <descr>// properties which are supported by all descendants<br/>
          <br/>Either reads a flag to find the width or sets the width. <br/>Default is set to zero.</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.BoundsLockCount">
        <short>Finds how many of the Bounds are locked</short>
        <descr>// properties which are supported by all descendants</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Brush">
        <short>Find which type of brush to use for drawing the control</short>
        <descr>// properties which are supported by all descendants</descr>
        <seealso>
          <link id="#lcl.graphics.TBrush"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.CachedClientHeight">
        <short>Stored value of client height</short>
        <descr>Read value fom flag</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.CachedClientWidth">
        <short>Stored value of Client Width</short>
        <descr>Reads value from flag</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.ChildSizing">
        <short>Definitions of how any child control is to be sized</short>
        <descr>Reads values from flag or stores values to flag. Most of the properties are inherited from TControlChildSizing, <br/>which you should read to find out more about this control</descr>
        <seealso>
          <link id="#lcl.Controls.TControlChildSizing"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.ControlCount">
        <short>The number of controls associated with this window</short>
        <descr>// properties which are supported by all descendants <br/>Reads value from flag</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Controls">
        <short>The indexed list of controls found in this window</short>
        <descr>// properties which are supported by all descendants
<br/>

 Reads values from a flag; Index is a number signifying which control, from a list
</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.Controls.Index">
        <short>Numerical value to identify the control within the window</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DefWndProc">
        <short>The default procedure to be associated with the window</short>
        <descr>// properties which are supported by all descendants<br/>reads or writes a flag to define what is the default procedure</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockClientCount">
        <short>The number of clients to which this control is docked</short>
        <descr>Reads count from flag</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockClients">
        <short>The indexed list of dock clients of this window</short>
        <descr>Reads a flag to find the actual dock client controls
</descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DockClients.Index">
        <short>The serial numbers (Index) of the dock clients</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockManager">
        <short>Property that actually controls the docking process</short>
        <descr>Reads or writes a flag. Derived from the parent class TDockManager</descr>
        <seealso>
          <link id="#lcl.Controls.TDockManager"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DockSite">
        <short>Is this a dock site? Default false</short>
        <descr>Reads or sets a flag to show whether this is a dock site. Default false</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.DoubleBuffered">
        <short>Are the contents of this window to be double buffered?</short>
        <descr>Reads or writes flag to determine whether double buffering is to be used</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Handle">
        <short>Operating System Handle for identifying and manipulating this window</short>
        <descr>Reads from or writes handle to flag
</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.IsResizing">
        <short>Is the window being re-sized?</short>
        <descr>Reads or writes flag to indicate re-sizing</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.TabOrder">
        <short>The place this control occupies in the list of tabs</short>
        <descr>Reads or writes information in flag; default is -1</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.TabStop">
        <short>Is the control in the sequence of controls accessed by successive presses of the Tab key?</short>
        <descr>Use the TabStop to allow or disallow access to the control using the Tab key.

If the TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user can't press the Tab key to move to the control.
</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnDockDrop">
        <short>Event handler for dropping a control in a docked position</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnDockOver">
        <short>Event handler for docking a control over another control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnEnter">
        <short>
          <var>OnEnter</var>
 - event handler for when the mouse enters the control, and the control receives focus</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnExit">
        <short>
          <var>OnExit</var>
 - event handler for when the mouse leaves the control and it loses focus</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnKeyDown">
        <short>
          <var>OnKeyDown</var>
 - event handler for instance when key is down while control has focus</short>
        <descr>
          <p>
            <var>OnKeyDown</var>
 - event handler for instance when key is down while control has focus</p>
          <p>Differs from <link id="#lcl.Controls.TWinControl.OnKeyPress">OnKeyPress</link> in that the key may have already been down when the control received focus; with <var>OnKeyPress</var> the key needs to become pressed while the control has focus.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnKeyPress">
        <short>OnKeyPress - event controller for a key being pressed while the control has focus. To properly handle national chars use UTF8KeyPress instead.</short>
        <descr>
          <p>
            <var>OnKeyPress</var>
 - event controller for a key being pressed while the control has focus</p>
          <p>Differs from <link id="#lcl.Controls.TWinControl.OnKeyDown">OnKeyDown</link> in that the key needs to become pressed while the control has focus; with <var>OnKeyDown</var>  the key may have already been down when the control received focus.</p>
          <p>Note: we recommend you to use OnUTF8KeyPress to prevent data lost. National chars are converted from UTF8 to the system encoding in OnKeyPressEvent. This can cause a data lost if symbol cannot be converted, which means OnKeyPress is not called or with Char=#0. OnUTF8KeyPress does not perform this conversion.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnKeyUp">
        <short>
          <var>OnKeyUp</var>
  - event handler for instance when a key is up (not pressed) while the control has focus</short>
        <descr>
          <p>
            <var>OnKeyUp</var>
  - event handler for instance when a key is up (not pressed) while the control has focus</p>
          <p>The key may already have been up when the control received focus, or a pressed key may become released during the time the control has focus.</p>
        </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnMouseWheel">
        <short>Event handler for any movement of the mouse wheel</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnMouseWheelDown">
        <short>Event handler for downward movement of the mouse wheel</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnMouseWheelUp">
        <short>Event handler for upward movement of the mouse wheel</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnUnDock">
        <short>
          <var>OnUnDock</var>
 - event handler for control becoming disconnected (undocked) from parent</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.OnUTF8KeyPress">
        <short>UTF8KeyPress - event controller for a key being pressed while the control has focus.</short>
        <descr>
          <p>
            <var>OnUTF8KeyPress</var> - event controller for a key being pressed while the control has focus</p>
          <p>Differs from <link id="#lcl.Controls.TWinControl.OnKeyPress">OnKeyDown</link> in that the char does not converts to the system encoding</p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.ParentCtl3D">
        <short>
          <var>ParentCtl3D</var> - does it inherit Ctl3D properties from parents? (Deprecated)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.Showing">
        <short>Is the window showing? (similar to Visible in other contexts)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.UseDockManager">
        <short>Use a dock manager to control docking? (default false)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TWinControl.VisibleDockClientCount">
        <short>The number of visible client controls for docking</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.AdjustSize">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Controls.TControl.AutoSizeDelayed" name="TWinControl.AutoSizeDelayed">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.AutoSizeDelayed.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.BeginUpdateBounds">
        <short>
          <var>BeginUpdateBounds</var> - start updating the bounds of the current WinControl</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.EndUpdateBounds">
        <short>
          <var>EndUpdateBounds</var> - finishes updating the bounds setting</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.LockRealizeBounds">
        <short>
          <var>LockRealizeBounds</var> - make the realized bounds unaccessible</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.UnlockRealizeBounds">
        <short>
          <var>UnlockRealizeBounds</var> - unlock the previously locked realized bounds</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.ControlAtPos">
        <short>
          <var>ControlAtPos</var> - the identity of the control located at the specified point 
          
          <var>Pos</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.ControlAtPos.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlAtPos.Pos">
        <short>
          <var>ControlAtPos</var> - the identity of the control located at the specified point 
		      
          <var>Pos</var>
        </short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlAtPos.AllowDisabled">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.ControlAtPos">
        <short>
          <var>ControlAtPos</var> - the identity of the control located at the specified point 
		      
          <var>Pos</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.ControlAtPos.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlAtPos.Pos">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlAtPos.AllowDisabled">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlAtPos.AllowWinControls">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.ControlAtPos">
        <short>
          <var>ControlAtPos</var> - the identity of the control located at the specified point 
		      
          <var>Pos</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.ControlAtPos.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlAtPos.Pos">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlAtPos.AllowDisabled">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlAtPos.AllowWinControls">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlAtPos.OnlyClientAreas">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.DoAdjustClientRectChange">
        <short>
          <var>DoAdjustClientRectChange</var> - perform any adjustments needed when the client rectangle changes</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.InvalidateClientRectCache">
        <short>
          <var>InvalidateClientRectCache</var> - render invalid any information in the client rectangle cache</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.InvalidateClientRectCache.WithChildControls">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.ClientRectNeedsInterfaceUpdate">
        <short>
          <var>ClientRectNeedsInterfaceUpdate</var> - True if update needed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.ClientRectNeedsInterfaceUpdate.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TControl.SetBounds" name="TWinControl.SetBounds">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetBounds.aLeft">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetBounds.aTop">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetBounds.aWidth">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetBounds.aHeight">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TWinControl.Create">
        <seealso>
          <link id="#rtl.Classes.TComponent.Create">TComponent.Create</link>
          <link id="#LCL.Controls.TControl.Create">TControl.Create</link>
        </seealso>
        <short>
          <var>Create</var> - constructor for 
          <var>TWinControl</var>: performs inherited 
          <var>Create</var> and initialises some local variables</short>
        <descr>
          <p>
            <var>Create</var> - Constructor for 
            <var>TWinControl</var>: performs inherited 
            <var>Create</var> and initialises some local variables</p>
          <p>Overrides ancestor constructor, and may in turn be overridden</p>
          <p>Among additional variables initialised are: CompStyle, ChildSizing, Brush, TabOrder and TabStop</p>
        </descr>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.Create.TheOwner">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TWinControl.CreateParented">
        <short>
          <var>CreateParented</var> - constructor for a window that is the child of a specified parent</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CreateParented.ParentWindow">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.CreateParentedControl">
        <short>
          <var>CreateParentedControl</var> - returns a newly created window control that has a specified window as its parent</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.CreateParentedControl.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CreateParentedControl.ParentWindow">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TWinControl.Destroy">
        <short>
          <var>Destroy</var> - destructor for 
          <var>TWinControl</var> and derived classes. Removes handles and docked controls, frees resources, then calls inherited 
          <var>Destroy</var>
        </short>
        <descr>
          <p>
            <var>Destroy</var> - destructor for 
            <var>TWinControl</var> and derived classes</p>
          <p>Destroys any allocated handles, removes any docking links, and frees the resources used by the control, then performs inherited <var>Destroy</var>
          </p>
          <p>Overrides ancestor destructors, and may in turn be overridden</p>
        </descr>
        <seealso>
          <link id="#LCL.Controls.TControl.Destroy">TControl.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.DockDrop">
        <short>
          <var>DockDrop</var> - drop a dragged object into its docking position</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DockDrop.DockObject">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DockDrop.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DockDrop.Y">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.CanFocus">
        <short>
          <var>CanFocus</var> -  is the current window allowed to receive focus?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.CanFocus.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.GetControlIndex">
        <short>
          <var>GetControlIndex</var> - find the index value for the given control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetControlIndex.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetControlIndex.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SetControlIndex">
        <short>
          <var>SetControlIndex</var> - set a new index value for the given control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetControlIndex.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetControlIndex.NewIndex">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.Focused">
        <short>
          <var>Focused</var> - is the current window receiving focus?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.Focused.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.PerformTab">
        <short>
          <var>PerformTab</var> - perform a tab - is it in the forward direction?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.PerformTab.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.PerformTab.ForwardTab">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.ControlByName">
        <short>
          <var>ControlByName</var> - returns the identity of a control whose name is given as an argument</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.ControlByName.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlByName.ControlName">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SelectNext">
        <short>
          <var>SelectNext</var> - move to the next windowed control and give it focus</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SelectNext.CurControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SelectNext.GoForward">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SelectNext.CheckTabStop">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.BroadCast">
        <short>
          <var>BroadCast</var> - send 
          
          <var>ToAllMessage</var> to all recipients</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.BroadCast.ToAllMessage">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.NotifyControls">
        <short>
          <var>NotifyControls</var> - send 
          
          <var>Msg </var>(a message) to all controls</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.NotifyControls.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.DefaultHandler">
        <short>
          <var>DefaultHandler</var> - performs 
          <var>CallDefaultWndHandler</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.DefaultHandler">TObject.DefaultHandler</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DefaultHandler.AMessage">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.DisableAlign">
        <short>
          <var>DisableAlign</var> - turn off any alignment</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.EnableAlign">
        <short>
          <var>EnableAlign</var> - turn on the alignment process</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.Controls.TControl.GetTextLen" name="TWinControl.GetTextLen">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetTextLen.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TControl.Invalidate" name="TWinControl.Invalidate">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.InsertControl">
        <short>
          <var>InsertControl</var> - insert the specified control into the list, optionally with the specified index</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.InsertControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.InsertControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.InsertControl.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.InsertControl.Index">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.RemoveControl">
        <short>
          <var>RemoveControl</var> - remove the specified control from the list</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.RemoveControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.Insert">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.Insert.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.Insert">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.Insert.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.Insert.Index">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.Remove">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.Remove.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TControl.Repaint" name="TWinControl.Repaint">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SetFocus">
        <short>
          <var>SetFocus</var> - give the current control the focus</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.FindChildControl">
        <short>
          <var>FindChildControl</var> - find what controls are descended from the current one</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.FindChildControl.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.FindChildControl.ControlName">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.FlipChildren">
        <short>
          <var>FlipChildren</var> - reverse the order of the child components</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.FlipChildren.AllLevels">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.GetTabOrderList">
        <short>
          <var>GetTabOrderList</var> - find the list with the Tab Order</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetTabOrderList.List">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.HandleAllocated">
        <short>
          <var>HandleAllocated</var> - find if the operating system has allocated a handle to this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.HandleAllocated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.HandleNeeded">
        <short>
          <var>HandleNeeded</var> - tell the Operating System that this control requires a handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.BrushCreated">
        <short>
          <var>BrushCreated</var> - has a brush been created for this control?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.BrushCreated.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.EraseBackground">
        <short>
          <var>EraseBackground</var> - remove all material from the background</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.EraseBackground.DC">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.IntfUTF8KeyPress">
        <short>
          <var>IntfUTF8KeyPress</var> - returns the UTF8 value of the pressed key from the interface</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.IntfUTF8KeyPress.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.IntfUTF8KeyPress.UTF8Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.IntfUTF8KeyPress.RepeatCount">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TGraphicControl">
        <short>
          <var>TGraphicControl</var>
 is the base class for all lightweight controls.</short>
        <descr>
          <p>
            <var>TGraphicControl</var>
 supports simple lightweight controls that do not 
need the ability to accept keyboard input or contain other controls. </p>
          <p>Since lightweight controls do not wrap GUI screen objects, they are faster and use fewer resources than controls based on <var>TWinControl</var>.</p>
          <p>
            <var>TGraphicControl</var>
 provides a 
            
            <var>Canvas</var> property for access to the control's drawing surface and a virtual 
            
            <var>Paint</var> method called in response to paint requests received by the parent control.</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TWinControl"/>
          <link id="#lcl.Graphics.TCanvas"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TGraphicControl.FCanvas">
        <short>A reference to the parent's Canvas.</short>
        <descr>The canvas isn't "owned" by the TGraphicControl, but by its parent.</descr>
      </element>
      <!-- variable Visibility: private -->
      <element name="TGraphicControl.FOnPaint">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TGraphicControl.WMPaint">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphicControl.WMPaint.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TGraphicControl.Paint">
        <short>Virtual <var>Paint</var> method called in response to paint requests.</short>
        <descr>Virtual <var>Paint</var> method called in response to paint requests received by the parent control.</descr>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TGraphicControl.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TGraphicControl</var>: performs inherited 
          <var>Create</var> then creates local 
          <var>Canvas</var>
        </short>
        <descr>
          <p>
            <var>Create</var> - constructor for 
            <var>TGraphicControl</var>: performs inherited 
            <var>Create</var> then creates local 
            <var>Canvas</var>
          </p>
          <p>Overrides ancestor and may be overridden</p>
        </descr>
        <seealso>
          <link id="#LCL.Controls.TControl.Create">TControl.Create</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphicControl.Create.AOwner">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TGraphicControl.Destroy">
        <short>
          <var>Destroy</var> - destructor for 
          <var>TGraphicControl</var>: frees local canvas and performs inherited 
          <var>Destroy</var>
        </short>
        <descr>
          <p>
            <var>Destroy</var> - destructor for 
            <var>TGraphicControl</var>: frees local canvas and performs inherited 
            <var>Destroy</var>
          </p>
          <p>Overrides ancestor destructors, and may be overridden</p>
        </descr>
        <seealso>
          <link id="#LCL.Controls.TControl.Destroy">TControl.Destroy</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphicControl.Canvas">
        <short>A clipping window to the parent canvas.</short>
        <descr>
          <p>
            <var>The TGraphicsControl.Canvas</var>
 is a clipping window to the parent canvas.</p>
          <p>If you ask for the <var>Canvas.Width</var> or <var>Canvas.Height</var>, you are actually 
getting the parent control's Canvas dimensions.</p>
          <p>To get the dimensions of the <var>TGraphicControl,</var> you must query the <var>ClientRect</var>.</p>
        </descr>
        <seealso>
          <link id="#lcl.Graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TGraphicControl.OnPaint">
        <short>
          <var>OnPaint</var>
 - event handler for request to paint canvas</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TCustomControl">
        <short>
          <var>TCustomControl </var>- a base class for many window controls</short>
        <descr>
          <p>Contains simple basic definitions to create, destroy and paint window controls and set basic properties like canvas and border</p>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TWinControl">TWinControl</link>
          <link id="#lcl.Controls.TControl">TControl</link>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomControl.FCanvas">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TCustomControl.FOnPaint">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomControl.WMPaint">
        <short>
          <var>WMPaint</var> - LCL message for painting</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomControl.WMPaint.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TWinControl.PaintWindow" name="TCustomControl.PaintWindow">
        <short>Paint handler plug-in</short>
        <descr>This is a plug-in in TWinControl to get the DC, <br/>
assign it to our canvas and call the paint method for <br/>
descendants to do the actual painting
</descr>
        <seealso>
          <link id="#lcl.Controls.TWinControl.PaintWindow">TWinControl.PaintWindow</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomControl.PaintWindow.DC">
        <short>The Device Context in which to paint</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TCustomControl.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TCustomControl</var>: performs inherited 
          <var>Create</var>, then creates local 
          <var>Canvas</var> and sets 
          <var>DoubleBuffered</var> to be False</short>
        <seealso>
          <link id="#LCL.Controls.TControl.Create">TControl.Create</link>
          <link id="#LCL.Controls.TWinControl.Create">TWinControl.Create</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomControl.Create.AOwner">
        <short>Owner, ie the component that called this control</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TCustomControl.Destroy">
        <short>
          <var>Destroy</var> - destructor for 
          <var>TCustomControl</var>: frees local 
          <var>Canvas</var> then performs inherited 
          <var>Destroy</var>
        </short>
        <descr>
          <p>
            <var>Destroy</var> - destructor for 
            <var>TCustomControl</var>: frees local 
            <var>Canvas</var> then performs inherited 
            <var>Destroy</var>
          </p>
          <p>Overrides ancestor destructors, may be overridden</p>
        </descr>
        <seealso>
          <link id="#LCL.Controls.TControl.Destroy">TControl.Destroy</link>
          <link id="#LCL.Controls.TWinControl.Destroy">TWinControl.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomControl.DestroyComponent">
        <short>If the custom control has been destroyed, free its handle as well</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TCustomControl.Paint">
        <short>The default paint handler for the class</short>
        <descr>If using a control derived from this parent, the developer needs to write a specific paint handler to override this one</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomControl.Canvas">
        <short>The area of a control on which its components are drawn or painted</short>
        <descr>The Canvas is the area of screen on which the various components are drawn. <br/>
This inherits its properties from TCanvas, <br/>
and that description should be read to understand their definitions more fully.
</descr>
        <seealso>
          <link id="#lcl.Graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element link="#LCL.Controls.TWinControl.BorderStyle" name="TCustomControl.BorderStyle">
        <descr>Only a restricted series of options is available: none or a single border.
</descr>
        <seealso>
          <link id="#lcl.Controls.TBorderStyle"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomControl.OnPaint">
        <short>Event handler for painting</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TImageList">
        <short>
          <var>TImageList</var> - a list of images (usually ready for dragging)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element link="#LCL.ImgList.TCustomImageList.BkColor" name="TImageList.BkColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element link="#LCL.ImgList.TCustomImageList.Height" name="TImageList.Height">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element link="#LCL.ImgList.TCustomImageList.Masked" name="TImageList.Masked">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element link="#LCL.ImgList.TCustomImageList.Width" name="TImageList.Width">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element link="#LCL.ImgList.TCustomImageList.OnChange" name="TImageList.OnChange">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlPropertyStorage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlPropertyStorage.GetPropertyList">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlPropertyStorage.GetPropertyList.List">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDockZone">
        <short>
          <var>TDockZone</var> is a node in the 
          <var>TDockTree</var> and encapsulates a region into which  other zones or a single control are contained.</short>
        <descr>This is an ancestor class for <var>TDockTree</var>, in the sense that it forms the elementary component of which the tree is constructed
</descr>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockZone.FChildControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockZone.FChildCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockZone.FFirstChildZone">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockZone.FTree">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockZone.FZoneLimit">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockZone.FParentZone">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockZone.FOrientation">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockZone.FNextSibling">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockZone.FPrevSibling">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetHeight">
        <short>
          <var>GetHeight</var> - returns height for dock zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetLeft">
        <short>
          <var>GetLeft</var> - returns the position of the left hand border</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetLeft.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetLimitBegin">
        <short>
          <var>GetLimitBegin</var> - returns the limit for the beginning of the zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetLimitBegin.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetLimitSize">
        <short>
          <var>GetLimitSize</var> - returns the limit for the size of the zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetLimitSize.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetTop">
        <short>
          <var>GetTop</var> - returns the position of the top</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetTop.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetVisible">
        <short>
          <var>GetVisible</var> - returns the 
          <var>Visible</var> status</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetVisibleChildCount">
        <short>
          <var>GetVisibleChildCount</var> - returns the number of visible children</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetVisibleChildCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetWidth">
        <short>
          <var>GetWidth</var> - returns the width of the zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetZoneLimit">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetZoneLimit.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TDockZone.SetZoneLimit">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockZone.SetZoneLimit.AValue">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.IsOrientationValid">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.IsOrientationValid.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TDockZone.GetNextVisibleZone">
        <short>
          <var>GetNextVisibleZone</var> - returns the next visible zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetNextVisibleZone.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDockZone.Create">
        <descr>
          <p>
            <var>Create</var> - constructor for 
            <var>TDockZone</var>: sets local variables to show the 
            <var>Tree</var> to which the zone belongs and the 
            <var>ChildControl</var> which it contains, sets default bounds and then performs inherited 
            <var>Create</var>
          </p>
          <p>Overrides ancestor constructors, and may be overridden</p>
        </descr>
        <short>
          <var>Create</var> - constructor for 
          <var>TDockZone</var>: sets local variables to show the 
          <var>Tree</var> and the 
          <var>ChildControl</var>, sets default bounds and then performs inherited 
          <var>Create</var>
        </short>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockZone.Create.TheTree">
        <short>The dock tree to which this zone belongs</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.ExpandZoneLimit">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockZone.ExpandZoneLimit.NewLimit">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.FirstVisibleChild">
        <short>
          <var>FirstVisibleChild</var> - returns the first visible child zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.FirstVisibleChild.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.NextVisible">
        <short>
          <var>NextVisible</var> - returns next visible</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.NextVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.PrevVisible">
        <short>
          <var>PrevVisible</var> - returns the previous visible</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.PrevVisible.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.ResetChildren">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.ResetZoneLimits">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.Update">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Tree">
        <short>The dock tree of which this dock zone is a part</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.ChildCount">
        <short>The number of child controls for docking</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Height">
        <short>The height of the Dock Zone</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Left">
        <short>The position of the left side to the control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.LimitBegin">
        <short>The beginning limit of the DockZone (Left or Top)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.LimitSize">
        <short>The size of the limits of the DockZone (Width or Height)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Top">
        <short>The top coordinate of this control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Visible">
        <short>Is the control visible?</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.VisibleChildCount">
        <short>
          <var>VisibleChildCount</var> - the number of visible child controls</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Width">
        <short>The width of this control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.ZoneLimit">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TDockZoneClass">
        <short>
          <var>TDockZoneClass</var> - class of 
          <var>TDockZone</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TForEachZoneProc">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TForEachZoneProc.Zone">
        <short/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TDockTreeClass">
        <short>
          <var>TDockTreeClass</var> - class of 
          <var>TDockTree</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TDockTreeFlag">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDockTreeFlag.dtfUpdateAllNeeded">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TDockTreeFlags">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDockTree">
        <short>
          <var>TDockTree</var> - A tree of dock zones - every docked window has one tree</short>
        <descr>
          <pre>TDockTree - a tree of TDockZones - Every docked window has one tree

  
    This is an abstract class. The real implementation is in ldocktree.pas.

    Docking means here: Combining several windows to one. A window can here be
    a TCustomForm or a floating control (undocked) or a TDockForm.
    A window can be docked to another to the left, right, top, bottom or "into".
    The docking source window will be resized, to fit to the docking target
    window.

    Example1: Docking "A" (source window) left to "B" (target window)
    
       +---+    +----+
       | A | -&gt; | B  |
       +---+    |    |
                +----+
      Result: A new docktree will be created. Height of "A" will be resized to
              the height of "B".
              A splitter will be inserted between "A" and "B".
              And all three are children of the newly created TLazDockForm of the
              newly created TDockTree.
      
       +------------+
       |+---+|+----+|
       || A ||| B  ||
       ||   |||    ||
       |+---+|+----+|
       +------------+

      If "A" or "B" were floating controls, the floating dock sites are freed.
      If "A" or "B" were forms, their decorations (title bars and borders) are
      replaced by docked decorations.
      If "A" had a TDockTree, it is freed and its child dockzones are merged to
      the docktree of "B". Analog for docking "C" left to "A":
      
       +------------------+
       |+---+|+---+|+----+|
       || C ||| A ||| B  ||
       ||   |||   |||    ||
       |+---+|+---+|+----+|
       +------------------+
       

      
    Example2: Docking A into B
                +-----+
       +---+    |     |
       | A | ---+-&gt; B |
       +---+    |     |
                +-----+

      Result: A new docktree will be created. "A" will be resized to the size
              of "B". Both will be put into a TLazDockPages control which is the
              child of the newly created TDockTree.
              
       +-------+
       |[B][A] |
       |+-----+|
       ||     ||
       || A   ||
       ||     ||
       |+-----+|
       +-------+

    Every DockZone has siblings and children. Siblings can either be
    - horizontally (left to right, splitter),
    - vertically (top to bottom, splitter)
    - or upon each other (as pages, left to right).


    InsertControl - undock control and dock it into the manager. For example
                    dock Form1 left to a Form2:
                    InsertControl(Form1,alLeft,Form2);
                    To dock "into", into a TDockPage, use Align=alNone.
    PositionDockRect - calculates where a control would be placed, if it would
                       be docked via InsertControl.
    RemoveControl - removes a control from the dock manager.

    GetControlBounds - TODO for Delphi compatibility
    ResetBounds - TODO for Delphi compatibility
    SetReplacingControl - TODO for Delphi compatibility
    PaintSite - TODO for Delphi compatibility

</pre>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TDockManager">TDockManager</link>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FBorderWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FDockSite">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FDockZoneClass">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FGrabberSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FGrabbersOnTop">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FFlags">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FTopZone">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FTopXYLimit">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FUpdateCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TDockTree.DeleteZone">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.DeleteZone.Zone">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.AdjustDockRect">
        <short>
          <var>AdjustDockRect</var> - adjust the position of the docking rectangle for the nominated control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.AdjustDockRect.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.AdjustDockRect.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.BeginUpdate" name="TDockTree.BeginUpdate"/>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.EndUpdate" name="TDockTree.EndUpdate">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.GetControlBounds" name="TDockTree.GetControlBounds">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.GetControlBounds.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.GetControlBounds.ControlBounds">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TDockTree.HitTest">
        <short>
          <var>HitTest</var> - performs a Hit test at the specified mouse position, and returns the Control present there </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockTree.HitTest.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.HitTest.MousePos">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.HitTest.HTFlag">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.InsertControl" name="TDockTree.InsertControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.InsertControl.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.InsertControl.InsertAt">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.InsertControl.DropControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.LoadFromStream" name="TDockTree.LoadFromStream">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.LoadFromStream.SrcStream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.PaintDockFrame">
        <short>
          <var>PaintDockFrame</var> - paints the nominated control's canvas at the specified position</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.PaintDockFrame.ACanvas">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.PaintDockFrame.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.PaintDockFrame.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.PositionDockRect" name="TDockTree.PositionDockRect">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.PositionDockRect.AClient">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.PositionDockRect.DropCtl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.PositionDockRect.DropAlign">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.PositionDockRect.DockRect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.RemoveControl" name="TDockTree.RemoveControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.RemoveControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.SaveToStream" name="TDockTree.SaveToStream">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.SaveToStream.DestStream">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.SetReplacingControl" name="TDockTree.SetReplacingControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.SetReplacingControl.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TDockManager.ResetBounds" name="TDockTree.ResetBounds">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.ResetBounds.Force">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.UpdateAll">
        <short>
          <var>UpdateAll</var> - bring all data up to date</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TDockTree.DockSite">
        <short>
          <var>DockSite</var> - the site for docking</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDockTree.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TDockTree</var>: sets up the 
          <var>DockSite</var>, performs inherited 
          <var>Create</var> and sets default 
          <var>BorderWidth</var>, creates the 
          <var>RootZone</var> for the Tree</short>
        <descr>
          <p>
            <var>Create</var> - constructor for 
            <var>TDockTree</var>: sets up the 
            <var>DockSite</var>, performs inherited 
            <var>Create</var> and sets default 
            <var>BorderWidth</var>, creates the 
            <var>RootZone</var> for the Tree</p>
          <p>Overrides ancestor constructors, may be overridden</p>
        </descr>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.Create.TheDockSite">
        <short>The window control that is to be the site for docking</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TDockTree.Destroy">
        <short>
          <var>Destroy</var> - destructor for 
          <var>TDockTree</var>: deletes the 
          <var>RootZone</var> then performs inherited 
          <var>Destroy</var>
        </short>
        <descr>
          <p>
            <var>Destroy</var> - destructor for 
            <var>TDockTree</var>: deletes the 
            <var>RootZone</var> then performs inherited 
            <var>Destroy</var>
          </p>
          <p>Overrides ancestor destructors, and may be overridden</p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Destroy">TPersistent.Destroy</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TDockManager.PaintSite" name="TDockTree.PaintSite">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.PaintSite.DC">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockTree.DockZoneClass">
        <short>
          <var>DockZoneClass</var> - the class of dock zone</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TMouse">
        <short>
          <var>TMouse</var> - some properties of the current Mouse</short>
        <descr>Contains information about current mouse position, whether it has captured an object, whether it is dragging the object, and how far the mouse is allowed to move before the captured object is made to move.
</descr>
      </element>
      <!-- variable Visibility: default -->
      <element name="TMouse.FCapture">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TMouse.FDragImmediate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TMouse.FDragThreshold">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="TMouse.SetCapture">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouse.SetCapture.Value">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="TMouse.GetCapture">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TMouse.GetCapture.Result">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="TMouse.GetCursorPos">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TMouse.GetCursorPos.Result">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="TMouse.GetIsDragging">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TMouse.GetIsDragging.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TMouse.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TMouse</var>: calls inherited 
          <var>Create</var>
        </short>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TMouse.Destroy">
        <descr>Can be a locally defined method to override the method specified by the parent object
</descr>
        <short>
          <var>Destroy</var> - destructor for 
          <var>TMouse</var>: calls inherited 
          <var>Destroy</var>
        </short>
        <seealso>
          <link id="#rtl.System.TObject.Destroy">TObject.Destroy</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.Capture">
        <short>System handle for the captured object</short>
        <descr>Reads or writes a system variable identifying the captured object</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.CursorPos">
        <short>The screen position of the cursor</short>
        <descr>Reads or writes a variable to determine the position of the cursor (a point with X, Y co-ordinates)</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.DragImmediate">
        <short>Does the object get dragged as soon as the mouse moves?</short>
        <descr>Reads or writes a flag to determine whether to move the object immediately the mouse moves: default is true</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.DragThreshold">
        <short>The least distance the mouse must move before the captured object is moved</short>
        <descr>Reads or writes a flag to deterine the threshold movement (if DragImmediate was false). Default is 5 pixels</descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.IsDragging">
        <short>Is the mouse being used to drag an object?</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="AnchorAlign">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefaultSideForAnchorKind">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="AnchorReferenceSide">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="AlignNames">
        <short>the strings that appear, eg in the Object Inspector, to describe the possible types of alignments</short>
      </element>
      <!-- function Visibility: default -->
      <element name="FindDragTarget">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="FindDragTarget.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FindDragTarget.Position">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FindDragTarget.AllowDisabled">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindControlAtPosition">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="FindControlAtPosition.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FindControlAtPosition.Position">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FindControlAtPosition.AllowDisabled">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindLCLWindow">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="FindLCLWindow.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FindLCLWindow.ScreenPos">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindControl">
        <short>Find the Handle for the specified Control</short>
        <descr>
          <p>FindControl</p>
          <p>Returns the TWinControl associated with the Handle.</p>
          <p>This is very interface specific. Better use FindOwnerControl.</p>
          <p>Handle can also be a child handle, and does not need to be the Handle
		property of the Result.</p>
          <p>IMPORTANT: So, in most cases: Result.Handle &lt;&gt; Handle in the params.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="FindControl.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FindControl.Handle">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindOwnerControl">
        <short>Find the Handle for the specified Owner Control</short>
        <descr>
          <p>FindOwnerControl</p>
          <p>Returns the TWinControl owning the Handle. Handle can also be a child handle,</p>
          <p>and does not need to be the Handle property of the Result.</p>
          <p>IMPORTANT: Therefore, in most cases: parameter Handle &lt;&gt; Result.Handle</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="FindOwnerControl.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FindOwnerControl.Handle">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="FindLCLControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="FindLCLControl.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="FindLCLControl.ScreenPos">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="SendAppMessage">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="SendAppMessage.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="SendAppMessage.Msg">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="SendAppMessage.WParam">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="SendAppMessage.LParam">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="MoveWindowOrg">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="MoveWindowOrg.dc">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="MoveWindowOrg.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="MoveWindowOrg.Y">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="RecreateWnd">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="RecreateWnd.AWinControl">
        <short/>
      </element>
      <!-- variable Visibility: default -->
      <element name="DefaultDockTreeClass">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="SetCaptureControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="SetCaptureControl.Control">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GetCaptureControl">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="GetCaptureControl.Result">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="CancelDrag">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="DragDone">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="DragDone.Drop">
        <short/>
      </element>
      <!-- variable Visibility: default -->
      <element name="NewStyleControls">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="Mouse">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: default -->
      <element name="CursorToString">
        <short>Returns a string for the name of the cursor as identified by an integer constant</short>
        <descr>Calls CursorToIdent to find correct entry in look-up table</descr>
        <errors/>
        <seealso>
          <link id="#lcl.Controls.CursorToIdent"/>
        </seealso>
      </element>
      <!-- function result Visibility: default -->
      <element name="CursorToString.Result">
        <short>Returns a string with the name of the cursor type corresponding to the integer constant</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="CursorToString.Cursor">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="StringToCursor">
        <short>
          <var>StringToCursor</var> - returns the cursor value corresponding to the name supplied</short>
        <descr>
          <p>
            <var>StringToCursor</var> - returns the cursor value corresponding to the name supplied</p>
          <p>Finds the numeric cursor value corresponding to the name <var>S</var> in the cursor look-up table</p>
        </descr>
      </element>
      <!-- function result Visibility: default -->
      <element name="StringToCursor.Result">
        <short>The numeric cursor value from the look-up table</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="StringToCursor.S">
        <short>The name of the cursor for which the numeric value is sought</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="GetCursorValues">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="GetCursorValues.Proc">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="CursorToIdent">
        <short>Uses look-up table to find cursor identifier corresponding to integer cursor constant</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="CursorToIdent.Result">
        <short>Returns true if a valid entry is found in the look-up table</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="CursorToIdent.Cursor">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="CursorToIdent.Ident">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="IdentToCursor">
        <short>
          <var>IdentToCursor</var> - uses look-up table to find numeric cursor value corresponding to the Identifier string</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="IdentToCursor.Result">
        <short>Returns True if a valid entry was found in the look-up table</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="IdentToCursor.Ident">
        <short>The name of the cursor cor which the numeric value is sought</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="IdentToCursor.Cursor">
        <short>The numeric value of the named cursor</short>
      </element>
      <!-- function Visibility: default -->
      <element name="GetKeyShiftState">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="GetKeyShiftState.Result">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="AdjustBorderSpace">
        <short>Adjust space round border of this control</short>
        <descr>
          <p>RemainingClientRect: remaining clientrect without CurBorderSpace</p>
          <p>CurBorderSpace: current borderspace around RemainingClientRect</p>
          <p>Left, Top, Right, Bottom: apply these borderspaces to CurBorderSpace</p>
          <p>CurBorderSpace will be set to the maximum of CurBorderSpace and Left, Top, Right, Bottom.</p>
          <p>RemainingClientRect will shrink.</p>
          <p>RemainingClientRect will not shrink to negative size.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="AdjustBorderSpace.RemainingClientRect">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="AdjustBorderSpace.CurBorderSpace">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="AdjustBorderSpace.Left">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="AdjustBorderSpace.Top">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="AdjustBorderSpace.Right">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="AdjustBorderSpace.Bottom">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="Register">
        <short>Register the components used in the current application, so that they can be recognised</short>
        <seealso>
          <link id="#rtl.classes.registercomponents"/>
        </seealso>
      </element>
      <element name="TControl.BiDiMode">
        <short>
          <var>BiDiMode</var> - enabling bi-directional writing</short>
        <descr>Allows Languages such as Arabic and Hebrew to be used
</descr>
      </element>
      <element name="TControl.ParentBiDiMode">
        <short>
          <var>ParentBiDiMode</var>
 - does the control follow the BiDiMode settings of its parent?</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="fsSurface">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="fsBorder">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvNone">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvLowered">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvRaised">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="bvSpace">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.XPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.YPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.Pos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMMouseWheel.Result">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TCaptureMouseButtons">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csNoDesignSelectable">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlStyleType.csOwnedChildsSelectable">
        <short/>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PHintInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="THintInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintWindowClass">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintMaxWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintColor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.CursorRect">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.CursorPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.ReshowTimeout">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HideTimeout">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintStr">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="THintInfo.HintData">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FDragCursor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FDragging">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FDragHotspot">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FOldCursor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FImageIndex">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FLastDragPos">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragImageList.FLockedWindow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TDragImageList.SetDragCursor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.SetDragCursor.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragImageList.Initialize">
        <short>
          <var>Initialize</var> the list of images for dragging</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.ImgList.TCustomImageList.Initialize">TCustomImageList.Initialize</link>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.BeginDrag">
        <short>
          <var>BeginDrag</var> - start the drag process; returns True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragImageList.BeginDrag.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.BeginDrag.Window">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.BeginDrag.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.BeginDrag.Y">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.DragLock">
        <short>
          <var>DragLock</var> - returns True if dragging has been locked for the specifies window at given location</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragImageList.DragLock.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.DragLock.Window">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.DragLock.XPos">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.DragLock.YPos">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.DragMove">
        <short>
          <var>DragMove</var> - move dragged images to specified location and return True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragImageList.DragMove.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.DragMove.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.DragMove.Y">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragImageList.DragUnlock">
        <short>
          <var>DragUnlock</var> - unlock the list of images for dragging</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.EndDrag">
        <short>
          <var>EndDrag</var> - retuns True if the drag process has ended</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragImageList.EndDrag.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element link="#LCL.ImgList.TCustomImageList.GetHotSpot" name="TDragImageList.GetHotSpot">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragImageList.GetHotSpot.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragImageList.HideDragImage">
        <short>
          <var>HideDragImage</var> - method for making dragged image invisible</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragImageList.SetDragImage">
        <short>
          <var>SetDragImage</var> - place the indexed drag image at the specified location, returning True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragImageList.SetDragImage.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.SetDragImage.Index">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.SetDragImage.HotSpotX">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragImageList.SetDragImage.HotSpotY">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragImageList.ShowDragImage">
        <short>
          <var>ShowDragImage</var> - display the dragged image</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragImageList.DragCursor">
        <short>
          <var>DragCursor</var> - the cursor for use during the dragging process</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragImageList.DragHotspot">
        <short>
          <var>DragHotspot</var> - the position of the HotSpot (usually the pointer of the cursor)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragImageList.Dragging">
        <short>
          <var>Dragging</var> - True if dragging is proceeding</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetDockCaptionEvent">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGetDockCaptionEvent.Sender">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGetDockCaptionEvent.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGetDockCaptionEvent.ACaption">
        <short/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FAlwaysShowDragImages">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragObject.FControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDragObject.Create">
        <short>
          <var>Create</var> - constructor fro 
          <var>TDragObject</var>: copies 
          <var>AControl</var> to local variable</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragObject.Create.AControl">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.AlwaysShowDragImages">
        <short>Should the image of dragged objects always be shown?</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragObject.Control">
        <short>The control that is to be dragged</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TDockOrientation.doPages">
        <short/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FEraseDockRect">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragDockObject.FIncreaseDockArea">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.IncreaseDockArea">
        <short>
          <var>IncreaseDockArea</var> - determine whether the area for docking is allowed to be enlarged</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragDockObject.EraseDockRect">
        <short>
          <var>EraseDockRect</var> - remove the rectangle that was used for docking</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TDragManager">
        <short>
          <var>TDragManager</var> - a class for managing the dragging of controls (eventually to be dropped or docked)</short>
        <descr>
          <p>The declaration contains a number of procedure definitions that are 'virtual' and 'abstract'. This means that there is no implementation specified: these essentially represent 'place-holders',  and it is the responsibility of the developer of descendant classes to override these methods and implement them as desired.</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragManager.FDragImmediate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDragManager.FDragThreshold">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.KeyUp">
        <short>
          <var>KeyUp</var> - method for processing a key that is not pressed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.KeyUp.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.KeyUp.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.KeyDown">
        <short>
          <var>KeyDown</var> - method for handling a key that is pressed down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.KeyDown.Key">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.KeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.CaptureChanged">
        <short>
          <var>CaptureChanged</var> - method for use when the identity of the captured control has changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.CaptureChanged.OldCaptureControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.MouseMove">
        <short>
          <var>MouseMove</var> - method for processing a mouse movement</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.MouseMove.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.MouseMove.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.MouseMove.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.MouseUp">
        <short>
          <var>MouseUp</var> - method for processing a mouse button that is not pressed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.MouseUp.Button">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.MouseUp.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.MouseUp.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.MouseUp.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDragManager.MouseDown">
        <short>
          <var>MouseDown</var> - method for processing a mouse button that is pressed down</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.MouseDown.Button">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.MouseDown.Shift">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.MouseDown.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.MouseDown.Y">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TDragManager.Create">
        <short>
          <var>Create</var> - constructor for 
          <var>TDragManager</var>: calls inherited 
          <var>Create</var> and sets default drag threshold; sets 
          <var>DragImmediate</var> True</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TComponent.Create">TComponent.Create</link>
        </seealso>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.Create.TheOwner">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragManager.IsDragging">
        <short>
          <var>IsDragging</var> - returns True if dragging is in progress</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragManager.IsDragging.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDragManager.Dragging">
        <short>
          <var>Dragging</var> - returns True if the specified control is being dragged</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDragManager.Dragging.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.Dragging.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.RegisterDockSite">
        <short>
          <var>RegisterDockSite</var> - adds the nominated site to the list or register of docking sites</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.RegisterDockSite.Site">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.RegisterDockSite.DoRegister">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.DragStart">
        <short>
          <var>DragStart</var> - begin the drag</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.DragStart.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.DragStart.AImmediate">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.DragStart.AThreshold">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.DragMove">
        <short>
          <var>DragMove</var> - method for dragging to specified position (virtual method - needs to be supplied by user)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.DragMove.APosition">
        <short>DragStart</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDragManager.DragStop">
        <short>
          <var>DragStop</var> - finish the drag</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDragManager.DragStop.ADrop">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragManager.DragImmediate">
        <short>Is the dragging process to start immediately the control receives focus (eg gets captured by mouse)?</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDragManager.DragThreshold">
        <short>The threshold amount by which the mouse must move before the dragging process starts.</short>
        <descr>The threshold amount by which the mouse must move before the dragging process starts. Default is 5 pixels - irrelevant if <link id="#lcl.Controls.TDragManager.DragImmediate"/> is true
</descr>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="DragManager">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlCellAlign">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaFill">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaLeftTop">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaRightBottom">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlCellAlign.ccaCenter">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlCellAligns">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlBorderSpacing.FCellAlignHorizontal">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlBorderSpacing.FCellAlignVertical">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlBorderSpacing.FInnerBorder">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControlBorderSpacing.IsInnerBorderStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlBorderSpacing.IsInnerBorderStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetCellAlignHorizontal">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.SetCellAlignHorizontal.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetCellAlignVertical">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.SetCellAlignVertical.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlBorderSpacing.SetInnerBorder">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.SetInnerBorder.AValue">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.Change.InnerSpaceChanged">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlBorderSpacing.GetSideSpace">
        <short>
          <var>GetSideSpace</var> - finds th espace requied at the side for the specified anchor kind</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControlBorderSpacing.GetSideSpace.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlBorderSpacing.GetSideSpace.Kind">
        <short/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.InnerBorder">
        <short>The size of the inner border around the control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.CellAlignHorizontal">
        <short>
          <var>CellAlignHorizontal</var>  - the sort of horizontal alignment to use if a cell is being aligned</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlBorderSpacing.CellAlignVertical">
        <short>
          <var>CellAlignVertical</var>  - the sort of vertical alignment to use if a cell is being aligned</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAnchorSideChangeOperation">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideChangeOperation.ascoAdd">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideChangeOperation.ascoRemove">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TAnchorSideChangeOperation.ascoChangeSide">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TAnchorSide.Destroy">
        <short>
          <var>Destroy</var> - destructor for 
          <var>TAnchorSide</var>: removes all anchoring links then calls inherited 
          <var>Destroy</var>
        </short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Destroy">TPersistent.Destroy</link>
        </seealso>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfAutoSizeNeeded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfLeftLoaded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfTopLoaded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfWidthLoaded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfHeightLoaded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfBaseBoundsValid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfPreferredMinSizeValid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfOnResizeNeeded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlFlag.cfOnChangeBoundsNeeded">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlHandlerType.chtOnVisibleChanging">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlHandlerType.chtOnVisibleChanged">
        <short/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.fAnchoredControls">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FAutoSizing">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FAutoSizingLockCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FCaptureMouseButtons">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.fLastAlignedBoundsTried">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FLastDoChangeClientSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FPreferredMinWidth">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FPreferredMinHeight">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FReadBounds">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.CaptureMouseButtonsIsStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.CaptureMouseButtonsIsStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.GetAnchoredControls">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetAnchoredControls.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetAnchoredControls.Index">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetParentFont">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetParentFont.Value">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetCursor">
        <short>Function to find position of the cursor</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetCursor.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.BeginAutoSizing">
        <short>Procedure for the beginning of the autosizing process</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.EndAutoSizing">
        <short>Procedure for the end of the autosizing process</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ForeignAnchorSideChanged">
        <short>Procedure invoked when the anchor side of a different control (not the current) is changed</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ForeignAnchorSideChanged.TheAnchorSide">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ForeignAnchorSideChanged.Operation">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoBorderSpacingChange.InnerSpaceChanged">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.IsBorderSpacingInnerBorderStored">
        <short>Function to find if details of border spacing are stored</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsBorderSpacingInnerBorderStored.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CalculatePreferredSize.WithThemeSpace">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CheckOnChangeBounds">
        <short>Checks for changes and calls <var>DoOnChangeBounds</var>
        </short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.IsAParentAligning">
        <short>Determine if a parent control is involved in the alignment process</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsAParentAligning.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetLogicalClientRect">
        <short>Logical size of client area (e.g. in a <var>TScrollBox</var> the logical client area can be bigger than the visual)</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetLogicalClientRect.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.IsClientHeightStored">
        <short>Is Client Height Stored?</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsClientHeightStored.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.IsClientWidthStored">
        <short>Is Client Width Stored?</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsClientWidthStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.WMContextMenu">
        <short>Protected messages to system - when context menu is required</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WMContextMenu.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.CMTextChanged">
        <short>Control Message for a change in the control's text</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CMTextChanged.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDragImages">
        <short>Get the list of Images to be dragged - returned as a list</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetDragImages.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoFloatMsg">
        <short>Sends a message to the operating system about the floating status of ADockSource</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoFloatMsg.ADockSource">
        <short/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.DoDragMsg.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoDragMsg.ADragMessage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoDragMsg.APosition">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoDragMsg.ADragObject">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoDragMsg.ATarget">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoDragMsg.ADocking">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetDefaultDockCaption">
        <short>
          <var>GetDefaultDockCaption</var> - returns the default string for dock caption</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetDefaultDockCaption.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.UpdateMouseCursor">
        <short>
          <var>UpdateMouseCursor</var> - ensure co-ordinates 
          
          <var>X, Y </var> for the cursor are correctly stored</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.UpdateMouseCursor.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.UpdateMouseCursor.Y">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.FormEndUpdated">
        <short>
          <var>FormEndUpdated</var> - the update for the Form has ended</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.ParentFontChanged">
        <short>
          <var>ParentFontChanged</var> - method for dealing with a change in the font of the parent</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.TextChanged">
        <short>Procedure to deal with changes in text</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControl.GetCachedText">
        <short>
          <var>GetCachedText</var> - method for retrieving caption text from cache; returns True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetCachedText.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetCachedText.CachedText">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.VisibleChanged">
        <short>
          <var>VisibleChanged</var> - method to use when the 
          <var>Visible</var> property has changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControl.DoCallNotifyHandler">
        <short>
          <var>DoCallNotifyHandler</var> - calls a Notify Handler of the specified type</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.DoCallNotifyHandler.HandlerType">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ManualDock.KeepDockSiteSize">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ManualFloat.KeepDockSiteSize">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.NeedParentForAutoSize">
        <short>
          <var>NeedParentForAutoSize</var>:  True - need to know parent's properties to do autosize. False - can autosize independently</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.NeedParentForAutoSize.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorToCompanion">
        <short>
          <var>AnchorToCompanion</var> - anchor to another control, not necessarily an immediate neighbour</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorToCompanion.Side">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorToCompanion.Space">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorToCompanion.Sibling">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorToCompanion.FreeCompositeSide">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorSame">
        <short>Anchor on the same side as a sibling</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorSame.Side">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorSame.Sibling">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorAsAlign">
        <short>
          <var>AnchorAsAlign</var> - Anchor following same rules as Align</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorAsAlign.TheAlign">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorAsAlign.Space">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AnchorClient">
        <short>Anchor to the client space</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchorClient.Space">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.AnchoredControlCount">
        <short>The number of controls anchored to this one</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.AnchoredControlCount.Result">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.AnchoredControls">
        <short>The indexed list of controls anchored to this one</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AnchoredControls.Index">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetPreferredSize.WithThemeSpace">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetDefaultWidth">
        <short>Find default width (by reference to ancestor)</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetDefaultWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetDefaultHeight">
        <short>Find the default height (by reference to ancestor)</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetDefaultHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetControlClassDefaultSize">
        <short>Find the default size for this class of controls (by reference to parents)</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetControlClassDefaultSize.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetSidePosition">
        <short>Find which side is being used for anchoring</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetSidePosition.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetSidePosition.Side">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.CNPreferredSizeChanged">
        <short>
          <var>CNPreferredSizeChanged</var> - issue control signal to show that preferrd size has changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetAnchorsDependingOnParent">
        <short>Find out the required anchor settings by reference to the parents</short>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetAnchorsDependingOnParent.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.GetAnchorsDependingOnParent.WithNormalAnchors">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.DisableAutoSizing">
        <short>Turn off automatic sizing - implies that default is accepted or sizing is done manually</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.EnableAutoSizing">
        <short>Turns on (enables) automatic sizing</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.BaseBounds">
        <short>The rectangle defining the base bounds for this control</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.ReadBounds">
        <short>
          <var>ReadBounds</var> - find out what bounds have been defined</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.WriteLayoutDebugReport">
        <short>Used for debugging</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.WriteLayoutDebugReport.Prefix">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.GetTopParent">
        <short>Find which control is the top parent (ie ultimate ancestor)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.GetTopParent.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsControlVisible">
        <short>Is the control visible on the current desktop?</short>
        <descr>
          <p>Is the control visible on the current desktop?</p>
          <p>Does not check parents</p>
        </descr>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsControlVisible.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.FormIsUpdating">
        <short>True if the form is being updated</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.FormIsUpdating.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ActiveDefaultControlChanged">
        <short>The active default control has changed to <var>NewControl</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.ActiveDefaultControlChanged.NewControl">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.ParentDestroyingHandle">
        <short>
          <var>ParentDestroyingHandle</var> - returns True if the parent control is destroying the Handle</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.ParentDestroyingHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.ShowHelp">
        <short>Procedure for displaying the Help associated with this control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.HasHelp">
        <short>Indicates that this control has an entry in the Help-file</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.HasHelp.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnVisibleChanging">
        <short>
          <var>AddHandlerOnVisibleChanging</var> - method for adding a handler for the 
          <var>OnVisibleChanging</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AddHandlerOnVisibleChanging.OnVisibleChangingEvent">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AddHandlerOnVisibleChanging.AsLast">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnVisibleChanging">
        <short>
          <var>RemoveHandlerOnVisibleChanging</var> - method to remove a handler for the 
          <var>OnVisibleChanging</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.RemoveHandlerOnVisibleChanging.OnVisibleChangingEvent">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.AddHandlerOnVisibleChanged">
        <short>
          <var>AddHandlerOnVisibleChanged</var> - method for adding a handler for the 
          <var>OnVisibleChanged</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AddHandlerOnVisibleChanged.OnVisibleChangedEvent">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.AddHandlerOnVisibleChanged.AsLast">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControl.RemoveHandlerOnVisibleChanged">
        <short>
          <var>RemoveHandlerOnVisibleChanged</var> - method to remove handler for the 
          <var>OnVisibleChanged</var> event</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.RemoveHandlerOnVisibleChanged.OnVisibleChangedEvent">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControl.CaptureMouseButtons">
        <short>Which mouse button(s) to be used for capture? Default left button, but may be a set of up to three</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FBiDiMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControl.FParentBiDiMode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TControl.IsBiDiModeStored">
        <short>Is the BiDi mode stored?</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsBiDiModeStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetBiDiMode">
        <short>
          <var>SetBiDiMode</var> - specifies the BiDi mode</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetBiDiMode.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.SetParentBiDiMode">
        <short>
          <var>SetParentBiDiMode</var> - specifies the BiDi mode for the parent control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.SetParentBiDiMode.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.CMBiDiModeChanged">
        <short>
          <var>CMBiDiModeChanged</var> - issues control message when BiDi mode is changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CMBiDiModeChanged.Message">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControl.CMParentBiDiModeChanged">
        <short>
          <var>CMParentBiDiModeChanged</var> - issues a control message when the parent control's BiDi mode is changed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControl.CMParentBiDiModeChanged.Message">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.UseRightToLeftAlignment">
        <short>
          <var>UseRightToLeftAlignment</var> - as opposed to usual left to right</short>
        <descr>Needs <var>BiDiMode</var> enabled
</descr>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.UseRightToLeftAlignment.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.UseRightToLeftReading">
        <short>
          <var>UseRightToLeftReading </var>- as opposed to usual left to right</short>
        <descr>Needs <var>BiDiMode</var> enabled</descr>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.UseRightToLeftReading.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.UseRightToLeftScrollBar">
        <short>
          <var>UseRightToLeftScrollBar</var> - as opposed to usual left to right</short>
        <descr>Needs <var>BiDiMode</var> enabled</descr>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.UseRightToLeftScrollBar.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControl.IsRightToLeft">
        <short>
          <var>IsRightToLeft</var> - as opposed to usual left to right</short>
        <descr>Needs <var>BiDiMode</var> enabled</descr>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TControl.IsRightToLeft.Result">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TChildControlResizeStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlResizeStyle.crsAnchorAligning">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlResizeStyle.crsScaleChilds">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlResizeStyle.crsHomogenousChildResize">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TChildControlResizeStyle.crsHomogenousSpaceResize">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlChildrenLayout">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlChildrenLayout.cclNone">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlChildrenLayout.cclLeftToRightThenTopToBottom">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlChildrenLayout.cclTopToBottomThenLeftToRight">
        <short/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FControlsPerLine">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlChildSizing.FLayout">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetControlsPerLine">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.SetControlsPerLine.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TControlChildSizing.SetLayout">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.SetLayout.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlChildSizing.SetGridSpacing">
        <short>
          <var>SetGridSpacing</var> - specifies a value for spacing on the grid (for drawing etc)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TControlChildSizing.SetGridSpacing.Spacing">
        <short/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.Layout">
        <short>
          <var>Layout</var> - L-R then Top-Bottom, or Top-Bottom then L-R (or none)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlChildSizing.ControlsPerLine">
        <short>
          <var>ControlsPerLine</var> - number of controls per line</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWinControlFlag.wcfHandleVisible">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TControlAtPosFlag">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfAllowDisabled">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfAllowWinControls">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfOnlyClientAreas">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfRecursive">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TControlAtPosFlag.capfHasScrollOffset">
        <short/>
      </element>
      <!-- set type Visibility: default -->
      <element name="TControlAtPosFlags">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TWinControl.FOnGetDockCaption">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TWinControl.AlignNonAlignedControls">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.AlignNonAlignedControls.ListOfControls">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.AlignNonAlignedControls.BoundsModified">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="#LCL.Controls.TControl.IsClientHeightStored" name="TWinControl.IsClientHeightStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.IsClientHeightStored.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element link="#LCL.Controls.TControl.IsClientWidthStored" name="TWinControl.IsClientWidthStored">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.IsClientWidthStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CreateControlAlignList">
        <short>
          <var>CreateControlAlignList</var> - creates a list of the controls that are aligned with the present window control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CreateControlAlignList.TheAlign">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CreateControlAlignList.AlignList">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CreateControlAlignList.StartControl">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.ResizeDelayedAutoSizeChildren">
        <short>
          <var>ResizeDelayedAutoSizeChildren</var> - method for re-sizing children, using autosize delayed</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoDragMsg.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDragMsg.ADragMessage">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDragMsg.APosition">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDragMsg.ADragObject">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDragMsg.ATarget">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDragMsg.ADocking">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoDockClientMsg">
        <short>
          <var>DoDockClientMsg</var> - issues a Dock Client message for a specified 
          <var>DragDropOject</var> at a given position; returns True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoDockClientMsg.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDockClientMsg.DragDockObject">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoDockClientMsg.Position">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.DoUndockClientMsg">
        <short>
          <var>DoUndockClientMsg</var> - issues a message to undock a client control; returns True if successful</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.DoUndockClientMsg.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoUndockClientMsg.NewTarget">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoUndockClientMsg.Client">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoSendShowHideToInterface">
        <descr/>
        <errors/>
        <seealso/>
        <short>
          <var>DoSendShowHideToInterface</var> - send the Show/Hide status to the interface</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.RealizeBoundsRecursive">
        <short>
          <var>RealizeBoundsRecursive</var> - perform 
          <var>RealizeBounds</var> in a recursive manner</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CalculatePreferredSize.WithThemeSpace">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.CMBiDiModeChanged">
        <short>
          <var>CMBiDiModeChanged</var> - control message for a change in the 
          <var>BiDiMode</var> property</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.CMBiDiModeChanged.Message">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoUnDock.KeepDockSiteSize">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.DoFloatMsg" name="TWinControl.DoFloatMsg">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoFloatMsg.ADockSource">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.DoGetDockCaption">
        <short>
          <var>DoGetDockCaption</var> - find the caption for the docked control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoGetDockCaption.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DoGetDockCaption.ACaption">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TWinControl.SendDialogChar">
        <short>
          <var>SendDialogChar</var> - LCL key message: returns True if a dialog character has been sent</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.SendDialogChar.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SendDialogChar.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SelectFirst">
        <short>
          <var>SelectFirst</var> - select the first control on the list</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.FinalizeWnd">
        <short>
          <var>FinalizeWnd</var> -  getting ready to remove window (gets called before the Handle is destroyed)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.FormEndUpdated">
        <short>
          <var>FormEndUpdated</var> - calls inherited 
          <var>FormEndUpdated</var> then informs each child control</short>
        <descr/>
        <errors/>
        <seealso>
          <link id="#LCL.Controls.TControl.FormEndUpdated">TControl.FormEndUpdated</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.SetChildZPosition">
        <short>
          <var>SetChildZPosition</var> - specify the position of the child control in the Z plane (ie front-to-back)</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetChildZPosition.AChild">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetChildZPosition.APosition">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TWinControl.WSSetText">
        <short>
          <var>WSSetText</var> - writes the name of the current widget set to a local variable</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WSSetText.AText">
        <short/>
      </element>
      <!-- property Visibility: protected -->
      <element name="TWinControl.OnGetDockCaption">
        <short>
          <var>OnGetDockCaption</var> - event handler to find the caption for the docked control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.ControlAtPos.Flags">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TControl.WriteLayoutDebugReport" name="TWinControl.WriteLayoutDebugReport">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.WriteLayoutDebugReport.Prefix">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.DockDrop.DragDockObject">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TControl.SetTempCursor" name="TWinControl.SetTempCursor">
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetTempCursor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.AddControl">
        <short>
          <var>AddControl</var> - add this control to the list of controls</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TWinControl.GetDockCaption">
        <short>
          <var>GetDockCaption</var> - get the caption for the specified docked control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TWinControl.GetDockCaption.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.GetDockCaption.AControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.IntfUTF8KeyPress.SystemKey">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.PaintTo">
        <short>
          <var>PaintTo</var> - Paint to a specified position on the canvas</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.PaintTo.DC">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.PaintTo.X">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.PaintTo.Y">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.PaintTo.ACanvas">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TWinControl.SetShape">
        <short>
          <var>SetShape</var> - make the specified shape appear on the Window</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TWinControl.SetShape.AShape">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.FontChanged" name="TGraphicControl.FontChanged">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TGraphicControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.DoOnChangeBounds" name="TGraphicControl.DoOnChangeBounds">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.FontChanged" name="TCustomControl.FontChanged">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomControl.FontChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element link="#LCL.Controls.TControl.SetColor" name="TCustomControl.SetColor">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TCustomControl.SetColor.Value">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element link="#LCL.Controls.TWinControl.DestroyWnd" name="TCustomControl.DestroyWnd">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TImageList.AllocBy">
        <short>
          <var>AllocBy</var> - for allocation</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TImageList.BlendColor">
        <short>
          <var>BlendColor</var> - the colour for blending</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element link="#LCL.ImgList.TCustomImageList.DrawingStyle" name="TImageList.DrawingStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element link="#LCL.ImgList.TCustomImageList.ImageType" name="TImageList.ImageType">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element link="#LCL.ImgList.TCustomImageList.ShareImages" name="TImageList.ShareImages">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockZone.Create.TheChildControl">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.FindZone">
        <short>
          <var>FindZone</var> - returns the Dockzone for the nominated control</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.FindZone.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockZone.FindZone.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.AddAsFirstChild">
        <short>
          <var>AddAsFirstChild</var> - add a new zone as the first child</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockZone.AddAsFirstChild.NewChildZone">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.AddAsLastChild">
        <short>
          <var>AddAsLastChild</var> - add an new zone as the last child</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockZone.AddAsLastChild.NewChildZone">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.ReplaceChild">
        <short>
          <var>ReplaceChild</var> - replace the 
          <var>OldChild</var> zone with the 
          <var>NewChild</var>
        </short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockZone.ReplaceChild.OldChild">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockZone.ReplaceChild.NewChild">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.GetLastChild">
        <short>
          <var>GetLastChild</var> - returns the last child zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetLastChild.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TDockZone.GetIndex">
        <short>
          <var>GetIndex</var> - returns the index of the current zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TDockZone.GetIndex.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TDockZone.Remove">
        <short>
          <var>Remove</var> the nominated child zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockZone.Remove.ChildZone">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.ChildControl">
        <short>The child control to be docked here</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.FirstChild">
        <short>The first child control in the list of controls for docking</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Orientation">
        <short>Whether docking is oriented vertically, horizontally, in pages, or not at all</short>
        <descr>
          <p>doNoOrient   : zone contains a TControl and no child zones.</p>
          <p>doHorizontal : zone's children are stacked top-to-bottom.</p>
          <p>doVertical     : zone's children are arranged left-to-right.</p>
          <p>doPages       : zone's children are pages arranged left-to-right.</p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.Parent">
        <short>The parent dock zone to which this control is docked</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.NextSibling">
        <short>The next sibling (related control atthe same level) in the list of docked controls</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockZone.PrevSibling">
        <short>The previous sibling (control at the same level) in the list of docked controls</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TDockTree.FRootZone">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TDockTree.SetDockSite">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.SetDockSite.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TDockTree.SetDockZoneClass">
        <short>
          <var>SetDockZoneClass</var> - specifies the class of dock zone</short>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TDockTree.SetDockZoneClass.AValue">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TDockTree.RootZone">
        <short>
          <var>RootZone</var> - the zone that forms the root of the current Dock Tree</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="DockSplitterClass">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TMouse.FWheelScrollLines">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TMouse.SetCursorPos">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouse.SetCursorPos.AValue">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMouse.GetWheelScrollLines">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TMouse.GetWheelScrollLines.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMouse.GetDragImmediate">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TMouse.GetDragImmediate.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TMouse.SetDragImmediate">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouse.SetDragImmediate.AValue">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMouse.GetDragThreshold">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TMouse.GetDragThreshold.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TMouse.SetDragThreshold">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="TMouse.SetDragThreshold.AValue">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TMouse.WheelScrollLines">
        <short>
          <var>WheelScrollLines</var> - the number of lines the the scroll wheel has traversed</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="MainAlignAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="OppositeAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="ClockwiseAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="AnchorNames">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- argument Visibility: default -->
      <element name="SetCaptureControl.AWinControl">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="SetCaptureControl.Position">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="AdjustBorderSpace.Space">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="DbgS">
        <short/>
        <descr/>
        <errors/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="DbgS.Result">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="DbgS.a">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="DbgS.Anchors">
        <short/>
      </element>
      <!-- argument Visibility: default -->
      <element name="DbgS.Side">
        <short/>
      </element>
      <element name="TControl.AnchAnchor">
        <short>Anchor to the bottom</short>
      </element>
      <element name="TDockZone.Height">
        <short>The height of this control</short>
      </element>
      <element name="TControl.OnMouseWheel">
        <short>
          <var>OnMouseWheel</var> - event handler for a movement of the mouse wheel</short>
      </element>
      <element name="TControl.OnMouseWheelDown">
        <short>
          <var>OnMouseWheelDown</var> - event handler for downward movement of mouse wheel</short>
      </element>
      <element name="TControl.OnMouseWheelUp">
        <short>
          <var>OnMouseWheelUp</var> - event handler for upward movement of mouse wheel</short>
      </element>
      <element name="TWinControl.InvalidatePreferredChildSizes">
        <short>
          <var>InvalidatePreferredChildSizes</var> - renders the preferred child sizes invalid</short>
      </element>
      <element name="TDragObject.AutoCreated">
        <short>
          <var>AutoCreated</var> - if True, the drag object is automatically created</short>
      </element>
      <element name="TDragObject.EndDrag">
        <short>
          <var>EndDrag</var> - method for terminating drag of nominated object at specified location</short>
      </element>
      <element name="TDragDockObject.DockOffset">
        <short>
          <var>AdjustDockRect</var> - the position for offsetting the dock point</short>
      </element>
      <element name="TDockManager.MouseMessage">
        <short>
          <var>MouseMessage</var> - message sent to system for mouse events</short>
      </element>
      <element name="TDockManager.AutoFreeByControl">
        <short>
          <var>AutoFreeByControl</var> - returns True if an object has been automatically freed by a control</short>
      </element>
      <element name="TControl.WMMouseWheel">
        <short>Protected message to system - when mouse wheel moves</short>
      </element>
      <element name="TControl.DoMouseWheel">
        <short>
          <var>DoMouseWheel</var> - performs the action to deal with a movement of the mouse wheel; returns True if handled</short>
      </element>
      <element name="TControl.DoMouseWheelDown">
        <short>
          <var>DoMouseWheelDown</var> - performs the action for a downward movement of the mouse wheel; returns True if handled</short>
      </element>
      <element name="TControl.DoMouseWheelUp">
        <short>
          <var>DoMouseWheelUp</var> - performs the action for an upward movement of the mouse wheel; returns True if handled</short>
      </element>
      <element link="#LCL.Controls.TDockManager.MouseMessage" name="TDockTree.MouseMessage"/>
      <element name="TControl.CreateControlBorderSpacing">
        <short>
          <var>CreateControlBorderSpacing</var> - calls 
          <var>TControlBorderSpacing.Create</var> to create the border spacing for this control</short>
        <seealso>
          <link id="TControlBorderSpacing.Create">TControlBorderSpacing.Create</link>
        </seealso>
      </element>
      <element name="TControl.WMCancelMode">
        <short>Protected message to system for CancelMode</short>
      </element>
      <element name="TControl.CMWantSpecialKey">
        <short>Control Message when a special key is needed</short>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore">
        <short>
          <var>CustomAlignInsertBefore</var> - returns True if the 
          <var>OnAlignInsertBefore</var> event handler has been assigned and executes successfully</short>
      </element>
      <element name="TWinControl.CustomAlignPosition">
        <short>
          <var>CustomAlignPosition</var> calls the 
          <var>OnAlignPosition</var> event handler to make a highly specified alignment</short>
      </element>
      <element name="TWinControl.CMBorderChanged">
        <short>
          <var>CMBorderChanged</var> - ControlMessage for a change in the 
          <var>Border</var> property</short>
      </element>
      <element name="TWinControl.OnAlignInsertBefore">
        <short>
          <var>OnAlignInsertBefore</var> - event handler for an aligned insertion before action</short>
      </element>
      <element name="TWinControl.OnAlignPosition">
        <short>
          <var>OnAlignPosition</var> - event handler for supplying align position</short>
      </element>
      <element name="TDockZone.AddSibling">
        <short>
          <var>AddSibling</var> - insers a new sibling control into the dock zone</short>
      </element>
      <element name="TDockTree.DumpLayout">
        <short>
          <var>DumpLayout</var> - stores layout in a file</short>
      </element>
      <element name="TDockZone.SetLimitBegin">
        <short>
          <var>SetLimitBegin</var> - specifies the limit for the beginning of the zone</short>
      </element>
      <element name="TDockZone.SetLimitSize">
        <short>
          <var>SetLimitSize</var> - specifies the limit for the size of the zone</short>
      </element>
      <element name="TDockZone.SetHeight">
        <short>
          <var>SetHeight</var> - specifies the height of the zone</short>
      </element>
      <element name="TDockZone.SetLeft">
        <short>
          <var>SetLeft</var> - specifies the left side of the zone</short>
      </element>
      <element name="TDockZone.SetTop">
        <short>
          <var>SetTop</var> - specifies the top of the zone</short>
      </element>
      <element name="TDockZone.SetWidth">
        <short>
          <var>SetWidth</var> - specifies the width of the zone</short>
      </element>
      <element link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass" name="TWinControl.WSRegisterClass"/>
      <element link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass" name="TControl.WSRegisterClass"/>
      <element link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass" name="TGraphicControl.WSRegisterClass"/>
      <element link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass" name="TCustomControl.WSRegisterClass"/>
      <topic name="AutoSize">
        <short>
          <var>AutoSize</var> - boolean property that permits the size of a control to be adjusted automatically</short>
        <descr>
          <p>
            <var>AutoSize</var> is a boolean property found in many classes; it permits the size of a control to be adjusted automatically to accommodate differences in the text or graphic contained therein, and allows most efficient use of available space</p>
          <p>Many controls call  <link id="#lcl.Controls.TControl.DoAutoSize">TControl.DoAutoSize</link> to perform the actual auto-sizing. </p>
          <p>IMPORTANT: Many Delphi controls override this method and many call this method directly after setting some properties.</p>
          <p>During handle creation not all interfaces can create complete Device Contexts which are needed to calculate things like text size.</p>
          <p>That's why you should always call <link id="#lcl.Controls.TControl.AdjustSize">AdjustSize</link> instead of <var>DoAutoSize</var>.</p>
          <p>
            <var>TControl.AdjustSize</var> calls <var>DoAutoSize</var> in a smart fashion.</p>
          <p>During loading and handle creation the calls are delayed.</p>
          <p>This method initially does the same as <link id="#lcl.Controls.TWinControl.DoAutoSize">TWinControl.DoAutoSize</link>.  But since <var>DoAutoSize</var> is commonly overriden by descendant components,  it is not useful to perform all tests, which can result in too much overhead. To reduce this the LCL calls <var>AdjustSize</var> instead.</p>
          <p>When setting <var>AutoSize</var> = true the LCL autosizes the control in width and height. This is one of the most complex parts of the LCL, because the result depends on nearly a hundred properties. Let's start simple:</p>
          <p>The LCL will only autosize the Width or Height if it is free to resize. In other words - the width is not autosized if:</p>
          <ul>
            <li>the left and right side is anchored. You can anchor the sides with the <var>Anchors</var> property or by setting the <var>Align</var> property to <var>alTop</var>, <var>alBottom</var> or <var>alClient</var>
            </li>
            <li>the Width and Height are bound by the <var>Constraints</var> properties. The Contraints can also be overriden by the widgetset. For example the winapi does not allow resizing the height of a combobox. And the gtk widgetset does not allow resizing the width of a vertical scrollbar</li>
          </ul>
          <p>The new size is calculated by the protected method <link id="#lcl.Controls.TControl.CalculatePreferredSize">TControl.CalculatePreferredSize</link>.
			      This method asks the widgetset for an appropriate Width and Height. For example a <var>TButton</var> has preferred Width and Height. A <var>TComboBox</var> has only a preferred Height. The preferred Width is returned as 0 and so the LCL does not autosize the Width - it keeps the width unaltered. Finally a <var>TMemo</var> has no preferred Width or Height. Therefore AutoSize has no effect on a TMemo.</p>
          <p>Some controls override this method. For example the <var>TGraphicControl</var> descendants like <var>TLabel</var> have no window handle and so cannot query the widgetset. They must calculate their preferred Width and Height themselves.</p>
          <p>The widgetsets must override the <var>GetPreferredSize</var> method for each widget class that has a preferred size (Width or Height or both).</p>
          <p>
            <b>Parent.AutoSize</b>
          </p>
          <p>The above described the simple explanation. The real algorithm provides far more possibilities and is therefore far more complex.</p>
          <p>
            <b>Properties / Methods</b>
          </p>
          <ul>
            <li>Left</li>
            <li>Top</li>
          </ul>
          <p>If <var>Parent</var> is not nil then <var>Left, Top</var> are the pixel distance to the top, left pixel of the parent's client area (not scrolled). Remember the client area is always without the frame and scrollbars of the parent. For Delphi users: Some VCL controls like TGroupbox define the client area as the whole control including the frame and some not - the LCL is more consistent, and therefore Delphi incompatible. Left and Top can be negative or bigger than the client area. Some widgetsets define a minimum/maximum somewhere around 10.000 or more.</p>
          <p>When the client area is scrolled the Left and Top are kept unchanged. </p>
          <p>During resizing/moving Left and Top are not always in sync with the coordinates of the Handle object.</p>
          <p>If Parent=nil then Left, Top depend on the widgetset and the window manager. Till Lazarus 0.9.25 this is typically the screen coordinate of the left,top of the client area of the form. This is Delphi incompatible. It is planned to change this to the Left, Top of the window.</p>
          <p>Hint:</p>
          <p>Each time you change Left and Top the LCL moves instantly. If you want to change both Left and Top use instead:</p>
          <code>with Button1 do
	      SetBounds(NewLeft,NewTop,Width,Height);</code>
          <ul>
            <li>Width</li>
            <li>Height</li>
          </ul>
          <p>The Size in pixels must not be negative, and most widgetsets do not allow Width=0 and/or Height=0. Some controls on some platforms define a bigger minimum constraint. Instead of sizing a control to Width=0 and/or Height=0, set Visible=false. During resizing/moving Width and Height are not always in sync with the size of the Handle object.</p>
          <ul>
            <li>BoundsRect</li>
          </ul>
          <p>Same as Bounds(Left,Top,Width,Height).</p>
          <p>Common newbie mistake:</p>
          <code>BoundsRect.Left:=3; // WRONG: common newbie mistake
</code>
          <p>This has no effect, because reading BoundsRect is a function. It creates a temporary TRect on the stack.</p>
          <ul>
            <li>ClientRect</li>
          </ul>
          <p>Left and Top are always 0,0. Width and Height are the visible size in pixels of the client area. Remember the client area is without the frame and without scrollbars. In a scrollable client area the logical client area can be bigger than the visible.</p>
          <ul>
            <li>ClientOrigin</li>
          </ul>
          <p>Returns the screen coordinate of the top left coordinate 0,0 of the client area. Note that this value is the position as stored in the interface and is not always in sync with the LCL. When a control is moved, the LCL sets the bounds to the desired position and sends a move message to the interface. It is up to the interface to handle moves instantly or queued.</p>
          <ul>
            <li>LCLIntf.GetClientBounds</li>
          </ul>
          <p>Returns the client bounds of a control. Like ClientRect, but Left and Top are the pixel distances to the control's left, top. For example on a TGroupBox the Left, Top are the width and height of the left and top frame border. Scrolling has no effect on GetClientBounds.</p>
          <ul>
            <li>LCLIntf.GetWindowRect</li>
          </ul>
          <p>After the call, ARect will be the control area in screen coordinates. That means, Left and Top will be the screen coordinate of the TopLeft pixel of the Handle object and Right and Bottom will be the screen coordinate of the BottomRight pixel.</p>
          <ul>
            <li>FBaseBoundsLock: integer</li>
          </ul>
          <p>Increased/Decreased by LockBaseBounds/UnlockBaseBounds.
		      Used to keep FBaseBounds during SetBounds calls.</p>
          <ul>
            <li>FBaseParentClientSize: TPoint</li>
          </ul>
          <p>The Parent.ClientRect size valid for the FBaseBounds.
		      FBaseBounds and FBaseParentClientSize are used to calculate the distance for
		      akRight (akBottom).
		      When the parent is resized, the LCL knows what distance to keep.</p>
          <ul>
            <li>FBoundsRectForNewParent: TRect</li>
          </ul>
          <p>When changing the Parent of a control the Handle is recreated and many
		      things can happen. Especially for docking forms the process is too
		      unreliable. Therefore the BoundsRect is saved. The VCL uses a similar
		      mechanism.</p>
          <ul>
            <li>fLastAlignedBounds: TRect</li>
          </ul>
          <p>See <link id="#lcl.Controls.TControl.SetAlignedBounds">TControl.SetAlignedBounds</link> for an explanation.
		      In short: It stops some circles between interface and LCL autosizing.</p>
          <ul>
            <li>FLastChangebounds: TRect</li>
          </ul>
          <p>Used to stop calling ChangeBounds with the same coordinates. This happens
		      very often.</p>
          <ul>
            <li>FLastDoChangeBounds: TRect</li>
          </ul>
          <p>Used to avoid calling OnChangeBounds with the same coordinates. This reduces
				      user defined autosizing.</p>
          <ul>
            <li>FLastResizeClientHeight: integer</li>
            <li>FLastResizeClientWidth: integer</li>
            <li>FLastResizeHeight: integer</li>
            <li>FLastResizeWidth: integer</li>
          </ul>
          <p>Used to avoid calling OnResize with the same coordinates. This reduces user
				      defined autosizing.</p>
          <ul>
            <li>FLoadedClientSize: TPoint</li>
          </ul>
          <p>During loading many things are delayed and many things are set and worse: in
				      the wrong order. That's why SetClientWidth/SetClientHeight calls are stored
				      and set at end of loading again.
				      This way the LCL can restore the distances (e.g. akRight) used during
				      designing.</p>
          <ul>
            <li>FReadBounds: TRect</li>
          </ul>
          <p>Same as FLoadedClientSize, but for SetLeft, SetTop, SetWidth, SetHeight.</p>
          <ul>
            <li>procedure SetBoundsRectForNewParent(const AValue: TRect);</li>
          </ul>
          <p>Used to set FBoundsRectForNewParent. See above.</p>
          <ul>
            <li>procedure SetAlignedBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;  </li>
          </ul>
          <p>Sets fLastAlignedBounds, see above.</p>
          <ul>
            <li>procedure SetInitialBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;</li>
          </ul>
          <p>A smart version of SetBounds, reducing overhead during creation and loading.</p>
          <ul>
            <li>procedure UpdateBaseBounds(StoreBounds, StoreParentClientSize, UseLoadedValues: boolean); virtual;</li>
          </ul>
          <p>Commit current bounds to base bounds.</p>
          <ul>
            <li>procedure SetClientHeight(Value: Integer);</li>
            <li>procedure SetClientSize(Value: TPoint);</li>
            <li>procedure SetClientWidth(Value: Integer);  </li>
          </ul>
          <p>Exists for Delphi compatibility too. Resizes the control, to get the wanted ClientRect size.</p>
          <ul>
            <li>procedure ChangeBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</li>
          </ul>
          <p>This is the internal SetBounds.
						      Applies constraints, updates base bounds, calls OnChangeBound, OnResize,
						      locks bounds.</p>
          <ul>
            <li>procedure DoSetBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</li>
          </ul>
          <p>This really sets the FLeft, FTop, FWidth, FHeight private variables.</p>
          <ul>
            <li>procedure SetBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;</li>
          </ul>
          <p>This is the standard procedure overriden by many Delphi controls. TWinControl overrides it too. </p>
          <p>Ignores calls when bounds are locked; lock the FBoundsRealized to avoid overhead to the interface during auto sizing.</p>
          <p>ChangeBounds is not locked this way.</p>
          <ul>
            <li>Function GetClientOrigin: TPoint; virtual;</li>
          </ul>
          <p>Screen coordinate of Left, Top of client area.</p>
          <ul>
            <li>Function GetClientRect: TRect; virtual;</li>
          </ul>
          <p>Size of client area. (always Left=0, Top=0)</p>
          <ul>
            <li>Function GetScrolledClientRect: TRect; virtual;</li>
          </ul>
          <p>Visible client area in ClientRect.</p>
          <ul>
            <li>function GetChildsRect(Scrolled: boolean): TRect; virtual;</li>
          </ul>
          <p>Returns the Client rectangle relative to the control's Left, Top.
						      If Scrolled is true, the rectangle is moved by the current scrolling values
						      (for an example see TScrollingWincontrol).</p>
          <ul>
            <li>function GetClientScrollOffset: TPoint; virtual;</li>
          </ul>
          <p>Returns the scrolling offset of the client area.</p>
          <ul>
            <li>function GetControlOrigin: TPoint; virtual;</li>
          </ul>
          <p>Returns the screen coordinate of the topleft coordinate 0,0 of the control area. (The topleft pixel of the control on the screen)
						      Note that this value is the position as stored in the interface and is not always in sync with the LCL. When a control is moved, the LCL sets the
bounds to the wanted position and sends a move message to the interface. It is up to the interface to handle moves instantly or queued.</p>
        </descr>
      </topic>
    </module>
    <!-- Controls -->
  </package>
</fpdoc-descriptions>
